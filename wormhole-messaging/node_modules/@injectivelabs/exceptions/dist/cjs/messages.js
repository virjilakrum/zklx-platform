"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.chainErrorMessagesMap = exports.chainModuleCodeErrorMessagesMap = void 0;
const types_1 = require("./types");
const auctionErrorMap = {
    [types_1.ChainAuctionErrorCodes.ErrBidInvalid]: 'The gas limit provided in the transaction is not valid',
    [types_1.ChainAuctionErrorCodes.ErrBidRound]: 'The gas limit provided in the transaction is not valid',
};
const authZErrorMap = {
    // ErrNoAuthorizationFound error if there is no authorization found given a grant key
    [types_1.ChainAuthZErrorCodes.ErrNoAuthorizationFound]: 'Authorization not found',
    // ErrInvalidExpirationTime error if the set expiration time is in the past
    [types_1.ChainAuthZErrorCodes.ErrInvalidExpirationTime]: 'Expiration time of authorization should be more than current time',
    // ErrUnknownAuthorizationType error for unknown authorization type
    [types_1.ChainAuthZErrorCodes.ErrUnknownAuthorizationType]: 'Unknown authorization type',
    // ErrNoGrantKeyFound error if the requested grant key does not exist
    [types_1.ChainAuthZErrorCodes.ErrNoGrantKeyFound]: 'Grant key not found',
    // ErrAuthorizationExpired error if the authorization has expired
    [types_1.ChainAuthZErrorCodes.ErrAuthorizationExpired]: 'Authorization expired',
    // ErrGranteeIsGranter error if the grantee and the granter are the same
    [types_1.ChainAuthZErrorCodes.ErrGranteeIsGranter]: 'Grantee and granter should be different',
    // ErrAuthorizationNumOfSigners error if an authorization message does not have only one signer
    [types_1.ChainAuthZErrorCodes.ErrAuthorizationNumOfSigners]: 'Authorization can be given to msg with only one signer',
    // ErrNegativeMaxTokens error if the max tokens is negative
    [types_1.ChainAuthZErrorCodes.ErrNegativeMaxTokens]: 'Max tokens should be positive',
};
const cosmosErrorMap = {
    [types_1.ChainCosmosErrorCode.ErrInsufficientFee]: 'You do not have enough funds to cover the transaction fees.',
    [types_1.ChainCosmosErrorCode.ErrInsufficientFunds]: 'You do not have enough funds.',
    [types_1.ChainCosmosErrorCode.ErrTxTimeoutHeight]: 'The transaction failed to be included within a block on time.',
    [types_1.ChainCosmosErrorCode.ErrTxDecode]: 'There is an issue while parsing the transaction',
    [types_1.ChainCosmosErrorCode.ErrInvalidSequence]: 'The sequence number is not valid',
    [types_1.ChainCosmosErrorCode.ErrUnauthorized]: 'Unauthorized',
    [types_1.ChainCosmosErrorCode.ErrUnknownRequest]: 'The request is not known',
    [types_1.ChainCosmosErrorCode.ErrInvalidAddress]: 'The address is not valid',
    [types_1.ChainCosmosErrorCode.ErrInvalidPubKey]: 'The public key is not valid',
    [types_1.ChainCosmosErrorCode.ErrUnknownAddress]: 'The address is unknown',
    [types_1.ChainCosmosErrorCode.ErrInvalidCoins]: 'The coins are not valid',
    [types_1.ChainCosmosErrorCode.ErrOutOfGas]: 'The transaction run out of gas',
    [types_1.ChainCosmosErrorCode.ErrMemoTooLarge]: 'The memo field in the transaction is too large',
    [types_1.ChainCosmosErrorCode.ErrTooManySignatures]: 'The transaction exceeded the maximum number of signatures',
    [types_1.ChainCosmosErrorCode.ErrNoSignatures]: 'There are no signatures appended on the transaction',
    [types_1.ChainCosmosErrorCode.ErrJSONMarshal]: 'There is an issue while parsing the transaction',
    [types_1.ChainCosmosErrorCode.ErrJSONUnmarshal]: 'There is an issue while parsing the transaction',
    [types_1.ChainCosmosErrorCode.ErrInvalidRequest]: 'invalid request',
    [types_1.ChainCosmosErrorCode.ErrTxInMempoolCache]: 'The transaction is already in the mempool',
    [types_1.ChainCosmosErrorCode.ErrMempoolIsFull]: 'The mempool is full',
    [types_1.ChainCosmosErrorCode.ErrTxTooLarge]: 'The transaction is too large',
    [types_1.ChainCosmosErrorCode.ErrKeyNotFound]: 'Account does not exist on chain. To create an account, send some tokens to it',
    [types_1.ChainCosmosErrorCode.ErrWrongPassword]: 'invalid account password',
    [types_1.ChainCosmosErrorCode.ErrorInvalidSigner]: 'tx intended signer does not match the given signer',
    [types_1.ChainCosmosErrorCode.ErrorInvalidGasAdjustment]: 'invalid gas adjustment',
    [types_1.ChainCosmosErrorCode.ErrInvalidHeight]: 'The height provided in the transaction is not valid',
    [types_1.ChainCosmosErrorCode.ErrInvalidVersion]: 'The version provided in the transaction is not valid',
    [types_1.ChainCosmosErrorCode.ErrInvalidChainID]: 'The chainId provided in the transaction is not valid',
    [types_1.ChainCosmosErrorCode.ErrInvalidType]: 'The type provided in the transaction is not valid',
    [types_1.ChainCosmosErrorCode.ErrUnknownExtensionOptions]: 'The extension options provided in the transaction is unknown',
    [types_1.ChainCosmosErrorCode.ErrWrongSequence]: 'The sequence number provided in the transaction is incorrect',
    [types_1.ChainCosmosErrorCode.ErrPackAny]: 'failed packing protobuf message to Any',
    [types_1.ChainCosmosErrorCode.ErrUnpackAny]: 'failed unpacking protobuf message from Any',
    [types_1.ChainCosmosErrorCode.ErrLogic]: 'Internal logic error',
    [types_1.ChainCosmosErrorCode.ErrConflict]: 'conflict',
    [types_1.ChainCosmosErrorCode.ErrNotSupported]: 'The feature is not supported',
    [types_1.ChainCosmosErrorCode.ErrNotFound]: 'not found',
    [types_1.ChainCosmosErrorCode.ErrIO]: 'Internal IO error',
    [types_1.ChainCosmosErrorCode.ErrAppConfig]: 'error in app.toml',
    [types_1.ChainCosmosErrorCode.ErrInvalidGasLimit]: 'The gas limit provided in the transaction is not valid',
};
const exchangeErrorMap = {
    [types_1.ChainExchangeModuleErrorCode.ErrOrderInvalid]: 'Your order failed to validate',
    [types_1.ChainExchangeModuleErrorCode.ErrSpotMarketNotFound]: 'The spot market has not been found',
    [types_1.ChainExchangeModuleErrorCode.ErrSpotMarketExists]: 'The spot market already exists',
    [types_1.ChainExchangeModuleErrorCode.ErrBadField]: 'There is an issue with your order',
    [types_1.ChainExchangeModuleErrorCode.ErrMarketInvalid]: 'The market failed to validate',
    [types_1.ChainExchangeModuleErrorCode.ErrInsufficientDeposit]: 'Your trading account has insufficient funds',
    [types_1.ChainExchangeModuleErrorCode.ErrUnrecognizedOrderType]: 'The order type is not recognized',
    [types_1.ChainExchangeModuleErrorCode.ErrInsufficientPositionQuantity]: 'The position quantity is insufficient for the order',
    [types_1.ChainExchangeModuleErrorCode.ErrOrderHashInvalid]: 'The order hash is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrBadSubaccountID]: 'The subaccount id is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidBaseDenom]: '',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidExpiry]: 'The expiry date is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidPrice]: 'The price is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidQuantity]: 'The quantity is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrUnsupportedOracleType]: 'The oracle type is not supported',
    [types_1.ChainExchangeModuleErrorCode.ErrOrderDoesntExist]: 'The order does not exist',
    [types_1.ChainExchangeModuleErrorCode.ErrOrderbookFillInvalid]: '',
    [types_1.ChainExchangeModuleErrorCode.ErrPerpetualMarketExists]: 'The perpetual market already exists',
    [types_1.ChainExchangeModuleErrorCode.ErrExpiryFuturesMarketExists]: 'The expiry futures market market already exists',
    [types_1.ChainExchangeModuleErrorCode.ErrExpiryFuturesMarketExpired]: 'The expiry futures market has expired',
    [types_1.ChainExchangeModuleErrorCode.ErrNoLiquidity]: 'There is not enough liquidity',
    [types_1.ChainExchangeModuleErrorCode.ErrSlippageExceedsWorstPrice]: 'There is not enough liquidity',
    [types_1.ChainExchangeModuleErrorCode.ErrInsufficientOrderMargin]: 'The order has insufficient margin',
    [types_1.ChainExchangeModuleErrorCode.ErrDerivativeMarketNotFound]: 'The derivative market cannot be found',
    [types_1.ChainExchangeModuleErrorCode.ErrPositionNotFound]: 'The position cannot be found',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidReduceOnlyPositionDirection]: 'Position direction does not oppose the reduce-only order',
    [types_1.ChainExchangeModuleErrorCode.ErrPriceSurpassesBankruptcyPrice]: 'Your order price surpasses bankruptcy price',
    [types_1.ChainExchangeModuleErrorCode.ErrPositionNotLiquidable]: 'The position is not liquidable',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidTriggerPrice]: 'Your order trigger price is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidOracleType]: 'The oracle type is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidPriceTickSize]: 'The minimum price tick size is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidQuantityTickSize]: 'The minimum quantity tick size is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidMargin]: "Your order's minimum margin is not valid ",
    [types_1.ChainExchangeModuleErrorCode.ErrExceedsOrderSideCount]: 'You cannot have more orders for this market for this direction',
    [types_1.ChainExchangeModuleErrorCode.ErrMarketOrderAlreadyExists]: 'You cannot place another market order within this block',
    [types_1.ChainExchangeModuleErrorCode.ErrConditionalMarketOrderAlreadyExists]: 'You cannot place another conditional market order',
    [types_1.ChainExchangeModuleErrorCode.ErrMarketLaunchProposalAlreadyExists]: 'There is an existing equivalent market launch proposal.',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidMarketStatus]: 'The market status is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrSameDenoms]: 'The base denom and quote denom cannot be same',
    [types_1.ChainExchangeModuleErrorCode.ErrSameOracles]: 'The oracle base and the oracle quote cannot be the same',
    [types_1.ChainExchangeModuleErrorCode.ErrFeeRatesRelation]: 'The MakerFeeRate does not match TakerFeeRate requirements',
    [types_1.ChainExchangeModuleErrorCode.ErrMarginsRelation]: 'The MaintenanceMarginRatio cannot be greater than InitialMarginRatio',
    [types_1.ChainExchangeModuleErrorCode.ErrExceedsMaxOracleScaleFactor]: 'The OracleScaleFactor cannot be greater than MaxOracleScaleFactor',
    [types_1.ChainExchangeModuleErrorCode.ErrSpotExchangeNotEnabled]: 'Spot exchange is not enabled yet',
    [types_1.ChainExchangeModuleErrorCode.ErrDerivativesExchangeNotEnabled]: 'Derivatives exchange is not enabled yet',
    [types_1.ChainExchangeModuleErrorCode.ErrOraclePriceDeltaExceedsThreshold]: 'The oracle price delta exceeds threshold',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidHourlyInterestRate]: 'The hourly interest rate is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidHourlyFundingRateCap]: 'The hourly funding rate cap is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidMarketFundingParamUpdate]: 'You can only update funding parameters on perpetual markets.',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidTradingRewardCampaign]: 'The trading reward campaign is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidFeeDiscountSchedule]: 'The fee discount schedule is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidLiquidationOrder]: 'The liquidation order is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrTradingRewardCampaignDistributionError]: 'Unknown error happened for campaign distributions',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidTradingRewardsPendingPointsUpdate]: 'The updated trading reward points is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidBatchMsgUpdate]: 'The MsgBatchUpdate is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrExceedsTopOfBookPrice]: 'The post-only order price exceeds top of the orderbook price',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidOrderTypeForMessage]: 'The order type is not supported for this message',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidDMMSender]: 'The sender must match the DMM address',
    [types_1.ChainExchangeModuleErrorCode.ErrAlreadyOptedOutOfRewards]: 'The DMM address already opted out of rewards',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidMarginRatio]: 'The margin ratio is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrBelowMinimalContribution]: 'The provided funds are below minimum',
    [types_1.ChainExchangeModuleErrorCode.ErrLowPositionMargin]: 'The position is below initial margin requirement',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidTotalSupply]: 'The pool has non-positive total LP token supply',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidLpTokenBurnAmount]: 'The passed LP token burn amount is greater than total LP token supply',
    [types_1.ChainExchangeModuleErrorCode.ErrUnsupportedAction]: 'This action is not supported',
    [types_1.ChainExchangeModuleErrorCode.ErrNegativePositionQuantity]: 'The position quantity cannot be negative',
    [types_1.ChainExchangeModuleErrorCode.ErrBinaryOptionsMarketExists]: 'The BinaryOptions market already exists',
    [types_1.ChainExchangeModuleErrorCode.ErrBinaryOptionsMarketNotFound]: 'The BinaryOptions market cannot be found',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidSettlement]: 'The settlement price is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrAccountDoesntExist]: 'The trading account does not exist',
    [types_1.ChainExchangeModuleErrorCode.ErrSenderIsNotAnAdmin]: 'The sender should be the admin of the market',
    [types_1.ChainExchangeModuleErrorCode.ErrMarketAlreadyScheduledToSettle]: 'The market is already scheduled to settle ',
    [types_1.ChainExchangeModuleErrorCode.ErrGenericMarketNotFound]: 'The market cannot be found',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidDenomDecimal]: 'The denom decimal cannot be below 1 or above max scale factor',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidState]: 'The state is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrTransientOrdersUpToCancelNotSupported]: 'The transient orders up to cancellation not supported',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidTrade]: 'The trade is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrNoMarginLocked]: 'There is no margin locked in the trading account',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidAccessLevel]: 'There is no access to perform action',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidAddress]: 'The address is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidArgument]: 'The argument is not valid',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidFundsDirection]: 'Invalid funds direction',
    [types_1.ChainExchangeModuleErrorCode.ErrNoFundsProvided]: 'No funds provided',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidSignature]: 'Invalid signature',
    [types_1.ChainExchangeModuleErrorCode.ErrNoFundsToUnlock]: 'No funds to unlock',
    [types_1.ChainExchangeModuleErrorCode.ErrNoMsgsProvided]: 'No msgs provided',
    [types_1.ChainExchangeModuleErrorCode.ErrNoMsgProvided]: 'No msg provided',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidAmount]: 'Invalid amount',
    [types_1.ChainExchangeModuleErrorCode.ErrFeatureDisabled]: 'The current feature has been disabled',
    [types_1.ChainExchangeModuleErrorCode.ErrTooMuchOrderMargin]: 'Order has too much margin',
    [types_1.ChainExchangeModuleErrorCode.ErrBadSubaccountNonce]: 'Subaccount nonce is invalid',
    [types_1.ChainExchangeModuleErrorCode.ErrInsufficientFunds]: 'Insufficient funds',
    [types_1.ChainExchangeModuleErrorCode.ErrPostOnlyMode]: 'Only post-only actions available for approximately 30 minutes after a chain upgrade.',
    [types_1.ChainExchangeModuleErrorCode.ErrClientOrderIdAlreadyExists]: 'Client order id already exists',
    [types_1.ChainExchangeModuleErrorCode.ErrInvalidCid]: 'Client order id is invalid. Max length is 36 chars',
};
const insuranceErrorMap = {
    [types_1.ChainInsuranceErrorCodes.ErrInsuranceFundAlreadyExists]: 'The insurance fund already exists',
    [types_1.ChainInsuranceErrorCodes.ErrInsuranceFundNotFound]: 'The insurance fund is not found',
    [types_1.ChainInsuranceErrorCodes.ErrRedemptionAlreadyExists]: 'The redemption already exists',
    [types_1.ChainInsuranceErrorCodes.ErrInvalidDepositAmount]: 'The deposit amount is not valid',
    [types_1.ChainInsuranceErrorCodes.ErrInvalidDepositDenom]: 'The deposit denom is not valid',
    [types_1.ChainInsuranceErrorCodes.ErrPayoutTooLarge]: 'The insurance fund payout exceeds the deposits',
    [types_1.ChainInsuranceErrorCodes.ErrInvalidTicker]: 'The ticker is not valid',
    [types_1.ChainInsuranceErrorCodes.ErrInvalidQuoteDenom]: 'The quote denom is not valid',
    [types_1.ChainInsuranceErrorCodes.ErrInvalidOracle]: 'The oracle is not valid',
    [types_1.ChainInsuranceErrorCodes.ErrInvalidExpirationTime]: 'The expiration time is not valid',
    [types_1.ChainInsuranceErrorCodes.ErrInvalidMarketID]: 'The marketId is not valid',
    [types_1.ChainInsuranceErrorCodes.ErrInvalidShareDenom]: 'The share denom is not valid',
};
const ocrErrorMap = {
    [types_1.ChainOcrErrorCodes.ErrStaleReport]: 'stale report',
    [types_1.ChainOcrErrorCodes.ErrIncompleteProposal]: 'incomplete proposal',
    [types_1.ChainOcrErrorCodes.ErrRepeatedAddress]: 'repeated oracle address',
    [types_1.ChainOcrErrorCodes.ErrTooManySigners]: 'too many signers',
    [types_1.ChainOcrErrorCodes.ErrIncorrectConfig]: 'incorrect config',
    [types_1.ChainOcrErrorCodes.ErrConfigDigestNotMatch]: "config digest doesn't match",
    [types_1.ChainOcrErrorCodes.ErrWrongNumberOfSignatures]: 'wrong number of signatures',
    [types_1.ChainOcrErrorCodes.ErrIncorrectSignature]: 'incorrect signature',
    [types_1.ChainOcrErrorCodes.ErrNoTransmitter]: 'no transmitter specified',
    [types_1.ChainOcrErrorCodes.ErrIncorrectTransmissionData]: 'incorrect transmission data',
    [types_1.ChainOcrErrorCodes.ErrNoTransmissionsFound]: 'no transmissions found',
    [types_1.ChainOcrErrorCodes.ErrMedianValueOutOfBounds]: 'median value is out of bounds',
    [types_1.ChainOcrErrorCodes.ErrIncorrectRewardPoolDenom]: "LINK denom doesn't match",
    [types_1.ChainOcrErrorCodes.ErrNoRewardPool]: "Reward Pool doesn't exist",
    [types_1.ChainOcrErrorCodes.ErrInvalidPayees]: 'wrong number of payees and transmitters',
    [types_1.ChainOcrErrorCodes.ErrModuleAdminRestricted]: 'action is restricted to the module admin',
    [types_1.ChainOcrErrorCodes.ErrFeedAlreadyExists]: 'feed already exists',
    [types_1.ChainOcrErrorCodes.ErrFeedDoesntExists]: 'feed doesnt exists',
    [types_1.ChainOcrErrorCodes.ErrAdminRestricted]: 'action is admin-restricted',
    [types_1.ChainOcrErrorCodes.ErrInsufficientRewardPool]: 'insufficient reward pool',
    [types_1.ChainOcrErrorCodes.ErrPayeeAlreadySet]: 'payee already set',
    [types_1.ChainOcrErrorCodes.ErrPayeeRestricted]: 'action is payee-restricted',
    [types_1.ChainOcrErrorCodes.ErrFeedConfigNotFound]: 'feed config not found',
};
const oracleErrorMap = {
    [types_1.ChainOracleErrorCodes.ErrEmptyRelayerAddr]: 'relayer address is empty',
    [types_1.ChainOracleErrorCodes.ErrBadRatesCount]: 'bad rates count',
    [types_1.ChainOracleErrorCodes.ErrBadResolveTimesCount]: 'bad resolve times',
    [types_1.ChainOracleErrorCodes.ErrBadRequestIDsCount]: 'bad request ID',
    [types_1.ChainOracleErrorCodes.ErrRelayerNotAuthorized]: 'relayer not authorized',
    [types_1.ChainOracleErrorCodes.ErrBadPriceFeedBaseCount]: 'bad price feed base count',
    [types_1.ChainOracleErrorCodes.ErrBadPriceFeedQuoteCount]: 'bad price feed quote count',
    [types_1.ChainOracleErrorCodes.ErrUnsupportedOracleType]: 'unsupported oracle type',
    [types_1.ChainOracleErrorCodes.ErrBadMessagesCount]: 'bad messages count',
    [types_1.ChainOracleErrorCodes.ErrBadCoinbaseMessage]: 'bad Coinbase message',
    [types_1.ChainOracleErrorCodes.ErrInvalidEthereumSignature]: 'bad Ethereum signature',
    [types_1.ChainOracleErrorCodes.ErrBadCoinbaseMessageTimestamp]: 'bad Coinbase message timestamp',
    [types_1.ChainOracleErrorCodes.ErrCoinbasePriceNotFound]: 'Coinbase price not found',
    [types_1.ChainOracleErrorCodes.ErrBadPrice]: 'Prices must be positive',
    [types_1.ChainOracleErrorCodes.ErrPriceTooLarge]: 'Prices must be less than 10 million.',
    [types_1.ChainOracleErrorCodes.ErrInvalidBandIBCRequest]: 'Invalid Band IBC Request',
    [types_1.ChainOracleErrorCodes.ErrSample]: 'sample error',
    [types_1.ChainOracleErrorCodes.ErrInvalidPacketTimeout]: 'invalid packet timeout',
    [types_1.ChainOracleErrorCodes.ErrBadSymbolsCount]: 'invalid symbols count',
    [types_1.ChainOracleErrorCodes.ErrBadIBCPortBind]: 'could not claim port capability',
    [types_1.ChainOracleErrorCodes.ErrInvalidPortID]: 'invalid IBC Port ID',
    [types_1.ChainOracleErrorCodes.ErrInvalidChannelID]: 'invalid IBC Channel ID',
    [types_1.ChainOracleErrorCodes.ErrBadRequestInterval]: 'invalid Band IBC request interval',
    [types_1.ChainOracleErrorCodes.ErrInvalidBandIBCUpdateRequest]: 'Invalid Band IBC Update Request Proposal',
    [types_1.ChainOracleErrorCodes.ErrBandIBCRequestNotFound]: 'Band IBC Oracle Request not found',
    [types_1.ChainOracleErrorCodes.ErrEmptyBaseInfo]: 'Base Info is empty',
    [types_1.ChainOracleErrorCodes.ErrEmptyProvider]: 'provider is empty',
    [types_1.ChainOracleErrorCodes.ErrInvalidProvider]: 'invalid provider name',
    [types_1.ChainOracleErrorCodes.ErrInvalidSymbol]: 'invalid symbol',
    [types_1.ChainOracleErrorCodes.ErrRelayerAlreadyExists]: 'relayer already exists',
    [types_1.ChainOracleErrorCodes.ErrProviderPriceNotFound]: 'provider price not found',
    [types_1.ChainOracleErrorCodes.ErrInvalidOracleRequest]: 'invalid oracle request',
    [types_1.ChainOracleErrorCodes.ErrOraclePriceNotFound]: 'no price for oracle was found',
};
const peggyErrorMap = {
    [types_1.ChainPeggyErrorCodes.ErrInternal]: 'internal',
    [types_1.ChainPeggyErrorCodes.ErrDuplicate]: 'duplicate',
    [types_1.ChainPeggyErrorCodes.ErrInvalid]: 'invalid',
    [types_1.ChainPeggyErrorCodes.ErrTimeout]: 'timeout',
    [types_1.ChainPeggyErrorCodes.ErrUnknown]: 'unknown',
    [types_1.ChainPeggyErrorCodes.ErrEmpty]: 'empty',
    [types_1.ChainPeggyErrorCodes.ErrOutdated]: 'outdated',
    [types_1.ChainPeggyErrorCodes.ErrUnsupported]: 'unsupported',
    [types_1.ChainPeggyErrorCodes.ErrNonContiguousEventNonce]: 'non contiguous event nonce',
    [types_1.ChainPeggyErrorCodes.ErrNoUnbatchedTxsFound]: 'no unbatched txs found',
    [types_1.ChainPeggyErrorCodes.ErrResetDelegateKeys]: 'can not set orchestrator addresses more than once',
    [types_1.ChainPeggyErrorCodes.ErrSupplyOverflow]: 'supply cannot exceed max ERC20 value',
    [types_1.ChainPeggyErrorCodes.ErrInvalidEthSender]: 'invalid ethereum sender on claim',
    [types_1.ChainPeggyErrorCodes.ErrInvalidEthDestination]: 'invalid ethereum destination',
};
const tokenFactoryErrorMap = {
    [types_1.ChainTokenFactoryErrorCodes.ErrDenomExists]: 'attempting to create a denom that already exists',
    [types_1.ChainTokenFactoryErrorCodes.ErrUnauthorized]: 'unauthorized account',
    [types_1.ChainTokenFactoryErrorCodes.ErrInvalidDenom]: 'invalid denom',
    [types_1.ChainTokenFactoryErrorCodes.ErrInvalidCreator]: 'invalid creator',
    [types_1.ChainTokenFactoryErrorCodes.ErrInvalidAuthorityMetadata]: 'invalid authority metadata',
    [types_1.ChainTokenFactoryErrorCodes.ErrInvalidGenesis]: 'invalid genesis',
    [types_1.ChainTokenFactoryErrorCodes.ErrSubdenomTooLong]: 'subdenom too long',
    [types_1.ChainTokenFactoryErrorCodes.ErrSubdenomTooShort]: 'subdenom too short',
    [types_1.ChainTokenFactoryErrorCodes.ErrSubdenomNestedTooShort]: 'nested subdenom too short, each one should have at least',
    [types_1.ChainTokenFactoryErrorCodes.ErrCreatorTooLong]: 'creator too long',
    [types_1.ChainTokenFactoryErrorCodes.ErrDenomDoesNotExist]: 'denom does not exist',
};
const wasmxErrorMap = {
    [types_1.ChainWasmXErrorCodes.ErrInvalidGasLimit]: 'invalid gas limit',
    [types_1.ChainWasmXErrorCodes.ErrInvalidGasPrice]: 'invalid gas price',
    [types_1.ChainWasmXErrorCodes.ErrInvalidContractAddress]: 'invalid contract address',
    [types_1.ChainWasmXErrorCodes.ErrAlreadyRegistered]: 'contract already registered',
    [types_1.ChainWasmXErrorCodes.ErrDuplicateContract]: 'duplicate contract',
    [types_1.ChainWasmXErrorCodes.ErrNoContractAddresses]: 'no contract addresses found',
    [types_1.ChainWasmXErrorCodes.ErrInvalidCodeId]: 'invalid code id',
};
const stakingErrorMap = {
    [types_1.ChainStakingErrorCodes.ErrEmptyValidatorAddr]: 'empty validator address',
    [types_1.ChainStakingErrorCodes.ErrNoValidatorFound]: 'validator does not exist',
    [types_1.ChainStakingErrorCodes.ErrValidatorOwnerExists]: 'validator already exist for this operator address; must use new validator operator address',
    [types_1.ChainStakingErrorCodes.ErrValidatorPubKeyExists]: 'validator already exist for this pubkey; must use new validator pubkey',
    [types_1.ChainStakingErrorCodes.ErrValidatorPubKeyTypeNotSupported]: 'validator pubkey type is not supported',
    [types_1.ChainStakingErrorCodes.ErrValidatorJailed]: 'validator for this address is currently jailed',
    [types_1.ChainStakingErrorCodes.ErrBadRemoveValidator]: 'failed to remove validator',
    [types_1.ChainStakingErrorCodes.ErrCommissionNegative]: 'commission must be positive',
    [types_1.ChainStakingErrorCodes.ErrCommissionHuge]: 'commission cannot be more than 100%',
    [types_1.ChainStakingErrorCodes.ErrCommissionGTMaxRate]: 'commission cannot be more than the max rate',
    [types_1.ChainStakingErrorCodes.ErrCommissionUpdateTime]: 'commission cannot be changed more than once in 24h',
    [types_1.ChainStakingErrorCodes.ErrCommissionChangeRateNegative]: 'commission change rate must be positive',
    [types_1.ChainStakingErrorCodes.ErrCommissionChangeRateGTMaxRate]: 'commission change rate cannot be more than the max rate',
    [types_1.ChainStakingErrorCodes.ErrCommissionGTMaxChangeRate]: 'commission cannot be changed more than max change rate',
    [types_1.ChainStakingErrorCodes.ErrSelfDelegationBelowMinimum]: "validator's self delegation must be greater than their minimum self delegation",
    [types_1.ChainStakingErrorCodes.ErrMinSelfDelegationDecreased]: 'minimum self delegation cannot be decrease',
    [types_1.ChainStakingErrorCodes.ErrEmptyDelegatorAddr]: 'empty delegator address',
    [types_1.ChainStakingErrorCodes.ErrNoDelegation]: 'no delegation for (address, validator) tuple',
    [types_1.ChainStakingErrorCodes.ErrBadDelegatorAddr]: 'delegator does not exist with address',
    [types_1.ChainStakingErrorCodes.ErrNoDelegatorForAddress]: 'delegator does not contain delegation',
    [types_1.ChainStakingErrorCodes.ErrInsufficientShares]: 'insufficient delegation shares',
    [types_1.ChainStakingErrorCodes.ErrDelegationValidatorEmpty]: 'cannot delegate to an empty validator',
    [types_1.ChainStakingErrorCodes.ErrNotEnoughDelegationShares]: 'not enough delegation shares',
    [types_1.ChainStakingErrorCodes.ErrNotMature]: 'entry not mature',
    [types_1.ChainStakingErrorCodes.ErrNoUnbondingDelegation]: 'no unbonding delegation found',
    [types_1.ChainStakingErrorCodes.ErrMaxUnbondingDelegationEntries]: 'too many unbonding delegation entries for (delegator, validator) tuple',
    [types_1.ChainStakingErrorCodes.ErrNoRedelegation]: 'no redelegation found',
    [types_1.ChainStakingErrorCodes.ErrSelfRedelegation]: 'cannot redelegate to the same validator',
    [types_1.ChainStakingErrorCodes.ErrTinyRedelegationAmount]: 'too few tokens to redelegate (truncates to zero tokens)',
    [types_1.ChainStakingErrorCodes.ErrBadRedelegationDst]: 'redelegation destination validator not found',
    [types_1.ChainStakingErrorCodes.ErrTransitiveRedelegation]: 'redelegation to this validator already in progress; first redelegation to this validator must complete before next redelegation',
    [types_1.ChainStakingErrorCodes.ErrMaxRedelegationEntries]: 'too many redelegation entries for (delegator, src-validator, dst-validator) tuple',
    [types_1.ChainStakingErrorCodes.ErrDelegatorShareExRateInvalid]: 'cannot delegate to validators with invalid (zero) ex-rate',
    [types_1.ChainStakingErrorCodes.ErrBothShareMsgsGiven]: 'both shares amount and shares percent provided',
    [types_1.ChainStakingErrorCodes.ErrNeitherShareMsgsGiven]: 'neither shares amount nor shares percent provided',
    [types_1.ChainStakingErrorCodes.ErrInvalidHistoricalInfo]: 'invalid historical info',
    [types_1.ChainStakingErrorCodes.ErrNoHistoricalInfo]: 'no historical info found',
    [types_1.ChainStakingErrorCodes.ErrEmptyValidatorPubKey]: 'empty validator public key',
    [types_1.ChainStakingErrorCodes.ErrCommissionLTMinRate]: 'commission cannot be less than min rate',
    [types_1.ChainStakingErrorCodes.ErrUnbondingNotFound]: 'unbonding operation not found',
    [types_1.ChainStakingErrorCodes.ErrUnbondingOnHoldRefCountNegative]: 'cannot un-hold unbonding operation that is not on hold',
};
const govErrorMap = {
    [types_1.ChainGovErrorCodes.ErrUnknownProposal]: 'unknown proposal',
    [types_1.ChainGovErrorCodes.ErrInactiveProposal]: 'inactive proposal',
    [types_1.ChainGovErrorCodes.ErrAlreadyActiveProposal]: 'proposal already active',
    [types_1.ChainGovErrorCodes.ErrInvalidProposalContent]: 'invalid proposal content',
    [types_1.ChainGovErrorCodes.ErrInvalidProposalType]: 'invalid proposal type',
    [types_1.ChainGovErrorCodes.ErrInvalidVote]: 'invalid vote option',
    [types_1.ChainGovErrorCodes.ErrInvalidGenesis]: 'invalid genesis state',
    [types_1.ChainGovErrorCodes.ErrNoProposalHandlerExists]: 'no handler exists for proposal type',
    [types_1.ChainGovErrorCodes.ErrUnroutableProposalMsg]: 'proposal message not recognized by router',
    [types_1.ChainGovErrorCodes.ErrNoProposalMsgs]: 'no messages proposed',
    [types_1.ChainGovErrorCodes.ErrInvalidProposalMsg]: 'invalid proposal message',
    [types_1.ChainGovErrorCodes.ErrInvalidSigner]: 'expected gov account as only signer for proposal message',
    [types_1.ChainGovErrorCodes.ErrInvalidSignalMsg]: 'signal message is invalid',
    [types_1.ChainGovErrorCodes.ErrMetadataTooLong]: 'metadata too long',
    [types_1.ChainGovErrorCodes.ErrMinDepositTooSmall]: 'minimum deposit is too small',
    [types_1.ChainGovErrorCodes.ErrProposalNotFound]: 'proposal is not found',
    [types_1.ChainGovErrorCodes.ErrInvalidProposer]: 'invalid proposer',
    [types_1.ChainGovErrorCodes.ErrNoDeposits]: 'no deposits found',
    [types_1.ChainGovErrorCodes.ErrVotingPeriodEnded]: 'voting period already ended',
    [types_1.ChainGovErrorCodes.ErrInvalidProposal]: 'invalid proposal',
};
const bankErrorMap = {
    [types_1.ChainBankErrorCodes.ErrNoInputs]: 'no inputs to send transaction',
    [types_1.ChainBankErrorCodes.ErrNoOutputs]: 'no outputs to send transaction',
    [types_1.ChainBankErrorCodes.ErrInputOutputMismatch]: 'sum inputs != sum outputs',
    [types_1.ChainBankErrorCodes.ErrSendDisabled]: 'send transactions are disabled',
    [types_1.ChainBankErrorCodes.ErrDenomMetadataNotFound]: 'client denom metadata not found',
    [types_1.ChainBankErrorCodes.ErrInvalidKey]: 'invalid key',
    [types_1.ChainBankErrorCodes.ErrDuplicateEntry]: 'duplicate entry',
    [types_1.ChainBankErrorCodes.ErrMultipleSenders]: 'multiple senders not allowed',
};
const distributionErrorMap = {
    [types_1.ChainDistributionErrorCodes.ErrEmptyDelegatorAddr]: 'delegator address is empty',
    [types_1.ChainDistributionErrorCodes.ErrEmptyWithdrawAddr]: 'withdraw address is empty',
    [types_1.ChainDistributionErrorCodes.ErrEmptyValidatorAddr]: 'validator address is empty',
    [types_1.ChainDistributionErrorCodes.ErrEmptyDelegationDistInfo]: 'no delegation distribution info',
    [types_1.ChainDistributionErrorCodes.ErrNoValidatorDistInfo]: 'no validator distribution info',
    [types_1.ChainDistributionErrorCodes.ErrNoValidatorCommission]: 'no validator commission to withdraw',
    [types_1.ChainDistributionErrorCodes.ErrSetWithdrawAddrDisabled]: 'set withdraw address disabled',
    [types_1.ChainDistributionErrorCodes.ErrBadDistribution]: 'community pool does not have sufficient coins to distribute',
    [types_1.ChainDistributionErrorCodes.ErrInvalidProposalAmount]: 'invalid community pool spend proposal amount',
    [types_1.ChainDistributionErrorCodes.ErrEmptyProposalRecipient]: 'invalid community pool spend proposal recipient',
    [types_1.ChainDistributionErrorCodes.ErrNoValidatorExists]: 'validator does not exist',
    [types_1.ChainDistributionErrorCodes.ErrNoDelegationExists]: 'delegation does not exist',
};
const wasmErrorMap = {
    [types_1.ChainWasmErrorCodes.ErrCreateFailed]: 'create wasm contract failed',
    [types_1.ChainWasmErrorCodes.ErrAccountExists]: 'contract account already exists',
    [types_1.ChainWasmErrorCodes.ErrInstantiateFailed]: 'instantiate wasm contract failed',
    [types_1.ChainWasmErrorCodes.ErrExecuteFailed]: 'Contract execution failed',
    [types_1.ChainWasmErrorCodes.ErrGasLimit]: 'insufficient gas',
    [types_1.ChainWasmErrorCodes.ErrInvalidGenesis]: 'invalid genesis',
    [types_1.ChainWasmErrorCodes.ErrNotFound]: 'not found',
    [types_1.ChainWasmErrorCodes.ErrQueryFailed]: 'query wasm contract failed',
    [types_1.ChainWasmErrorCodes.ErrInvalidMsg]: 'invalid CosmosMsg from the contract',
    [types_1.ChainWasmErrorCodes.ErrMigrationFailed]: 'migrate wasm contract failed',
    [types_1.ChainWasmErrorCodes.ErrEmpty]: 'empty',
    [types_1.ChainWasmErrorCodes.ErrLimit]: 'exceeds limit',
    [types_1.ChainWasmErrorCodes.ErrInvalid]: 'invalid',
    [types_1.ChainWasmErrorCodes.ErrDuplicate]: 'duplicate',
    [types_1.ChainWasmErrorCodes.ErrMaxIBCChannels]: 'max transfer channels',
    [types_1.ChainWasmErrorCodes.ErrUnsupportedForContract]: 'unsupported for this contract',
    [types_1.ChainWasmErrorCodes.ErrPinContractFailed]: 'pinning contract failed',
    [types_1.ChainWasmErrorCodes.ErrUnpinContractFailed]: 'unpinning contract failed',
    [types_1.ChainWasmErrorCodes.ErrUnknownMsg]: 'unknown message from the contract',
    [types_1.ChainWasmErrorCodes.ErrInvalidEvent]: 'invalid event',
};
exports.chainModuleCodeErrorMessagesMap = {
    [types_1.TransactionChainErrorModule.AuthZ]: authZErrorMap,
    [types_1.TransactionChainErrorModule.Auction]: auctionErrorMap,
    [types_1.TransactionChainErrorModule.CosmosSdk]: cosmosErrorMap,
    [types_1.TransactionChainErrorModule.Exchange]: exchangeErrorMap,
    [types_1.TransactionChainErrorModule.Insurance]: insuranceErrorMap,
    [types_1.TransactionChainErrorModule.Ocr]: ocrErrorMap,
    [types_1.TransactionChainErrorModule.Oracle]: oracleErrorMap,
    [types_1.TransactionChainErrorModule.Peggy]: peggyErrorMap,
    [types_1.TransactionChainErrorModule.TokenFactory]: tokenFactoryErrorMap,
    [types_1.TransactionChainErrorModule.Wasmx]: wasmxErrorMap,
    [types_1.TransactionChainErrorModule.Wasm]: wasmErrorMap,
    [types_1.TransactionChainErrorModule.Staking]: stakingErrorMap,
    [types_1.TransactionChainErrorModule.Bank]: bankErrorMap,
    [types_1.TransactionChainErrorModule.Gov]: govErrorMap,
    [types_1.TransactionChainErrorModule.Distribution]: distributionErrorMap,
};
/**
 * **Legacy** but needed for error messages from broadcasting transactions
 * where we don't control the response and only have the message
 * i.e Keplr, Leap, etc
 */
exports.chainErrorMessagesMap = {
    'insufficient fee': {
        message: 'You do not have enough funds to cover the transaction fees.',
        code: types_1.ChainCosmosErrorCode.ErrInsufficientFee,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'insufficient funds': {
        message: 'You do not have enough funds.',
        code: types_1.ChainCosmosErrorCode.ErrInsufficientFunds,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'tx timeout height': {
        message: 'The transaction failed to be included within a block on time.',
        code: types_1.ChainCosmosErrorCode.ErrTxTimeoutHeight,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'tx parse error': {
        message: 'There is an issue while parsing the transaction',
        code: types_1.ChainCosmosErrorCode.ErrTxDecode,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'invalid sequence': {
        message: 'The sequence number is not valid',
        code: types_1.ChainCosmosErrorCode.ErrInvalidSequence,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    unauthorized: {
        message: 'Unauthorized',
        code: types_1.ChainCosmosErrorCode.ErrUnauthorized,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'invalid address': {
        message: 'The address is not valid',
        code: types_1.ChainCosmosErrorCode.ErrInvalidAddress,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'cosmos account not exists': {
        message: 'You need to create your address on Injective by transferring funds',
        code: types_1.ChainCosmosErrorCode.ErrInsufficientFee,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'invalid pubkey': {
        message: 'The public key is not valid',
        code: types_1.ChainCosmosErrorCode.ErrInvalidPubKey,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'unknown address': {
        message: 'The address is unknown',
        code: types_1.ChainCosmosErrorCode.ErrUnknownAddress,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'invalid coins': {
        message: 'The coins are not valid',
        code: types_1.ChainCosmosErrorCode.ErrInvalidCoins,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'out of gas': {
        message: 'The transaction run out of gas',
        code: types_1.ChainCosmosErrorCode.ErrOutOfGas,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'memo too large': {
        message: 'The memo field in the transaction is too large',
        code: types_1.ChainCosmosErrorCode.ErrMemoTooLarge,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'maximum number of signatures exceeded': {
        message: 'The transaction exceeded the maximum number of signatures',
        code: types_1.ChainCosmosErrorCode.ErrTooManySignatures,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'no signatures supplied': {
        message: 'There are no signatures appended on the transaction',
        code: types_1.ChainCosmosErrorCode.ErrNoSignatures,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'failed to marshal JSON bytes': {
        message: 'There is an issue while parsing the transaction',
        code: types_1.ChainCosmosErrorCode.ErrJSONMarshal,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'failed to unmarshal JSON bytes': {
        message: 'There is an issue while parsing the transaction',
        code: types_1.ChainCosmosErrorCode.ErrJSONUnmarshal,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'invalid request': {
        message: 'invalid request',
        code: types_1.ChainCosmosErrorCode.ErrInvalidRequest,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'tx already in mempool': {
        message: 'The transaction is already in the mempool',
        code: types_1.ChainCosmosErrorCode.ErrTxInMempoolCache,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'mempool is full': {
        message: 'The mempool is full',
        code: types_1.ChainCosmosErrorCode.ErrMempoolIsFull,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'tx too large': {
        message: 'The transaction is too large',
        code: types_1.ChainCosmosErrorCode.ErrTxTooLarge,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'key not found': {
        message: 'Account does not exist on chain. To create an account, send some tokens to it',
        code: types_1.ChainCosmosErrorCode.ErrKeyNotFound,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'invalid account password': {
        message: 'invalid account password',
        code: types_1.ChainCosmosErrorCode.ErrWrongPassword,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'tx intended signer does not match the given signer': {
        message: 'tx intended signer does not match the given signer',
        code: types_1.ChainCosmosErrorCode.ErrorInvalidSigner,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'invalid gas adjustment': {
        message: 'invalid gas adjustment',
        code: types_1.ChainCosmosErrorCode.ErrorInvalidGasAdjustment,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'invalid height': {
        message: 'The height provided in the transaction is not valid',
        code: types_1.ChainCosmosErrorCode.ErrInvalidHeight,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'invalid version': {
        message: 'The version provided in the transaction is not valid',
        code: types_1.ChainCosmosErrorCode.ErrInvalidVersion,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'invalid chain-id': {
        message: 'The chainId provided in the transaction is not valid',
        code: types_1.ChainCosmosErrorCode.ErrInvalidChainID,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'invalid type': {
        message: 'The type provided in the transaction is not valid',
        code: types_1.ChainCosmosErrorCode.ErrInvalidType,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'unknown extension options': {
        message: 'The extension options provided in the transaction is unknown',
        code: types_1.ChainCosmosErrorCode.ErrUnknownExtensionOptions,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'incorrect account sequence': {
        message: 'The sequence number provided in the transaction is incorrect',
        code: types_1.ChainCosmosErrorCode.ErrWrongSequence,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'failed packing protobuf message to Any': {
        message: 'failed packing protobuf message to Any',
        code: types_1.ChainCosmosErrorCode.ErrPackAny,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'failed unpacking protobuf message from Any': {
        message: 'failed unpacking protobuf message from Any',
        code: types_1.ChainCosmosErrorCode.ErrUnpackAny,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'internal logic error': {
        message: 'Internal logic error',
        code: types_1.ChainCosmosErrorCode.ErrLogic,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    conflict: {
        message: 'conflict',
        code: types_1.ChainCosmosErrorCode.ErrConflict,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'feature not supported': {
        message: 'The feature is not supported',
        code: types_1.ChainCosmosErrorCode.ErrNotSupported,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'Internal IO error': {
        message: 'Internal IO error',
        code: types_1.ChainCosmosErrorCode.ErrIO,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'error in app.toml': {
        message: 'error in app.toml',
        code: types_1.ChainCosmosErrorCode.ErrAppConfig,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'invalid gas limit': {
        message: 'The gas limit provided in the transaction is not valid',
        code: types_1.ChainCosmosErrorCode.ErrInvalidGasLimit,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    // Auction Module Messages
    'invalid bid denom': {
        message: 'The gas limit provided in the transaction is not valid',
        code: types_1.ChainAuctionErrorCodes.ErrBidInvalid,
        module: types_1.TransactionChainErrorModule.Auction,
    },
    'invalid bid round': {
        message: 'The gas limit provided in the transaction is not valid',
        code: types_1.ChainAuctionErrorCodes.ErrBidRound,
        module: types_1.TransactionChainErrorModule.Auction,
    },
    // Insurance Module Messages
    'insurance fund already exists': {
        message: 'The insurance fund already exists',
        code: types_1.ChainInsuranceErrorCodes.ErrInsuranceFundAlreadyExists,
        module: types_1.TransactionChainErrorModule.Insurance,
    },
    'insurance fund not found': {
        message: 'The insurance fund is not found',
        code: types_1.ChainInsuranceErrorCodes.ErrInsuranceFundNotFound,
        module: types_1.TransactionChainErrorModule.Insurance,
    },
    'redemption already exists': {
        message: 'The redemption already exists',
        code: types_1.ChainInsuranceErrorCodes.ErrRedemptionAlreadyExists,
        module: types_1.TransactionChainErrorModule.Insurance,
    },
    'invalid deposit amount': {
        message: 'The deposit amount is not valid',
        code: types_1.ChainInsuranceErrorCodes.ErrInvalidDepositAmount,
        module: types_1.TransactionChainErrorModule.Insurance,
    },
    'invalid deposit denom': {
        message: 'The deposit denom is not valid',
        code: types_1.ChainInsuranceErrorCodes.ErrInvalidDepositDenom,
        module: types_1.TransactionChainErrorModule.Insurance,
    },
    'insurance payout exceeds deposits': {
        message: 'The insurance fund payout exceeds the deposits',
        code: types_1.ChainInsuranceErrorCodes.ErrPayoutTooLarge,
        module: types_1.TransactionChainErrorModule.Insurance,
    },
    'invalid ticker': {
        message: 'The ticker is not valid',
        code: types_1.ChainInsuranceErrorCodes.ErrInvalidTicker,
        module: types_1.TransactionChainErrorModule.Insurance,
    },
    'invalid quote denom': {
        message: 'The quote denom is not valid',
        code: types_1.ChainInsuranceErrorCodes.ErrInvalidQuoteDenom,
        module: types_1.TransactionChainErrorModule.Insurance,
    },
    'invalid oracle': {
        message: 'The oracle is not valid',
        code: types_1.ChainInsuranceErrorCodes.ErrInvalidOracle,
        module: types_1.TransactionChainErrorModule.Insurance,
    },
    'invalid expiration time': {
        message: 'The expiration time is not valid',
        code: types_1.ChainInsuranceErrorCodes.ErrInvalidExpirationTime,
        module: types_1.TransactionChainErrorModule.Insurance,
    },
    'invalid marketID': {
        message: 'The marketId is not valid',
        code: types_1.ChainInsuranceErrorCodes.ErrInvalidMarketID,
        module: types_1.TransactionChainErrorModule.Insurance,
    },
    'invalid share denom': {
        message: 'The share denom is not valid',
        code: types_1.ChainInsuranceErrorCodes.ErrInvalidShareDenom,
        module: types_1.TransactionChainErrorModule.Insurance,
    },
    // Exchange Module Messages
    'failed to validate order': {
        message: 'Your order failed to validate',
        code: types_1.ChainExchangeModuleErrorCode.ErrOrderInvalid,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'spot market not found': {
        message: 'The spot market has not been found',
        code: types_1.ChainExchangeModuleErrorCode.ErrSpotMarketNotFound,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'spot market exists': {
        message: 'The spot market already exists',
        code: types_1.ChainExchangeModuleErrorCode.ErrSpotMarketExists,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'struct field error': {
        message: 'There is an issue with your order',
        code: types_1.ChainExchangeModuleErrorCode.ErrBadField,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'failed to validate market': {
        message: 'The market failed to validate',
        code: types_1.ChainExchangeModuleErrorCode.ErrMarketInvalid,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'subaccount has insufficient deposits': {
        message: 'Your trading account has insufficient funds',
        code: types_1.ChainExchangeModuleErrorCode.ErrInsufficientDeposit,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'unrecognized order type': {
        message: 'The order type is not recognized',
        code: types_1.ChainExchangeModuleErrorCode.ErrUnrecognizedOrderType,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'position quantity insufficient for order': {
        message: 'The position quantity is insufficient for the order',
        code: types_1.ChainExchangeModuleErrorCode.ErrInsufficientPositionQuantity,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'order hash is not valid': {
        message: 'The order hash is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrOrderHashInvalid,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'subaccount id is not valid': {
        message: 'The subaccount id is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrBadSubaccountID,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'invalid base denom': {
        message: '',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidBaseDenom,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'invalid expiry': {
        message: 'The expiry date is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidExpiry,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'invalid price': {
        message: 'The price is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidPrice,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'invalid quantity': {
        message: 'The quantity is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidQuantity,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'unsupported oracle type': {
        message: 'The oracle type is not supported',
        code: types_1.ChainExchangeModuleErrorCode.ErrUnsupportedOracleType,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'order doesnt exist': {
        message: 'The order does not exist',
        code: types_1.ChainExchangeModuleErrorCode.ErrOrderDoesntExist,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'spot limit orderbook fill invalid': {
        message: '',
        code: types_1.ChainExchangeModuleErrorCode.ErrOrderbookFillInvalid,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'perpetual market exists': {
        message: 'The perpetual market already exists',
        code: types_1.ChainExchangeModuleErrorCode.ErrPerpetualMarketExists,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'expiry futures market exists': {
        message: 'The expiry futures market market already exists',
        code: types_1.ChainExchangeModuleErrorCode.ErrExpiryFuturesMarketExists,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'expiry futures market expired': {
        message: 'The expiry futures market has expired',
        code: types_1.ChainExchangeModuleErrorCode.ErrExpiryFuturesMarketExpired,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'no liquidity on the orderbook': {
        message: 'There is not enough liquidity',
        code: types_1.ChainExchangeModuleErrorCode.ErrNoLiquidity,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'orderbook liquidity cannot satisfy current worst price': {
        message: 'There is not enough liquidity',
        code: types_1.ChainExchangeModuleErrorCode.ErrSlippageExceedsWorstPrice,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'order has insufficient margin': {
        message: 'The order has insufficient margin',
        code: types_1.ChainExchangeModuleErrorCode.ErrInsufficientOrderMargin,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'derivative market not found': {
        message: 'The derivative market cannot be found',
        code: types_1.ChainExchangeModuleErrorCode.ErrDerivativeMarketNotFound,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'position not found': {
        message: 'The position cannot be found',
        code: types_1.ChainExchangeModuleErrorCode.ErrPositionNotFound,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'position direction does not oppose the reduce-only order': {
        message: 'Position direction does not oppose the reduce-only order',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidReduceOnlyPositionDirection,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'price surpasses bankruptcy price': {
        message: 'Your order price surpasses bankruptcy price',
        code: types_1.ChainExchangeModuleErrorCode.ErrPriceSurpassesBankruptcyPrice,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'position not liquidable': {
        message: 'The position is not liquidable',
        code: types_1.ChainExchangeModuleErrorCode.ErrPositionNotLiquidable,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'invalid trigger price': {
        message: 'Your order trigger price is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidTriggerPrice,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'invalid oracle type': {
        message: 'The oracle type is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidOracleType,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'invalid minimum price tick size': {
        message: 'The minimum price tick size is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidPriceTickSize,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'invalid minimum quantity tick size': {
        message: 'The minimum quantity tick size is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidQuantityTickSize,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'invalid minimum order margin': {
        message: "Your order's minimum margin is not valid ",
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidMargin,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'exceeds order side count': {
        message: 'You cannot have more orders for this market for this direction',
        code: types_1.ChainExchangeModuleErrorCode.ErrExceedsOrderSideCount,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'subaccount cannot place a market order when a market order in the same market was already placed in same block': {
        message: 'You cannot place another market order within this block',
        code: types_1.ChainExchangeModuleErrorCode.ErrMarketOrderAlreadyExists,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'cannot place a conditional market order when a conditional market order in same relative direction already exists': {
        message: 'You cannot place another conditional market order',
        code: types_1.ChainExchangeModuleErrorCode.ErrConditionalMarketOrderAlreadyExists,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'an equivalent market launch proposal already exists.': {
        message: 'There is an existing equivalent market launch proposal.',
        code: types_1.ChainExchangeModuleErrorCode.ErrMarketLaunchProposalAlreadyExists,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'invalid market status': {
        message: 'The market status is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidMarketStatus,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'base denom cannot be same with quote denom': {
        message: 'The base denom and quote denom cannot be same',
        code: types_1.ChainExchangeModuleErrorCode.ErrSameDenoms,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'oracle base cannot be same with oracle quote': {
        message: 'The oracle base and the oracle quote cannot be the same',
        code: types_1.ChainExchangeModuleErrorCode.ErrSameOracles,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'makerfeerate does not match takerfeeeate requirements': {
        message: 'The MakerFeeRate does not match TakerFeeRate requirements',
        code: types_1.ChainExchangeModuleErrorCode.ErrFeeRatesRelation,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'maintenancemarginratio cannot be greater than initialmarginratio': {
        message: 'The MaintenanceMarginRatio cannot be greater than InitialMarginRatio',
        code: types_1.ChainExchangeModuleErrorCode.ErrMarginsRelation,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'oraclescalefactor cannot be greater than maxoraclescalefactor': {
        message: 'The OracleScaleFactor cannot be greater than MaxOracleScaleFactor',
        code: types_1.ChainExchangeModuleErrorCode.ErrExceedsMaxOracleScaleFactor,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'spot exchange is not enabled yet': {
        message: 'Spot exchange is not enabled yet',
        code: types_1.ChainExchangeModuleErrorCode.ErrSpotExchangeNotEnabled,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'derivatives exchange is not enabled yet': {
        message: 'Derivatives exchange is not enabled yet',
        code: types_1.ChainExchangeModuleErrorCode.ErrDerivativesExchangeNotEnabled,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'oracle price delta exceeds threshold': {
        message: 'The oracle price delta exceeds threshold',
        code: types_1.ChainExchangeModuleErrorCode.ErrOraclePriceDeltaExceedsThreshold,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'invalid hourly interest rate': {
        message: 'The hourly interest rate is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidHourlyInterestRate,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'invalid hourly funding rate cap': {
        message: 'The hourly funding rate cap is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidHourlyFundingRateCap,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'only perpetual markets can update funding parameters': {
        message: 'You can only update funding parameters on perpetual markets.',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidMarketFundingParamUpdate,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'invalid trading reward campaign': {
        message: 'The trading reward campaign is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidTradingRewardCampaign,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'invalid fee discount schedule': {
        message: 'The fee discount schedule is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidFeeDiscountSchedule,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'invalid liquidation order': {
        message: 'The liquidation order is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidLiquidationOrder,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'unknown error happened for campaign distributions': {
        message: 'Unknown error happened for campaign distributions',
        code: types_1.ChainExchangeModuleErrorCode.ErrTradingRewardCampaignDistributionError,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'invalid trading reward points update': {
        message: 'The updated trading reward points is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidTradingRewardsPendingPointsUpdate,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'invalid batch msg update': {
        message: 'The MsgBatchUpdate is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidBatchMsgUpdate,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'post-only order exceeds top of book price': {
        message: 'The post-only order price exceeds top of the orderbook price',
        code: types_1.ChainExchangeModuleErrorCode.ErrExceedsTopOfBookPrice,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'order type not supported for given message': {
        message: 'The order type is not supported for this message',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidOrderTypeForMessage,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'sender must match dmm account': {
        message: 'The sender must match the DMM address',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidDMMSender,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'already opted out of rewards': {
        message: 'The DMM address already opted out of rewards',
        code: types_1.ChainExchangeModuleErrorCode.ErrAlreadyOptedOutOfRewards,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'invalid margin ratio': {
        message: 'The margin ratio is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidMarginRatio,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'provided funds are below minimum': {
        message: 'The provided funds are below minimum',
        code: types_1.ChainExchangeModuleErrorCode.ErrBelowMinimalContribution,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'position is below initial margin requirement': {
        message: 'The position is below initial margin requirement',
        code: types_1.ChainExchangeModuleErrorCode.ErrLowPositionMargin,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'pool has non-positive total lp token supply': {
        message: 'The pool has non-positive total LP token supply',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidTotalSupply,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'passed lp token burn amount is greater than total lp token supply': {
        message: 'The passed LP token burn amount is greater than total LP token supply',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidLpTokenBurnAmount,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'unsupported action': {
        message: 'This action is not supported',
        code: types_1.ChainExchangeModuleErrorCode.ErrUnsupportedAction,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'position quantity cannot be negative': {
        message: 'The position quantity cannot be negative',
        code: types_1.ChainExchangeModuleErrorCode.ErrNegativePositionQuantity,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'binary options market exists': {
        message: 'The BinaryOptions market already exists',
        code: types_1.ChainExchangeModuleErrorCode.ErrBinaryOptionsMarketExists,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'binary options market not found': {
        message: 'The BinaryOptions market cannot be found',
        code: types_1.ChainExchangeModuleErrorCode.ErrBinaryOptionsMarketNotFound,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'invalid settlement': {
        message: 'The settlement price is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidSettlement,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'account doesnt exist': {
        message: 'The trading account does not exist',
        code: types_1.ChainExchangeModuleErrorCode.ErrAccountDoesntExist,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'sender should be a market admin': {
        message: 'The sender should be the admin of the market',
        code: types_1.ChainExchangeModuleErrorCode.ErrSenderIsNotAnAdmin,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'market is already scheduled to settle': {
        message: 'The market is already scheduled to settle ',
        code: types_1.ChainExchangeModuleErrorCode.ErrMarketAlreadyScheduledToSettle,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'market not found': {
        message: 'The market cannot be found',
        code: types_1.ChainExchangeModuleErrorCode.ErrGenericMarketNotFound,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'denom decimal cannot be below 1 or above max scale factor': {
        message: 'The denom decimal cannot be below 1 or above max scale factor',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidDenomDecimal,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'state is invalid': {
        message: 'The state is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidState,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'transient orders up to cancellation not supported': {
        message: 'The transient orders up to cancellation not supported',
        code: types_1.ChainExchangeModuleErrorCode.ErrTransientOrdersUpToCancelNotSupported,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'invalid trade': {
        message: 'The trade is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidTrade,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'no margin locked in subaccount': {
        message: 'There is no margin locked in the trading account',
        code: types_1.ChainExchangeModuleErrorCode.ErrNoMarginLocked,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'Invalid access level to perform action': {
        message: 'There is no access to perform action',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidAccessLevel,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'Invalid address': {
        message: 'The address is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidAddress,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'Invalid argument': {
        message: 'The argument is not valid',
        code: types_1.ChainExchangeModuleErrorCode.ErrInvalidArgument,
        module: types_1.TransactionChainErrorModule.Exchange,
    },
    'empty validator address': {
        message: 'empty validator address',
        code: types_1.ChainStakingErrorCodes.ErrEmptyValidatorAddr,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'validator does not exist': {
        message: 'validator does not exist',
        code: types_1.ChainStakingErrorCodes.ErrNoValidatorFound,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'validator already exist for this operator address; must use new validator operator address': {
        message: 'validator already exist for this operator address; must use new validator operator address',
        code: types_1.ChainStakingErrorCodes.ErrValidatorOwnerExists,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'validator already exist for this pubkey; must use new validator pubkey': {
        message: 'validator already exist for this pubkey; must use new validator pubkey',
        code: types_1.ChainStakingErrorCodes.ErrValidatorPubKeyExists,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'validator pubkey type is not supported': {
        message: 'validator pubkey type is not supported',
        code: types_1.ChainStakingErrorCodes.ErrValidatorPubKeyTypeNotSupported,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'validator for this address is currently jailed': {
        message: 'validator for this address is currently jailed',
        code: types_1.ChainStakingErrorCodes.ErrValidatorJailed,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'failed to remove validator': {
        message: 'failed to remove validator',
        code: types_1.ChainStakingErrorCodes.ErrBadRemoveValidator,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'commission must be positive': {
        message: 'commission must be positive',
        code: types_1.ChainStakingErrorCodes.ErrCommissionNegative,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'commission cannot be more than 100%': {
        message: 'commission cannot be more than 100%',
        code: types_1.ChainStakingErrorCodes.ErrCommissionHuge,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'commission cannot be more than the max rate': {
        message: 'commission cannot be more than the max rate',
        code: types_1.ChainStakingErrorCodes.ErrCommissionGTMaxRate,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'commission cannot be changed more than once in 24h': {
        message: 'commission cannot be changed more than once in 24h',
        code: types_1.ChainStakingErrorCodes.ErrCommissionUpdateTime,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'commission change rate must be positive': {
        message: 'commission change rate must be positive',
        code: types_1.ChainStakingErrorCodes.ErrCommissionChangeRateNegative,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'commission change rate cannot be more than the max rate': {
        message: 'commission change rate cannot be more than the max rate',
        code: types_1.ChainStakingErrorCodes.ErrCommissionChangeRateGTMaxRate,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'commission cannot be changed more than max change rate': {
        message: 'commission cannot be changed more than max change rate',
        code: types_1.ChainStakingErrorCodes.ErrCommissionGTMaxChangeRate,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    "validator's self delegation must be greater than their minimum self delegation": {
        message: "validator's self delegation must be greater than their minimum self delegation",
        code: types_1.ChainStakingErrorCodes.ErrSelfDelegationBelowMinimum,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'minimum self delegation cannot be decrease': {
        message: 'minimum self delegation cannot be decrease',
        code: types_1.ChainStakingErrorCodes.ErrMinSelfDelegationDecreased,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'empty delegator address': {
        message: 'empty delegator address',
        code: types_1.ChainStakingErrorCodes.ErrEmptyDelegatorAddr,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'no delegation for (address, validator) tuple': {
        message: 'no delegation for (address, validator) tuple',
        code: types_1.ChainStakingErrorCodes.ErrNoDelegation,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'delegator does not exist with address': {
        message: 'delegator does not exist with address',
        code: types_1.ChainStakingErrorCodes.ErrBadDelegatorAddr,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'delegator does not contain delegation': {
        message: 'delegator does not contain delegation',
        code: types_1.ChainStakingErrorCodes.ErrNoDelegatorForAddress,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'insufficient delegation shares': {
        message: 'insufficient delegation shares',
        code: types_1.ChainStakingErrorCodes.ErrInsufficientShares,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'cannot delegate to an empty validator': {
        message: 'cannot delegate to an empty validator',
        code: types_1.ChainStakingErrorCodes.ErrDelegationValidatorEmpty,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'not enough delegation shares': {
        message: 'not enough delegation shares',
        code: types_1.ChainStakingErrorCodes.ErrNotEnoughDelegationShares,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'entry not mature': {
        message: 'entry not mature',
        code: types_1.ChainStakingErrorCodes.ErrNotMature,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'no unbonding delegation found': {
        message: 'no unbonding delegation found',
        code: types_1.ChainStakingErrorCodes.ErrNoUnbondingDelegation,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'too many unbonding delegation entries for (delegator, validator) tuple': {
        message: 'too many unbonding delegation entries for (delegator, validator) tuple',
        code: types_1.ChainStakingErrorCodes.ErrMaxUnbondingDelegationEntries,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'no redelegation found': {
        message: 'no redelegation found',
        code: types_1.ChainStakingErrorCodes.ErrNoRedelegation,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'cannot redelegate to the same validator': {
        message: 'cannot redelegate to the same validator',
        code: types_1.ChainStakingErrorCodes.ErrSelfRedelegation,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'too few tokens to redelegate (truncates to zero tokens)': {
        message: 'too few tokens to redelegate (truncates to zero tokens)',
        code: types_1.ChainStakingErrorCodes.ErrTinyRedelegationAmount,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'redelegation destination validator not found': {
        message: 'redelegation destination validator not found',
        code: types_1.ChainStakingErrorCodes.ErrBadRedelegationDst,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'redelegation to this validator already in progress; first redelegation to this validator must complete before next redelegation': {
        message: 'redelegation to this validator already in progress; first redelegation to this validator must complete before next redelegation',
        code: types_1.ChainStakingErrorCodes.ErrTransitiveRedelegation,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'too many redelegation entries for (delegator, src-validator, dst-validator) tuple': {
        message: 'too many redelegation entries for (delegator, src-validator, dst-validator) tuple',
        code: types_1.ChainStakingErrorCodes.ErrMaxRedelegationEntries,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'cannot delegate to validators with invalid (zero) ex-rate': {
        message: 'cannot delegate to validators with invalid (zero) ex-rate',
        code: types_1.ChainStakingErrorCodes.ErrDelegatorShareExRateInvalid,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'both shares amount and shares percent provided': {
        message: 'both shares amount and shares percent provided',
        code: types_1.ChainStakingErrorCodes.ErrBothShareMsgsGiven,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'neither shares amount nor shares percent provided': {
        message: 'neither shares amount nor shares percent provided',
        code: types_1.ChainStakingErrorCodes.ErrNeitherShareMsgsGiven,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'invalid historical info': {
        message: 'invalid historical info',
        code: types_1.ChainStakingErrorCodes.ErrInvalidHistoricalInfo,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'no historical info found': {
        message: 'no historical info found',
        code: types_1.ChainStakingErrorCodes.ErrNoHistoricalInfo,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'empty validator public key': {
        message: 'empty validator public key',
        code: types_1.ChainStakingErrorCodes.ErrEmptyValidatorPubKey,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'commission cannot be less than min rate': {
        message: 'commission cannot be less than min rate',
        code: types_1.ChainStakingErrorCodes.ErrCommissionLTMinRate,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'unbonding operation not found': {
        message: 'unbonding operation not found',
        code: types_1.ChainStakingErrorCodes.ErrUnbondingNotFound,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'cannot un-hold unbonding operation that is not on hold': {
        message: 'cannot un-hold unbonding operation that is not on hold',
        code: types_1.ChainStakingErrorCodes.ErrUnbondingOnHoldRefCountNegative,
        module: types_1.TransactionChainErrorModule.Staking,
    },
    'delegator address is empty': {
        message: 'delegator address is empty',
        code: types_1.ChainDistributionErrorCodes.ErrEmptyDelegatorAddr,
        module: types_1.TransactionChainErrorModule.Distribution,
    },
    'withdraw address is empty': {
        message: 'withdraw address is empty',
        code: types_1.ChainDistributionErrorCodes.ErrEmptyWithdrawAddr,
        module: types_1.TransactionChainErrorModule.Distribution,
    },
    'validator address is empty': {
        message: 'validator address is empty',
        code: types_1.ChainDistributionErrorCodes.ErrEmptyValidatorAddr,
        module: types_1.TransactionChainErrorModule.Distribution,
    },
    'no delegation distribution info': {
        message: 'no delegation distribution info',
        code: types_1.ChainDistributionErrorCodes.ErrEmptyDelegationDistInfo,
        module: types_1.TransactionChainErrorModule.Distribution,
    },
    'no validator distribution info': {
        message: 'no validator distribution info',
        code: types_1.ChainDistributionErrorCodes.ErrNoValidatorDistInfo,
        module: types_1.TransactionChainErrorModule.Distribution,
    },
    'no validator commission to withdraw': {
        message: 'no validator commission to withdraw',
        code: types_1.ChainDistributionErrorCodes.ErrNoValidatorCommission,
        module: types_1.TransactionChainErrorModule.Distribution,
    },
    'set withdraw address disabled': {
        message: 'set withdraw address disabled',
        code: types_1.ChainDistributionErrorCodes.ErrSetWithdrawAddrDisabled,
        module: types_1.TransactionChainErrorModule.Distribution,
    },
    'community pool does not have sufficient coins to distribute': {
        message: 'community pool does not have sufficient coins distribute',
        code: types_1.ChainDistributionErrorCodes.ErrBadDistribution,
        module: types_1.TransactionChainErrorModule.Distribution,
    },
    'invalid community pool spend proposal amount': {
        message: 'invalid community pool spend proposal amount',
        code: types_1.ChainDistributionErrorCodes.ErrInvalidProposalAmount,
        module: types_1.TransactionChainErrorModule.Distribution,
    },
    'invalid community pool spend proposal recipient': {
        message: 'invalid community pool spend proposal recipient',
        code: types_1.ChainDistributionErrorCodes.ErrEmptyProposalRecipient,
        module: types_1.TransactionChainErrorModule.Distribution,
    },
    'delegation does not exist': {
        message: 'delegation does not exist',
        code: types_1.ChainDistributionErrorCodes.ErrNoDelegationExists,
        module: types_1.TransactionChainErrorModule.Distribution,
    },
    'unknown proposal': {
        message: 'unknown proposal',
        code: types_1.ChainGovErrorCodes.ErrUnknownProposal,
        module: types_1.TransactionChainErrorModule.Gov,
    },
    'inactive proposal': {
        message: 'inactive proposal',
        code: types_1.ChainGovErrorCodes.ErrInactiveProposal,
        module: types_1.TransactionChainErrorModule.Gov,
    },
    'proposal already active': {
        message: 'proposal already active',
        code: types_1.ChainGovErrorCodes.ErrAlreadyActiveProposal,
        module: types_1.TransactionChainErrorModule.Gov,
    },
    'invalid proposal content': {
        message: 'invalid proposal content',
        code: types_1.ChainGovErrorCodes.ErrInvalidProposalContent,
        module: types_1.TransactionChainErrorModule.Gov,
    },
    'invalid proposal type': {
        message: 'invalid proposal type',
        code: types_1.ChainGovErrorCodes.ErrInvalidProposalType,
        module: types_1.TransactionChainErrorModule.Gov,
    },
    'invalid vote option': {
        message: 'invalid vote option',
        code: types_1.ChainGovErrorCodes.ErrInvalidVote,
        module: types_1.TransactionChainErrorModule.Gov,
    },
    'invalid genesis state': {
        message: 'invalid genesis state',
        code: types_1.ChainGovErrorCodes.ErrInvalidGenesis,
        module: types_1.TransactionChainErrorModule.Gov,
    },
    'no handler exists for proposal type': {
        message: 'no handler exists for proposal type',
        code: types_1.ChainGovErrorCodes.ErrNoProposalHandlerExists,
        module: types_1.TransactionChainErrorModule.Gov,
    },
    'proposal message not recognized by router': {
        message: 'proposal message not recognized by router',
        code: types_1.ChainGovErrorCodes.ErrUnroutableProposalMsg,
        module: types_1.TransactionChainErrorModule.Gov,
    },
    'no messages proposed': {
        message: 'no messages proposed',
        code: types_1.ChainGovErrorCodes.ErrNoProposalMsgs,
        module: types_1.TransactionChainErrorModule.Gov,
    },
    'invalid proposal message': {
        message: 'invalid proposal message',
        code: types_1.ChainGovErrorCodes.ErrInvalidProposalMsg,
        module: types_1.TransactionChainErrorModule.Gov,
    },
    'expected gov account as only signer for proposal message': {
        message: 'expected gov account as only signer for proposal message',
        code: types_1.ChainGovErrorCodes.ErrInvalidSigner,
        module: types_1.TransactionChainErrorModule.Gov,
    },
    'signal message is invalid': {
        message: 'signal message is invalid',
        code: types_1.ChainGovErrorCodes.ErrInvalidSignalMsg,
        module: types_1.TransactionChainErrorModule.Gov,
    },
    'metadata too long': {
        message: 'metadata too long',
        code: types_1.ChainGovErrorCodes.ErrMetadataTooLong,
        module: types_1.TransactionChainErrorModule.Gov,
    },
    'minimum deposit is too small': {
        message: 'minimum deposit is too small',
        code: types_1.ChainGovErrorCodes.ErrMinDepositTooSmall,
        module: types_1.TransactionChainErrorModule.Gov,
    },
    'proposal is not found': {
        message: 'proposal is not found',
        code: types_1.ChainGovErrorCodes.ErrProposalNotFound,
        module: types_1.TransactionChainErrorModule.Gov,
    },
    'invalid proposer': {
        message: 'invalid proposer',
        code: types_1.ChainGovErrorCodes.ErrInvalidProposer,
        module: types_1.TransactionChainErrorModule.Gov,
    },
    'no deposits found': {
        message: 'no deposits found',
        code: types_1.ChainGovErrorCodes.ErrNoDeposits,
        module: types_1.TransactionChainErrorModule.Gov,
    },
    'voting period already ended': {
        message: 'voting period already ended',
        code: types_1.ChainGovErrorCodes.ErrVotingPeriodEnded,
        module: types_1.TransactionChainErrorModule.Gov,
    },
    'invalid proposal': {
        message: 'invalid proposal',
        code: types_1.ChainGovErrorCodes.ErrInvalidProposal,
        module: types_1.TransactionChainErrorModule.Gov,
    },
    'no inputs to send transaction': {
        message: 'no inputs to send transaction',
        code: types_1.ChainBankErrorCodes.ErrNoInputs,
        module: types_1.TransactionChainErrorModule.Bank,
    },
    'no outputs to send transaction': {
        message: 'no outputs to send transaction',
        code: types_1.ChainBankErrorCodes.ErrNoOutputs,
        module: types_1.TransactionChainErrorModule.Bank,
    },
    'sum inputs != sum outputs': {
        message: 'sum inputs != sum outputs',
        code: types_1.ChainBankErrorCodes.ErrInputOutputMismatch,
        module: types_1.TransactionChainErrorModule.Bank,
    },
    'send transactions are disabled': {
        message: 'send transactions are disabled',
        code: types_1.ChainBankErrorCodes.ErrSendDisabled,
        module: types_1.TransactionChainErrorModule.Bank,
    },
    'client denom metadata not found': {
        message: 'client denom metadata not found',
        code: types_1.ChainBankErrorCodes.ErrDenomMetadataNotFound,
        module: types_1.TransactionChainErrorModule.Bank,
    },
    'invalid key': {
        message: 'invalid key',
        code: types_1.ChainBankErrorCodes.ErrInvalidKey,
        module: types_1.TransactionChainErrorModule.Bank,
    },
    'duplicate entry': {
        message: 'duplicate entry',
        code: types_1.ChainBankErrorCodes.ErrDuplicateEntry,
        module: types_1.TransactionChainErrorModule.Bank,
    },
    'multiple senders not allowed': {
        message: 'multiple senders not allowed',
        code: types_1.ChainBankErrorCodes.ErrMultipleSenders,
        module: types_1.TransactionChainErrorModule.Bank,
    },
    'create wasm contract failed': {
        code: types_1.ChainWasmErrorCodes.ErrCreateFailed,
        message: 'create wasm contract failed',
        module: types_1.TransactionChainErrorModule.Wasm,
    },
    'contract account already exists': {
        code: types_1.ChainWasmErrorCodes.ErrAccountExists,
        message: 'contract account already exists',
        module: types_1.TransactionChainErrorModule.Wasm,
    },
    'instantiate wasm contract failed': {
        code: types_1.ChainWasmErrorCodes.ErrInstantiateFailed,
        message: 'instantiate wasm contract failed',
        module: types_1.TransactionChainErrorModule.Wasm,
    },
    'execute wasm contract failed': {
        code: types_1.ChainWasmErrorCodes.ErrExecuteFailed,
        message: 'Contract execution failed',
        module: types_1.TransactionChainErrorModule.Wasm,
    },
    'insufficient gas': {
        code: types_1.ChainWasmErrorCodes.ErrGasLimit,
        message: 'insufficient gas',
        module: types_1.TransactionChainErrorModule.Wasm,
    },
    'invalid genesis': {
        code: types_1.ChainWasmErrorCodes.ErrInvalidGenesis,
        message: 'invalid genesis',
        module: types_1.TransactionChainErrorModule.Wasm,
    },
    'query wasm contract failed': {
        code: types_1.ChainWasmErrorCodes.ErrQueryFailed,
        message: 'query wasm contract failed',
        module: types_1.TransactionChainErrorModule.Wasm,
    },
    'invalid CosmosMsg from the contract': {
        code: types_1.ChainWasmErrorCodes.ErrInvalidMsg,
        message: 'invalid CosmosMsg from the contract',
        module: types_1.TransactionChainErrorModule.Wasm,
    },
    'migrate wasm contract failed': {
        code: types_1.ChainWasmErrorCodes.ErrMigrationFailed,
        message: 'migrate wasm contract failed',
        module: types_1.TransactionChainErrorModule.Wasm,
    },
    empty: {
        code: types_1.ChainWasmErrorCodes.ErrEmpty,
        message: 'empty',
        module: types_1.TransactionChainErrorModule.Wasm,
    },
    'exceeds limit': {
        code: types_1.ChainWasmErrorCodes.ErrLimit,
        message: 'exceeds limit',
        module: types_1.TransactionChainErrorModule.Wasm,
    },
    invalid: {
        code: types_1.ChainWasmErrorCodes.ErrInvalid,
        message: 'invalid',
        module: types_1.TransactionChainErrorModule.Wasm,
    },
    duplicate: {
        code: types_1.ChainWasmErrorCodes.ErrDuplicate,
        message: 'duplicate',
        module: types_1.TransactionChainErrorModule.Wasm,
    },
    'max transfer channels': {
        code: types_1.ChainWasmErrorCodes.ErrMaxIBCChannels,
        message: 'max transfer channels',
        module: types_1.TransactionChainErrorModule.Wasm,
    },
    'unsupported for this contract': {
        code: types_1.ChainWasmErrorCodes.ErrUnsupportedForContract,
        message: 'unsupported for this contract',
        module: types_1.TransactionChainErrorModule.Wasm,
    },
    'pinning contract failed': {
        code: types_1.ChainWasmErrorCodes.ErrPinContractFailed,
        message: 'pinning contract failed',
        module: types_1.TransactionChainErrorModule.Wasm,
    },
    'unpinning contract failed': {
        code: types_1.ChainWasmErrorCodes.ErrUnpinContractFailed,
        message: 'unpinning contract failed',
        module: types_1.TransactionChainErrorModule.Wasm,
    },
    'unknown message from the contract': {
        code: types_1.ChainWasmErrorCodes.ErrUnknownMsg,
        message: 'unknown message from the contract',
        module: types_1.TransactionChainErrorModule.Wasm,
    },
    'invalid event': {
        code: types_1.ChainWasmErrorCodes.ErrInvalidEvent,
        message: 'invalid event',
        module: types_1.TransactionChainErrorModule.Wasm,
    },
    'authorization not found': {
        code: types_1.ChainAuthZErrorCodes.ErrNoAuthorizationFound,
        message: 'Authorization not found',
        module: types_1.TransactionChainErrorModule.Wasm,
    },
    'expiration time of authorization': {
        code: types_1.ChainAuthZErrorCodes.ErrAuthorizationExpired,
        message: 'Authorization expired',
        module: types_1.TransactionChainErrorModule.Wasm,
    },
    'not found': {
        message: 'not found',
        code: types_1.ChainCosmosErrorCode.ErrNotFound,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
    'failed to fetch account num/seq': {
        message: 'Account does not exist on chain. Create it by send funds.',
        code: types_1.ChainCosmosErrorCode.ErrKeyNotFound,
        module: types_1.TransactionChainErrorModule.CosmosSdk,
    },
};
//# sourceMappingURL=messages.js.map