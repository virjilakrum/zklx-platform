/* eslint-disable */
import { grpc } from "@injectivelabs/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { Any } from "../../../google/protobuf/any";
import { Params } from "./params";
import { BridgeValidator } from "./types";
function createBaseMsgSetOrchestratorAddresses() {
    return { sender: "", orchestrator: "", ethAddress: "" };
}
export const MsgSetOrchestratorAddresses = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sender !== "") {
            writer.uint32(10).string(message.sender);
        }
        if (message.orchestrator !== "") {
            writer.uint32(18).string(message.orchestrator);
        }
        if (message.ethAddress !== "") {
            writer.uint32(26).string(message.ethAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSetOrchestratorAddresses();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.sender = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.orchestrator = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.ethAddress = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
            orchestrator: isSet(object.orchestrator) ? globalThis.String(object.orchestrator) : "",
            ethAddress: isSet(object.ethAddress) ? globalThis.String(object.ethAddress) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.sender !== "") {
            obj.sender = message.sender;
        }
        if (message.orchestrator !== "") {
            obj.orchestrator = message.orchestrator;
        }
        if (message.ethAddress !== "") {
            obj.ethAddress = message.ethAddress;
        }
        return obj;
    },
    create(base) {
        return MsgSetOrchestratorAddresses.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgSetOrchestratorAddresses();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.orchestrator = (_b = object.orchestrator) !== null && _b !== void 0 ? _b : "";
        message.ethAddress = (_c = object.ethAddress) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseMsgSetOrchestratorAddressesResponse() {
    return {};
}
export const MsgSetOrchestratorAddressesResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSetOrchestratorAddressesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgSetOrchestratorAddressesResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgSetOrchestratorAddressesResponse();
        return message;
    },
};
function createBaseMsgValsetConfirm() {
    return { nonce: "0", orchestrator: "", ethAddress: "", signature: "" };
}
export const MsgValsetConfirm = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.nonce !== "0") {
            writer.uint32(8).uint64(message.nonce);
        }
        if (message.orchestrator !== "") {
            writer.uint32(18).string(message.orchestrator);
        }
        if (message.ethAddress !== "") {
            writer.uint32(26).string(message.ethAddress);
        }
        if (message.signature !== "") {
            writer.uint32(34).string(message.signature);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgValsetConfirm();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.nonce = longToString(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.orchestrator = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.ethAddress = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.signature = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "0",
            orchestrator: isSet(object.orchestrator) ? globalThis.String(object.orchestrator) : "",
            ethAddress: isSet(object.ethAddress) ? globalThis.String(object.ethAddress) : "",
            signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nonce !== "0") {
            obj.nonce = message.nonce;
        }
        if (message.orchestrator !== "") {
            obj.orchestrator = message.orchestrator;
        }
        if (message.ethAddress !== "") {
            obj.ethAddress = message.ethAddress;
        }
        if (message.signature !== "") {
            obj.signature = message.signature;
        }
        return obj;
    },
    create(base) {
        return MsgValsetConfirm.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseMsgValsetConfirm();
        message.nonce = (_a = object.nonce) !== null && _a !== void 0 ? _a : "0";
        message.orchestrator = (_b = object.orchestrator) !== null && _b !== void 0 ? _b : "";
        message.ethAddress = (_c = object.ethAddress) !== null && _c !== void 0 ? _c : "";
        message.signature = (_d = object.signature) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
function createBaseMsgValsetConfirmResponse() {
    return {};
}
export const MsgValsetConfirmResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgValsetConfirmResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgValsetConfirmResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgValsetConfirmResponse();
        return message;
    },
};
function createBaseMsgSendToEth() {
    return { sender: "", ethDest: "", amount: undefined, bridgeFee: undefined };
}
export const MsgSendToEth = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sender !== "") {
            writer.uint32(10).string(message.sender);
        }
        if (message.ethDest !== "") {
            writer.uint32(18).string(message.ethDest);
        }
        if (message.amount !== undefined) {
            Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        if (message.bridgeFee !== undefined) {
            Coin.encode(message.bridgeFee, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSendToEth();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.sender = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.ethDest = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.amount = Coin.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.bridgeFee = Coin.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
            ethDest: isSet(object.ethDest) ? globalThis.String(object.ethDest) : "",
            amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
            bridgeFee: isSet(object.bridgeFee) ? Coin.fromJSON(object.bridgeFee) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.sender !== "") {
            obj.sender = message.sender;
        }
        if (message.ethDest !== "") {
            obj.ethDest = message.ethDest;
        }
        if (message.amount !== undefined) {
            obj.amount = Coin.toJSON(message.amount);
        }
        if (message.bridgeFee !== undefined) {
            obj.bridgeFee = Coin.toJSON(message.bridgeFee);
        }
        return obj;
    },
    create(base) {
        return MsgSendToEth.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgSendToEth();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : "";
        message.ethDest = (_b = object.ethDest) !== null && _b !== void 0 ? _b : "";
        message.amount = (object.amount !== undefined && object.amount !== null)
            ? Coin.fromPartial(object.amount)
            : undefined;
        message.bridgeFee = (object.bridgeFee !== undefined && object.bridgeFee !== null)
            ? Coin.fromPartial(object.bridgeFee)
            : undefined;
        return message;
    },
};
function createBaseMsgSendToEthResponse() {
    return {};
}
export const MsgSendToEthResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSendToEthResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgSendToEthResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgSendToEthResponse();
        return message;
    },
};
function createBaseMsgRequestBatch() {
    return { orchestrator: "", denom: "" };
}
export const MsgRequestBatch = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.orchestrator !== "") {
            writer.uint32(10).string(message.orchestrator);
        }
        if (message.denom !== "") {
            writer.uint32(18).string(message.denom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRequestBatch();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.orchestrator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.denom = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            orchestrator: isSet(object.orchestrator) ? globalThis.String(object.orchestrator) : "",
            denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.orchestrator !== "") {
            obj.orchestrator = message.orchestrator;
        }
        if (message.denom !== "") {
            obj.denom = message.denom;
        }
        return obj;
    },
    create(base) {
        return MsgRequestBatch.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgRequestBatch();
        message.orchestrator = (_a = object.orchestrator) !== null && _a !== void 0 ? _a : "";
        message.denom = (_b = object.denom) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseMsgRequestBatchResponse() {
    return {};
}
export const MsgRequestBatchResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRequestBatchResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgRequestBatchResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgRequestBatchResponse();
        return message;
    },
};
function createBaseMsgConfirmBatch() {
    return { nonce: "0", tokenContract: "", ethSigner: "", orchestrator: "", signature: "" };
}
export const MsgConfirmBatch = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.nonce !== "0") {
            writer.uint32(8).uint64(message.nonce);
        }
        if (message.tokenContract !== "") {
            writer.uint32(18).string(message.tokenContract);
        }
        if (message.ethSigner !== "") {
            writer.uint32(26).string(message.ethSigner);
        }
        if (message.orchestrator !== "") {
            writer.uint32(34).string(message.orchestrator);
        }
        if (message.signature !== "") {
            writer.uint32(42).string(message.signature);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmBatch();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.nonce = longToString(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.tokenContract = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.ethSigner = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.orchestrator = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.signature = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "0",
            tokenContract: isSet(object.tokenContract) ? globalThis.String(object.tokenContract) : "",
            ethSigner: isSet(object.ethSigner) ? globalThis.String(object.ethSigner) : "",
            orchestrator: isSet(object.orchestrator) ? globalThis.String(object.orchestrator) : "",
            signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nonce !== "0") {
            obj.nonce = message.nonce;
        }
        if (message.tokenContract !== "") {
            obj.tokenContract = message.tokenContract;
        }
        if (message.ethSigner !== "") {
            obj.ethSigner = message.ethSigner;
        }
        if (message.orchestrator !== "") {
            obj.orchestrator = message.orchestrator;
        }
        if (message.signature !== "") {
            obj.signature = message.signature;
        }
        return obj;
    },
    create(base) {
        return MsgConfirmBatch.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseMsgConfirmBatch();
        message.nonce = (_a = object.nonce) !== null && _a !== void 0 ? _a : "0";
        message.tokenContract = (_b = object.tokenContract) !== null && _b !== void 0 ? _b : "";
        message.ethSigner = (_c = object.ethSigner) !== null && _c !== void 0 ? _c : "";
        message.orchestrator = (_d = object.orchestrator) !== null && _d !== void 0 ? _d : "";
        message.signature = (_e = object.signature) !== null && _e !== void 0 ? _e : "";
        return message;
    },
};
function createBaseMsgConfirmBatchResponse() {
    return {};
}
export const MsgConfirmBatchResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmBatchResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgConfirmBatchResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgConfirmBatchResponse();
        return message;
    },
};
function createBaseMsgDepositClaim() {
    return {
        eventNonce: "0",
        blockHeight: "0",
        tokenContract: "",
        amount: "",
        ethereumSender: "",
        cosmosReceiver: "",
        orchestrator: "",
        data: "",
    };
}
export const MsgDepositClaim = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.eventNonce !== "0") {
            writer.uint32(8).uint64(message.eventNonce);
        }
        if (message.blockHeight !== "0") {
            writer.uint32(16).uint64(message.blockHeight);
        }
        if (message.tokenContract !== "") {
            writer.uint32(26).string(message.tokenContract);
        }
        if (message.amount !== "") {
            writer.uint32(34).string(message.amount);
        }
        if (message.ethereumSender !== "") {
            writer.uint32(42).string(message.ethereumSender);
        }
        if (message.cosmosReceiver !== "") {
            writer.uint32(50).string(message.cosmosReceiver);
        }
        if (message.orchestrator !== "") {
            writer.uint32(58).string(message.orchestrator);
        }
        if (message.data !== "") {
            writer.uint32(66).string(message.data);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositClaim();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.eventNonce = longToString(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.blockHeight = longToString(reader.uint64());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.tokenContract = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.amount = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.ethereumSender = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.cosmosReceiver = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.orchestrator = reader.string();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.data = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            eventNonce: isSet(object.eventNonce) ? globalThis.String(object.eventNonce) : "0",
            blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0",
            tokenContract: isSet(object.tokenContract) ? globalThis.String(object.tokenContract) : "",
            amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
            ethereumSender: isSet(object.ethereumSender) ? globalThis.String(object.ethereumSender) : "",
            cosmosReceiver: isSet(object.cosmosReceiver) ? globalThis.String(object.cosmosReceiver) : "",
            orchestrator: isSet(object.orchestrator) ? globalThis.String(object.orchestrator) : "",
            data: isSet(object.data) ? globalThis.String(object.data) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.eventNonce !== "0") {
            obj.eventNonce = message.eventNonce;
        }
        if (message.blockHeight !== "0") {
            obj.blockHeight = message.blockHeight;
        }
        if (message.tokenContract !== "") {
            obj.tokenContract = message.tokenContract;
        }
        if (message.amount !== "") {
            obj.amount = message.amount;
        }
        if (message.ethereumSender !== "") {
            obj.ethereumSender = message.ethereumSender;
        }
        if (message.cosmosReceiver !== "") {
            obj.cosmosReceiver = message.cosmosReceiver;
        }
        if (message.orchestrator !== "") {
            obj.orchestrator = message.orchestrator;
        }
        if (message.data !== "") {
            obj.data = message.data;
        }
        return obj;
    },
    create(base) {
        return MsgDepositClaim.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const message = createBaseMsgDepositClaim();
        message.eventNonce = (_a = object.eventNonce) !== null && _a !== void 0 ? _a : "0";
        message.blockHeight = (_b = object.blockHeight) !== null && _b !== void 0 ? _b : "0";
        message.tokenContract = (_c = object.tokenContract) !== null && _c !== void 0 ? _c : "";
        message.amount = (_d = object.amount) !== null && _d !== void 0 ? _d : "";
        message.ethereumSender = (_e = object.ethereumSender) !== null && _e !== void 0 ? _e : "";
        message.cosmosReceiver = (_f = object.cosmosReceiver) !== null && _f !== void 0 ? _f : "";
        message.orchestrator = (_g = object.orchestrator) !== null && _g !== void 0 ? _g : "";
        message.data = (_h = object.data) !== null && _h !== void 0 ? _h : "";
        return message;
    },
};
function createBaseMsgDepositClaimResponse() {
    return {};
}
export const MsgDepositClaimResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositClaimResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgDepositClaimResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgDepositClaimResponse();
        return message;
    },
};
function createBaseMsgWithdrawClaim() {
    return { eventNonce: "0", blockHeight: "0", batchNonce: "0", tokenContract: "", orchestrator: "" };
}
export const MsgWithdrawClaim = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.eventNonce !== "0") {
            writer.uint32(8).uint64(message.eventNonce);
        }
        if (message.blockHeight !== "0") {
            writer.uint32(16).uint64(message.blockHeight);
        }
        if (message.batchNonce !== "0") {
            writer.uint32(24).uint64(message.batchNonce);
        }
        if (message.tokenContract !== "") {
            writer.uint32(34).string(message.tokenContract);
        }
        if (message.orchestrator !== "") {
            writer.uint32(42).string(message.orchestrator);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawClaim();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.eventNonce = longToString(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.blockHeight = longToString(reader.uint64());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.batchNonce = longToString(reader.uint64());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.tokenContract = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.orchestrator = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            eventNonce: isSet(object.eventNonce) ? globalThis.String(object.eventNonce) : "0",
            blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0",
            batchNonce: isSet(object.batchNonce) ? globalThis.String(object.batchNonce) : "0",
            tokenContract: isSet(object.tokenContract) ? globalThis.String(object.tokenContract) : "",
            orchestrator: isSet(object.orchestrator) ? globalThis.String(object.orchestrator) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.eventNonce !== "0") {
            obj.eventNonce = message.eventNonce;
        }
        if (message.blockHeight !== "0") {
            obj.blockHeight = message.blockHeight;
        }
        if (message.batchNonce !== "0") {
            obj.batchNonce = message.batchNonce;
        }
        if (message.tokenContract !== "") {
            obj.tokenContract = message.tokenContract;
        }
        if (message.orchestrator !== "") {
            obj.orchestrator = message.orchestrator;
        }
        return obj;
    },
    create(base) {
        return MsgWithdrawClaim.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseMsgWithdrawClaim();
        message.eventNonce = (_a = object.eventNonce) !== null && _a !== void 0 ? _a : "0";
        message.blockHeight = (_b = object.blockHeight) !== null && _b !== void 0 ? _b : "0";
        message.batchNonce = (_c = object.batchNonce) !== null && _c !== void 0 ? _c : "0";
        message.tokenContract = (_d = object.tokenContract) !== null && _d !== void 0 ? _d : "";
        message.orchestrator = (_e = object.orchestrator) !== null && _e !== void 0 ? _e : "";
        return message;
    },
};
function createBaseMsgWithdrawClaimResponse() {
    return {};
}
export const MsgWithdrawClaimResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawClaimResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgWithdrawClaimResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgWithdrawClaimResponse();
        return message;
    },
};
function createBaseMsgERC20DeployedClaim() {
    return {
        eventNonce: "0",
        blockHeight: "0",
        cosmosDenom: "",
        tokenContract: "",
        name: "",
        symbol: "",
        decimals: "0",
        orchestrator: "",
    };
}
export const MsgERC20DeployedClaim = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.eventNonce !== "0") {
            writer.uint32(8).uint64(message.eventNonce);
        }
        if (message.blockHeight !== "0") {
            writer.uint32(16).uint64(message.blockHeight);
        }
        if (message.cosmosDenom !== "") {
            writer.uint32(26).string(message.cosmosDenom);
        }
        if (message.tokenContract !== "") {
            writer.uint32(34).string(message.tokenContract);
        }
        if (message.name !== "") {
            writer.uint32(42).string(message.name);
        }
        if (message.symbol !== "") {
            writer.uint32(50).string(message.symbol);
        }
        if (message.decimals !== "0") {
            writer.uint32(56).uint64(message.decimals);
        }
        if (message.orchestrator !== "") {
            writer.uint32(66).string(message.orchestrator);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgERC20DeployedClaim();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.eventNonce = longToString(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.blockHeight = longToString(reader.uint64());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.cosmosDenom = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.tokenContract = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.symbol = reader.string();
                    continue;
                case 7:
                    if (tag !== 56) {
                        break;
                    }
                    message.decimals = longToString(reader.uint64());
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.orchestrator = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            eventNonce: isSet(object.eventNonce) ? globalThis.String(object.eventNonce) : "0",
            blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0",
            cosmosDenom: isSet(object.cosmosDenom) ? globalThis.String(object.cosmosDenom) : "",
            tokenContract: isSet(object.tokenContract) ? globalThis.String(object.tokenContract) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
            decimals: isSet(object.decimals) ? globalThis.String(object.decimals) : "0",
            orchestrator: isSet(object.orchestrator) ? globalThis.String(object.orchestrator) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.eventNonce !== "0") {
            obj.eventNonce = message.eventNonce;
        }
        if (message.blockHeight !== "0") {
            obj.blockHeight = message.blockHeight;
        }
        if (message.cosmosDenom !== "") {
            obj.cosmosDenom = message.cosmosDenom;
        }
        if (message.tokenContract !== "") {
            obj.tokenContract = message.tokenContract;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.symbol !== "") {
            obj.symbol = message.symbol;
        }
        if (message.decimals !== "0") {
            obj.decimals = message.decimals;
        }
        if (message.orchestrator !== "") {
            obj.orchestrator = message.orchestrator;
        }
        return obj;
    },
    create(base) {
        return MsgERC20DeployedClaim.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const message = createBaseMsgERC20DeployedClaim();
        message.eventNonce = (_a = object.eventNonce) !== null && _a !== void 0 ? _a : "0";
        message.blockHeight = (_b = object.blockHeight) !== null && _b !== void 0 ? _b : "0";
        message.cosmosDenom = (_c = object.cosmosDenom) !== null && _c !== void 0 ? _c : "";
        message.tokenContract = (_d = object.tokenContract) !== null && _d !== void 0 ? _d : "";
        message.name = (_e = object.name) !== null && _e !== void 0 ? _e : "";
        message.symbol = (_f = object.symbol) !== null && _f !== void 0 ? _f : "";
        message.decimals = (_g = object.decimals) !== null && _g !== void 0 ? _g : "0";
        message.orchestrator = (_h = object.orchestrator) !== null && _h !== void 0 ? _h : "";
        return message;
    },
};
function createBaseMsgERC20DeployedClaimResponse() {
    return {};
}
export const MsgERC20DeployedClaimResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgERC20DeployedClaimResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgERC20DeployedClaimResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgERC20DeployedClaimResponse();
        return message;
    },
};
function createBaseMsgCancelSendToEth() {
    return { transactionId: "0", sender: "" };
}
export const MsgCancelSendToEth = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.transactionId !== "0") {
            writer.uint32(8).uint64(message.transactionId);
        }
        if (message.sender !== "") {
            writer.uint32(18).string(message.sender);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelSendToEth();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.transactionId = longToString(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.sender = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : "0",
            sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.transactionId !== "0") {
            obj.transactionId = message.transactionId;
        }
        if (message.sender !== "") {
            obj.sender = message.sender;
        }
        return obj;
    },
    create(base) {
        return MsgCancelSendToEth.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgCancelSendToEth();
        message.transactionId = (_a = object.transactionId) !== null && _a !== void 0 ? _a : "0";
        message.sender = (_b = object.sender) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseMsgCancelSendToEthResponse() {
    return {};
}
export const MsgCancelSendToEthResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelSendToEthResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgCancelSendToEthResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgCancelSendToEthResponse();
        return message;
    },
};
function createBaseMsgSubmitBadSignatureEvidence() {
    return { subject: undefined, signature: "", sender: "" };
}
export const MsgSubmitBadSignatureEvidence = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.subject !== undefined) {
            Any.encode(message.subject, writer.uint32(10).fork()).ldelim();
        }
        if (message.signature !== "") {
            writer.uint32(18).string(message.signature);
        }
        if (message.sender !== "") {
            writer.uint32(26).string(message.sender);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitBadSignatureEvidence();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.subject = Any.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.signature = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.sender = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            subject: isSet(object.subject) ? Any.fromJSON(object.subject) : undefined,
            signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
            sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.subject !== undefined) {
            obj.subject = Any.toJSON(message.subject);
        }
        if (message.signature !== "") {
            obj.signature = message.signature;
        }
        if (message.sender !== "") {
            obj.sender = message.sender;
        }
        return obj;
    },
    create(base) {
        return MsgSubmitBadSignatureEvidence.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgSubmitBadSignatureEvidence();
        message.subject = (object.subject !== undefined && object.subject !== null)
            ? Any.fromPartial(object.subject)
            : undefined;
        message.signature = (_a = object.signature) !== null && _a !== void 0 ? _a : "";
        message.sender = (_b = object.sender) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseMsgSubmitBadSignatureEvidenceResponse() {
    return {};
}
export const MsgSubmitBadSignatureEvidenceResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitBadSignatureEvidenceResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgSubmitBadSignatureEvidenceResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgSubmitBadSignatureEvidenceResponse();
        return message;
    },
};
function createBaseMsgValsetUpdatedClaim() {
    return {
        eventNonce: "0",
        valsetNonce: "0",
        blockHeight: "0",
        members: [],
        rewardAmount: "",
        rewardToken: "",
        orchestrator: "",
    };
}
export const MsgValsetUpdatedClaim = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.eventNonce !== "0") {
            writer.uint32(8).uint64(message.eventNonce);
        }
        if (message.valsetNonce !== "0") {
            writer.uint32(16).uint64(message.valsetNonce);
        }
        if (message.blockHeight !== "0") {
            writer.uint32(24).uint64(message.blockHeight);
        }
        for (const v of message.members) {
            BridgeValidator.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.rewardAmount !== "") {
            writer.uint32(42).string(message.rewardAmount);
        }
        if (message.rewardToken !== "") {
            writer.uint32(50).string(message.rewardToken);
        }
        if (message.orchestrator !== "") {
            writer.uint32(58).string(message.orchestrator);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgValsetUpdatedClaim();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.eventNonce = longToString(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.valsetNonce = longToString(reader.uint64());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.blockHeight = longToString(reader.uint64());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.members.push(BridgeValidator.decode(reader, reader.uint32()));
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.rewardAmount = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.rewardToken = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.orchestrator = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            eventNonce: isSet(object.eventNonce) ? globalThis.String(object.eventNonce) : "0",
            valsetNonce: isSet(object.valsetNonce) ? globalThis.String(object.valsetNonce) : "0",
            blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0",
            members: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.members)
                ? object.members.map((e) => BridgeValidator.fromJSON(e))
                : [],
            rewardAmount: isSet(object.rewardAmount) ? globalThis.String(object.rewardAmount) : "",
            rewardToken: isSet(object.rewardToken) ? globalThis.String(object.rewardToken) : "",
            orchestrator: isSet(object.orchestrator) ? globalThis.String(object.orchestrator) : "",
        };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if (message.eventNonce !== "0") {
            obj.eventNonce = message.eventNonce;
        }
        if (message.valsetNonce !== "0") {
            obj.valsetNonce = message.valsetNonce;
        }
        if (message.blockHeight !== "0") {
            obj.blockHeight = message.blockHeight;
        }
        if ((_a = message.members) === null || _a === void 0 ? void 0 : _a.length) {
            obj.members = message.members.map((e) => BridgeValidator.toJSON(e));
        }
        if (message.rewardAmount !== "") {
            obj.rewardAmount = message.rewardAmount;
        }
        if (message.rewardToken !== "") {
            obj.rewardToken = message.rewardToken;
        }
        if (message.orchestrator !== "") {
            obj.orchestrator = message.orchestrator;
        }
        return obj;
    },
    create(base) {
        return MsgValsetUpdatedClaim.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseMsgValsetUpdatedClaim();
        message.eventNonce = (_a = object.eventNonce) !== null && _a !== void 0 ? _a : "0";
        message.valsetNonce = (_b = object.valsetNonce) !== null && _b !== void 0 ? _b : "0";
        message.blockHeight = (_c = object.blockHeight) !== null && _c !== void 0 ? _c : "0";
        message.members = ((_d = object.members) === null || _d === void 0 ? void 0 : _d.map((e) => BridgeValidator.fromPartial(e))) || [];
        message.rewardAmount = (_e = object.rewardAmount) !== null && _e !== void 0 ? _e : "";
        message.rewardToken = (_f = object.rewardToken) !== null && _f !== void 0 ? _f : "";
        message.orchestrator = (_g = object.orchestrator) !== null && _g !== void 0 ? _g : "";
        return message;
    },
};
function createBaseMsgValsetUpdatedClaimResponse() {
    return {};
}
export const MsgValsetUpdatedClaimResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgValsetUpdatedClaimResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgValsetUpdatedClaimResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgValsetUpdatedClaimResponse();
        return message;
    },
};
function createBaseMsgUpdateParams() {
    return { authority: "", params: undefined };
}
export const MsgUpdateParams = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.authority !== "") {
            writer.uint32(10).string(message.authority);
        }
        if (message.params !== undefined) {
            Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.authority = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.params = Params.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
            params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.authority !== "") {
            obj.authority = message.authority;
        }
        if (message.params !== undefined) {
            obj.params = Params.toJSON(message.params);
        }
        return obj;
    },
    create(base) {
        return MsgUpdateParams.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgUpdateParams();
        message.authority = (_a = object.authority) !== null && _a !== void 0 ? _a : "";
        message.params = (object.params !== undefined && object.params !== null)
            ? Params.fromPartial(object.params)
            : undefined;
        return message;
    },
};
function createBaseMsgUpdateParamsResponse() {
    return {};
}
export const MsgUpdateParamsResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgUpdateParamsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
    },
};
export class MsgClientImpl {
    constructor(rpc) {
        this.rpc = rpc;
        this.ValsetConfirm = this.ValsetConfirm.bind(this);
        this.SendToEth = this.SendToEth.bind(this);
        this.RequestBatch = this.RequestBatch.bind(this);
        this.ConfirmBatch = this.ConfirmBatch.bind(this);
        this.DepositClaim = this.DepositClaim.bind(this);
        this.WithdrawClaim = this.WithdrawClaim.bind(this);
        this.ValsetUpdateClaim = this.ValsetUpdateClaim.bind(this);
        this.ERC20DeployedClaim = this.ERC20DeployedClaim.bind(this);
        this.SetOrchestratorAddresses = this.SetOrchestratorAddresses.bind(this);
        this.CancelSendToEth = this.CancelSendToEth.bind(this);
        this.SubmitBadSignatureEvidence = this.SubmitBadSignatureEvidence.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
    }
    ValsetConfirm(request, metadata) {
        return this.rpc.unary(MsgValsetConfirmDesc, MsgValsetConfirm.fromPartial(request), metadata);
    }
    SendToEth(request, metadata) {
        return this.rpc.unary(MsgSendToEthDesc, MsgSendToEth.fromPartial(request), metadata);
    }
    RequestBatch(request, metadata) {
        return this.rpc.unary(MsgRequestBatchDesc, MsgRequestBatch.fromPartial(request), metadata);
    }
    ConfirmBatch(request, metadata) {
        return this.rpc.unary(MsgConfirmBatchDesc, MsgConfirmBatch.fromPartial(request), metadata);
    }
    DepositClaim(request, metadata) {
        return this.rpc.unary(MsgDepositClaimDesc, MsgDepositClaim.fromPartial(request), metadata);
    }
    WithdrawClaim(request, metadata) {
        return this.rpc.unary(MsgWithdrawClaimDesc, MsgWithdrawClaim.fromPartial(request), metadata);
    }
    ValsetUpdateClaim(request, metadata) {
        return this.rpc.unary(MsgValsetUpdateClaimDesc, MsgValsetUpdatedClaim.fromPartial(request), metadata);
    }
    ERC20DeployedClaim(request, metadata) {
        return this.rpc.unary(MsgERC20DeployedClaimDesc, MsgERC20DeployedClaim.fromPartial(request), metadata);
    }
    SetOrchestratorAddresses(request, metadata) {
        return this.rpc.unary(MsgSetOrchestratorAddressesDesc, MsgSetOrchestratorAddresses.fromPartial(request), metadata);
    }
    CancelSendToEth(request, metadata) {
        return this.rpc.unary(MsgCancelSendToEthDesc, MsgCancelSendToEth.fromPartial(request), metadata);
    }
    SubmitBadSignatureEvidence(request, metadata) {
        return this.rpc.unary(MsgSubmitBadSignatureEvidenceDesc, MsgSubmitBadSignatureEvidence.fromPartial(request), metadata);
    }
    UpdateParams(request, metadata) {
        return this.rpc.unary(MsgUpdateParamsDesc, MsgUpdateParams.fromPartial(request), metadata);
    }
}
export const MsgDesc = { serviceName: "injective.peggy.v1.Msg" };
export const MsgValsetConfirmDesc = {
    methodName: "ValsetConfirm",
    service: MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgValsetConfirm.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgValsetConfirmResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
export const MsgSendToEthDesc = {
    methodName: "SendToEth",
    service: MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgSendToEth.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgSendToEthResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
export const MsgRequestBatchDesc = {
    methodName: "RequestBatch",
    service: MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgRequestBatch.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgRequestBatchResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
export const MsgConfirmBatchDesc = {
    methodName: "ConfirmBatch",
    service: MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgConfirmBatch.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgConfirmBatchResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
export const MsgDepositClaimDesc = {
    methodName: "DepositClaim",
    service: MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgDepositClaim.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgDepositClaimResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
export const MsgWithdrawClaimDesc = {
    methodName: "WithdrawClaim",
    service: MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgWithdrawClaim.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgWithdrawClaimResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
export const MsgValsetUpdateClaimDesc = {
    methodName: "ValsetUpdateClaim",
    service: MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgValsetUpdatedClaim.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgValsetUpdatedClaimResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
export const MsgERC20DeployedClaimDesc = {
    methodName: "ERC20DeployedClaim",
    service: MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgERC20DeployedClaim.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgERC20DeployedClaimResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
export const MsgSetOrchestratorAddressesDesc = {
    methodName: "SetOrchestratorAddresses",
    service: MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgSetOrchestratorAddresses.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgSetOrchestratorAddressesResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
export const MsgCancelSendToEthDesc = {
    methodName: "CancelSendToEth",
    service: MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgCancelSendToEth.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgCancelSendToEthResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
export const MsgSubmitBadSignatureEvidenceDesc = {
    methodName: "SubmitBadSignatureEvidence",
    service: MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgSubmitBadSignatureEvidence.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgSubmitBadSignatureEvidenceResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
export const MsgUpdateParamsDesc = {
    methodName: "UpdateParams",
    service: MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgUpdateParams.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgUpdateParamsResponse.decode(data);
            return Object.assign(Object.assign({}, value), { toObject() {
                    return value;
                } });
        },
    },
};
export class GrpcWebImpl {
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        var _a;
        const request = Object.assign(Object.assign({}, _request), methodDesc.requestType);
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders(Object.assign(Object.assign({}, (_a = this.options) === null || _a === void 0 ? void 0 : _a.metadata.headersMap), metadata === null || metadata === void 0 ? void 0 : metadata.headersMap))
            : metadata !== null && metadata !== void 0 ? metadata : this.options.metadata;
        return new Promise((resolve, reject) => {
            var _a;
            grpc.unary(methodDesc, Object.assign(Object.assign({ request, host: this.host, metadata: maybeCombinedMetadata !== null && maybeCombinedMetadata !== void 0 ? maybeCombinedMetadata : {} }, (this.options.transport !== undefined ? { transport: this.options.transport } : {})), { debug: (_a = this.options.debug) !== null && _a !== void 0 ? _a : false, onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                } }));
        });
    }
}
function longToString(long) {
    return long.toString();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
export class GrpcWebError extends globalThis.Error {
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
}
