"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenFactoryStatic = void 0;
const types_1 = require("./../types");
class TokenFactoryStatic {
    constructor(registry) {
        this.registry = registry;
        this.tokensByDenom = registry.reduce((list, token) => {
            const denom = token.denom.toLowerCase();
            if (list[denom]) {
                return list;
            }
            return Object.assign(Object.assign({}, list), { [denom]: token });
        }, {});
        this.tokensBySymbol = registry.reduce((list, token) => {
            const symbol = token.symbol.toLowerCase();
            return Object.assign(Object.assign({}, list), { [symbol]: [...(list[symbol] || []), token] });
        }, {});
    }
    toToken(denom) {
        return this.getMetaByDenomOrAddress(denom) || this.getMetaBySymbol(denom);
    }
    getMetaBySymbol(symbol, { type, source, verification, } = {}) {
        const tokensBySymbol = this.tokensBySymbol[symbol.toLowerCase()];
        if (!tokensBySymbol) {
            return;
        }
        const token = tokensBySymbol.find((token) => {
            const isType = !type || token.tokenType === type;
            const isSource = !source || token.source === source;
            const isVerification = !verification || token.tokenVerification === verification;
            return isType && isSource && isVerification;
        });
        const sortedTokens = tokensBySymbol.sort((t1, t2) => {
            const t1IsVerified = t1.tokenVerification === types_1.TokenVerification.Verified;
            const t2IsVerified = t2.tokenVerification === types_1.TokenVerification.Verified;
            return t1IsVerified && !t2IsVerified ? -1 : 1;
        });
        return token || sortedTokens[0];
    }
    getMetaByDenomOrAddress(denom) {
        const formattedDenom = denom.toLowerCase();
        return this.tokensByDenom[formattedDenom];
    }
}
exports.TokenFactoryStatic = TokenFactoryStatic;
//# sourceMappingURL=TokenFactoryStatic.js.map