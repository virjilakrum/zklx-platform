import { ChainId, EthereumChainId } from '@injectivelabs/ts-types';
import { Msgs } from '../../msgs';
import { GoogleProtobufAny, CosmosTxV1Beta1Tx, CosmosBaseV1Beta1Coin, InjectiveTypesV1TxExt, CosmosTxSigningV1Beta1Signing } from '@injectivelabs/core-proto-ts';
export declare const getPublicKey: ({ chainId, key, }: {
    chainId: string;
    key: string | GoogleProtobufAny.Any;
}) => GoogleProtobufAny.Any;
export declare const createBody: ({ message, memo, timeoutHeight, }: {
    message: Msgs | Msgs[];
    memo?: string | undefined;
    timeoutHeight?: number | undefined;
}) => CosmosTxV1Beta1Tx.TxBody;
export declare const createFee: ({ fee, payer, granter, gasLimit, }: {
    fee: {
        amount: string;
        denom: string;
    };
    payer?: string | undefined;
    granter?: string | undefined;
    gasLimit: number;
}) => CosmosTxV1Beta1Tx.Fee;
export declare const createSigners: ({ chainId, mode, signers, }: {
    chainId: string;
    signers: {
        pubKey: string | GoogleProtobufAny.Any;
        sequence: number;
    }[];
    mode: CosmosTxSigningV1Beta1Signing.SignMode;
}) => CosmosTxV1Beta1Tx.SignerInfo[];
export declare const createSignerInfo: ({ chainId, publicKey, sequence, mode, }: {
    chainId: string;
    publicKey: string | GoogleProtobufAny.Any;
    sequence: number;
    mode: CosmosTxSigningV1Beta1Signing.SignMode;
}) => CosmosTxV1Beta1Tx.SignerInfo;
export declare const createAuthInfo: ({ signerInfo, fee, }: {
    signerInfo: CosmosTxV1Beta1Tx.SignerInfo[];
    fee: CosmosTxV1Beta1Tx.Fee;
}) => CosmosTxV1Beta1Tx.AuthInfo;
export declare const createSignDoc: ({ bodyBytes, authInfoBytes, chainId, accountNumber, }: {
    bodyBytes: Uint8Array;
    authInfoBytes: Uint8Array;
    chainId: string;
    accountNumber: number;
}) => CosmosTxV1Beta1Tx.SignDoc;
export declare const createSignDocFromTransaction: (args: {
    txRaw: CosmosTxV1Beta1Tx.TxRaw;
    chainId: string;
    accountNumber: number;
}) => CosmosTxV1Beta1Tx.SignDoc;
export declare const createTxRawEIP712: (txRaw: CosmosTxV1Beta1Tx.TxRaw, extension: InjectiveTypesV1TxExt.ExtensionOptionsWeb3Tx) => CosmosTxV1Beta1Tx.TxRaw;
export declare const createWeb3Extension: ({ ethereumChainId, feePayer, feePayerSig, }: {
    ethereumChainId: EthereumChainId;
    feePayer?: string | undefined;
    feePayerSig?: Uint8Array | undefined;
}) => InjectiveTypesV1TxExt.ExtensionOptionsWeb3Tx;
export declare const getTransactionPartsFromTxRaw: (txRaw: CosmosTxV1Beta1Tx.TxRaw) => {
    authInfo: CosmosTxV1Beta1Tx.AuthInfo;
    body: CosmosTxV1Beta1Tx.TxBody;
    signatures: Uint8Array[];
};
export declare const getAminoStdSignDoc: ({ memo, chainId, accountNumber, timeoutHeight, sequence, gas, msgs, }: {
    memo?: string | undefined;
    chainId: ChainId;
    timeoutHeight?: string | undefined;
    accountNumber: number;
    sequence: number;
    gas?: string | undefined;
    msgs: Msgs[];
}) => {
    chain_id: ChainId;
    timeout_height: string;
    account_number: string;
    sequence: string;
    fee: {
        amount: {
            denom: string;
            amount: string;
        }[];
        gas: string;
        payer: string | undefined;
        granter: string | undefined;
        feePayer: string | undefined;
    };
    msgs: ({
        type: string;
        value: {
            granter: string;
            grantee: string;
            msg_type_url: string;
        };
    } | {
        type: string;
        value: import("../../authz/msgs/MsgExec").MsgExec.Object;
    } | {
        type: string;
        value: {
            from_address: string;
            to_address: string;
            amount: CosmosBaseV1Beta1Coin.Coin[];
        };
    } | {
        type: string;
        value: {
            inputs: import("@injectivelabs/core-proto-ts/cjs/cosmos/bank/v1beta1/bank").Input[];
            outputs: import("@injectivelabs/core-proto-ts/cjs/cosmos/bank/v1beta1/bank").Output[];
        };
    } | {
        type: string;
        value: {
            proposal_id: string;
            depositor: string;
            amount: CosmosBaseV1Beta1Coin.Coin[];
        };
    } | {
        type: string;
        value: {
            initial_deposit: {
                denom: string;
                amount: string;
            }[];
            proposer: string;
            content: {
                type_url: string;
                value: any;
            };
        };
    } | {
        type: string;
        value: import("../../gov/msgs/MsgSubmitProposalPerpetualMarketLaunch").MsgSubmitProposalPerpetualMarketLaunch.Object;
    } | {
        type: string;
        value: {
            proposal_id: string;
            voter: string;
            option: import("@injectivelabs/core-proto-ts/cjs/cosmos/gov/v1/gov").VoteOption;
            metadata: string;
        };
    } | {
        type: string;
        value: {
            delegator_address: string;
            validator_src_address: string;
            validator_dst_address: string;
            amount: CosmosBaseV1Beta1Coin.Coin | undefined;
        };
    } | {
        type: string;
        value: {
            validator_address: string;
        };
    } | {
        type: string;
        value: {
            sender: string;
        };
    } | {
        type: string;
        value: import("../../staking/msgs/MsgCreateValidator").MsgCreateValidator.Object;
    } | {
        type: string;
        value: import("../../feegrant/msgs/MsgGrantAllowance").MsgGrantAllowance.Object;
    } | {
        type: string;
        value: {
            to_proto: {};
            to_data: {};
            to_amino: {};
            to_web3: {};
            to_direct_sign: {};
            to_binary: {};
            params: {
                granter: string;
                grantee: string;
            };
            to_j_s_o_n: {};
            to_eip712_types: {};
            to_eip712: {};
            to_direct_sign_j_s_o_n: {};
        };
    } | {
        type: string;
        value: {
            signer: Uint8Array;
            data: Uint8Array;
        };
    })[];
    memo: string;
};
//# sourceMappingURL=tx.d.ts.map