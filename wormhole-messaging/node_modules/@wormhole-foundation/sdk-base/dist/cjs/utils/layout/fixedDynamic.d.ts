import type { Layout, ProperLayout, LayoutItem, NumLayoutItem, BytesLayoutItem, ArrayLayoutItem, SwitchLayoutItem, LayoutToType, NumType, BytesType, LayoutObject, FixedConversion, CustomConversion } from './layout.js';
type NonEmpty = readonly [unknown, ...unknown[]];
type IPLPair = readonly [any, ProperLayout];
type FilterItemsOfIPLPairs<ILA extends readonly IPLPair[], Fixed extends boolean> = ILA extends infer V extends readonly IPLPair[] ? V extends readonly [infer H extends IPLPair, ...infer T extends readonly IPLPair[]] ? FilterItemsOfLayout<H[1], Fixed> extends infer P extends ProperLayout | void ? P extends NonEmpty ? [[H[0], P], ...FilterItemsOfIPLPairs<T, Fixed>] : FilterItemsOfIPLPairs<T, Fixed> : never : [] : never;
type FilterLayoutOfItem<Item extends {
    layout: Layout;
}, Fixed extends boolean> = FilterItemsOfLayout<Item["layout"], Fixed> extends infer L extends LayoutItem | NonEmpty ? {
    readonly [K in keyof Item]: K extends "layout" ? L : Item[K];
} : void;
type FilterItem<Item extends LayoutItem, Fixed extends boolean> = Item extends infer I extends LayoutItem ? I extends NumLayoutItem ? I["custom"] extends NumType | FixedConversion<infer From extends NumType, infer To> ? Fixed extends true ? I : void : Fixed extends true ? void : I : I extends ArrayLayoutItem ? FilterLayoutOfItem<I, Fixed> : I extends BytesLayoutItem & {
    layout: Layout;
} ? I["custom"] extends {
    custom: FixedConversion<infer From extends LayoutObject, infer To>;
} ? Fixed extends true ? I : void : I extends {
    custom: CustomConversion<infer From extends LayoutObject, infer To>;
} ? Fixed extends true ? void : I : FilterLayoutOfItem<I, Fixed> : I extends BytesLayoutItem ? I["custom"] extends BytesType | FixedConversion<infer From extends BytesType, infer To> ? Fixed extends true ? I : void : Fixed extends true ? void : I : I extends SwitchLayoutItem ? {
    readonly [K in keyof I]: K extends "layouts" ? FilterItemsOfIPLPairs<I["layouts"], Fixed> : I[K];
} : never : never;
type FilterItemsOfLayout<L extends Layout, Fixed extends boolean> = L extends infer LI extends LayoutItem ? FilterItem<LI, Fixed> : L extends infer P extends ProperLayout ? P extends readonly [infer H extends LayoutItem, ...infer T extends ProperLayout] ? FilterItem<H, Fixed> extends infer NI ? NI extends LayoutItem ? [NI, ...FilterItemsOfLayout<T, Fixed>] : FilterItemsOfLayout<T, Fixed> : never : [] : never;
type StartFilterItemsOfLayout<L extends Layout, Fixed extends boolean> = FilterItemsOfLayout<L, Fixed> extends infer V extends Layout ? V : never;
export type FixedItemsOfLayout<L extends Layout> = StartFilterItemsOfLayout<L, true>;
export type DynamicItemsOfLayout<L extends Layout> = StartFilterItemsOfLayout<L, false>;
export declare const fixedItemsOfLayout: <L extends Layout>(layout: L) => FilterItemsOfLayout<L, true>;
export declare const dynamicItemsOfLayout: <L extends Layout>(layout: L) => FilterItemsOfLayout<L, false>;
export declare function addFixedValues<const L extends Layout>(layout: L, dynamicValues: LayoutToType<DynamicItemsOfLayout<L>>): LayoutToType<L>;
export {};
//# sourceMappingURL=fixedDynamic.d.ts.map