"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bitsetItem = exports.optionItem = exports.enumItem = void 0;
const layout_js_1 = require("./layout.js");
const utils_js_1 = require("./utils.js");
function enumItem(entries, opts) {
    const valueToName = Object.fromEntries(entries.map(([name, value]) => [value, name]));
    const nameToValue = Object.fromEntries(entries);
    return {
        binary: "uint",
        size: opts?.size ?? 1,
        endianness: opts?.endianness ?? "big",
        custom: {
            to: (encoded) => {
                const name = valueToName[encoded];
                if (name === undefined)
                    throw new Error(`Invalid enum value: ${encoded}`);
                return name;
            },
            from: (name) => nameToValue[name],
        }
    };
}
exports.enumItem = enumItem;
const baseOptionItem = (someType) => ({
    binary: "switch",
    idSize: 1,
    idTag: "isSome",
    layouts: [
        [[0, false], []],
        [[1, true], [(0, utils_js_1.customizableBytes)({ name: "value" }, someType)]],
    ]
});
function optionItem(optVal) {
    return {
        binary: "bytes",
        layout: baseOptionItem(optVal),
        custom: {
            to: (obj) => obj.isSome === true
                //TODO I'm really not sure why we need to manually narrow the type here
                ? obj["value"]
                : undefined,
            from: (value) => value === undefined
                ? { isSome: false }
                //TODO and this is even more sketch
                : { isSome: true, value },
        }
    };
}
exports.optionItem = optionItem;
;
function bitsetItem(bitnames, size) {
    return {
        binary: "uint",
        size: (size ?? Math.ceil(bitnames.length / 8)),
        custom: {
            to: (encoded) => {
                const ret = {};
                for (let i = 0; i < bitnames.length; ++i)
                    if (bitnames[i]) //skip undefined and empty string
                        //always use bigint for simplicity
                        ret[bitnames[i]] = (BigInt(encoded) & (1n << BigInt(i))) !== 0n;
                return ret;
            },
            from: (obj) => {
                let val = 0n;
                for (let i = 0; i < bitnames.length; ++i)
                    if (bitnames[i] && obj[bitnames[i]])
                        val |= 1n << BigInt(i);
                return (bitnames.length > layout_js_1.numberMaxSize ? val : Number(val));
            },
        },
    };
}
exports.bitsetItem = bitsetItem;
//# sourceMappingURL=items.js.map