"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findIdLayoutPair = exports.checkBytesTypeEqual = exports.checkNumEquals = exports.checkItemSize = exports.checkSize = exports.customizableBytes = exports.isFixedPrimitiveConversion = exports.isFixedBytesConversion = exports.isFixedUintConversion = exports.isLayout = exports.isLayoutItem = exports.isPrimitiveType = exports.isBytesType = exports.isNumType = void 0;
const layout_js_1 = require("./layout.js");
const isNumType = (x) => typeof x === "number" || typeof x === "bigint";
exports.isNumType = isNumType;
const isBytesType = (x) => x instanceof Uint8Array;
exports.isBytesType = isBytesType;
const isPrimitiveType = (x) => (0, exports.isNumType)(x) || (0, exports.isBytesType)(x);
exports.isPrimitiveType = isPrimitiveType;
const isLayoutItem = (x) => layout_js_1.binaryLiterals.includes(x?.binary);
exports.isLayoutItem = isLayoutItem;
const isLayout = (x) => (0, exports.isLayoutItem)(x) || Array.isArray(x) && x.every(exports.isLayoutItem);
exports.isLayout = isLayout;
const isFixedNumberConversion = (custom) => typeof custom?.from === "number";
const isFixedBigintConversion = (custom) => typeof custom?.from === "bigint";
const isFixedUintConversion = (custom) => isFixedNumberConversion(custom) || isFixedBigintConversion(custom);
exports.isFixedUintConversion = isFixedUintConversion;
const isFixedBytesConversion = (custom) => (0, exports.isBytesType)(custom?.from);
exports.isFixedBytesConversion = isFixedBytesConversion;
const isFixedPrimitiveConversion = (custom) => (0, exports.isFixedUintConversion)(custom) || (0, exports.isFixedBytesConversion)(custom);
exports.isFixedPrimitiveConversion = isFixedPrimitiveConversion;
const customizableBytes = (base, spec) => ({
    ...base,
    binary: "bytes",
    ...(() => {
        if (spec === undefined)
            return {};
        if ((0, exports.isLayout)(spec))
            return { layout: spec };
        if (spec instanceof Uint8Array || (0, exports.isFixedBytesConversion)(spec) || !Array.isArray(spec))
            return { custom: spec };
        return { layout: spec[0], custom: spec[1] };
    })()
});
exports.customizableBytes = customizableBytes;
const checkSize = (layoutSize, dataSize) => {
    if (layoutSize !== dataSize)
        throw new Error(`size mismatch: layout size: ${layoutSize}, data size: ${dataSize}`);
    return dataSize;
};
exports.checkSize = checkSize;
const checkItemSize = (item, dataSize) => ("size" in item && item.size !== undefined) ? (0, exports.checkSize)(item.size, dataSize) : dataSize;
exports.checkItemSize = checkItemSize;
const checkNumEquals = (custom, data) => {
    if (custom != data)
        throw new Error(`value mismatch: (constant) layout value: ${custom}, data value: ${data}`);
};
exports.checkNumEquals = checkNumEquals;
const checkBytesTypeEqual = (custom, data, opts) => {
    const toSlice = (bytes, slice) => slice === undefined
        ? [0, bytes.length]
        : Array.isArray(slice)
            ? slice
            : [slice, bytes.length];
    const [customStart, customEnd] = toSlice(custom, opts?.customSlice);
    const [dataStart, dataEnd] = toSlice(data, opts?.dataSlize);
    const length = customEnd - customStart;
    (0, exports.checkSize)(length, dataEnd - dataStart);
    for (let i = 0; i < custom.length; ++i)
        if (custom[i + customStart] !== data[i + dataStart])
            throw new Error(`binary data mismatch: ` +
                `layout value: ${custom}, offset: ${customStart}, data value: ${data}, offset: ${dataStart}`);
};
exports.checkBytesTypeEqual = checkBytesTypeEqual;
function findIdLayoutPair(item, data) {
    const id = data[item.idTag ?? "id"];
    return item.layouts.find(([idOrConversionId]) => (Array.isArray(idOrConversionId) ? idOrConversionId[1] : idOrConversionId) == id);
}
exports.findIdLayoutPair = findIdLayoutPair;
//# sourceMappingURL=utils.js.map