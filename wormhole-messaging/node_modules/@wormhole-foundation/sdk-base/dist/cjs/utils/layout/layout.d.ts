export type NumType = number | bigint;
export type BytesType = Uint8Array;
export type PrimitiveType = NumType | BytesType;
export type LayoutObject = {
    readonly [key: string]: any;
};
export declare const binaryLiterals: readonly ["int", "uint", "bytes", "array", "switch"];
export type BinaryLiterals = typeof binaryLiterals[number];
export type Endianness = "little" | "big";
export declare const defaultEndianness = "big";
export declare const numberMaxSize = 6;
export type NumberSize = 1 | 2 | 3 | 4 | 5 | 6;
export type NumSizeToPrimitive<Size extends number> = Size extends NumberSize ? number : Size & NumberSize extends never ? bigint : number | bigint;
export type FixedConversion<FromType extends PrimitiveType | LayoutObject, ToType> = {
    readonly to: ToType;
    readonly from: FromType;
};
export type CustomConversion<FromType extends PrimitiveType | LayoutObject, ToType> = {
    readonly to: (val: FromType) => ToType;
    readonly from: (val: ToType) => FromType;
};
export interface LayoutItemBase<BL extends BinaryLiterals> {
    readonly binary: BL;
}
interface FixedOmittableCustom<T extends PrimitiveType> {
    custom: T;
    omit?: boolean;
}
export interface LengthPrefixed {
    readonly lengthSize: NumberSize;
    readonly lengthEndianness?: Endianness;
}
interface NumLayoutItemBase<T extends NumType, Signed extends Boolean> extends LayoutItemBase<Signed extends true ? "int" : "uint"> {
    size: T extends bigint ? number : NumberSize;
    endianness?: Endianness;
}
export interface FixedPrimitiveNum<T extends NumType, Signed extends Boolean> extends NumLayoutItemBase<T, Signed>, FixedOmittableCustom<T> {
}
export interface OptionalToFromNum<T extends NumType, Signed extends Boolean> extends NumLayoutItemBase<T, Signed> {
    custom?: FixedConversion<T, any> | CustomConversion<T, any>;
}
export interface FixedPrimitiveBytes extends LayoutItemBase<"bytes">, FixedOmittableCustom<BytesType> {
}
export interface FlexPureBytes extends LayoutItemBase<"bytes"> {
    readonly custom?: BytesType | FixedConversion<BytesType, any> | CustomConversion<BytesType, any>;
}
export interface FlexLayoutBytes extends LayoutItemBase<"bytes"> {
    readonly custom?: FixedConversion<LayoutObject, any> | CustomConversion<LayoutObject, any>;
    readonly layout: Layout;
}
export interface ManualSizePureBytes extends FlexPureBytes {
    readonly size: number;
}
export interface LengthPrefixedPureBytes extends FlexPureBytes, LengthPrefixed {
}
export interface ManualSizeLayoutBytes extends FlexLayoutBytes {
    readonly size: number;
}
export interface LengthPrefixedLayoutBytes extends FlexLayoutBytes, LengthPrefixed {
}
interface ArrayLayoutItemBase extends LayoutItemBase<"array"> {
    readonly layout: Layout;
}
export interface FixedLengthArray extends ArrayLayoutItemBase {
    readonly length: number;
}
export interface LengthPrefixedArray extends ArrayLayoutItemBase, LengthPrefixed {
}
export interface RemainderArray extends ArrayLayoutItemBase {
}
type PlainId = number;
type ConversionId = readonly [number, unknown];
type IdProperLayoutPair<Id extends PlainId | ConversionId, P extends ProperLayout = ProperLayout> = readonly [Id, P];
type IdProperLayoutPairs = readonly IdProperLayoutPair<PlainId>[] | readonly IdProperLayoutPair<ConversionId>[];
type DistributiveAtLeast1<T> = T extends any ? readonly [T, ...T[]] : never;
export interface SwitchLayoutItem extends LayoutItemBase<"switch"> {
    readonly idSize: NumberSize;
    readonly idEndianness?: Endianness;
    readonly idTag?: string;
    readonly layouts: DistributiveAtLeast1<IdProperLayoutPair<PlainId> | IdProperLayoutPair<ConversionId>>;
}
export type NumLayoutItem<Signed extends boolean = boolean> = Signed extends infer S extends boolean ? FixedPrimitiveNum<number, S> | OptionalToFromNum<number, S> | FixedPrimitiveNum<bigint, S> | OptionalToFromNum<bigint, S> : never;
export type UintLayoutItem = NumLayoutItem<false>;
export type IntLayoutItem = NumLayoutItem<true>;
export type BytesLayoutItem = FixedPrimitiveBytes | FlexPureBytes | ManualSizePureBytes | LengthPrefixedPureBytes | FlexLayoutBytes | ManualSizeLayoutBytes | LengthPrefixedLayoutBytes;
export type ArrayLayoutItem = FixedLengthArray | LengthPrefixedArray | RemainderArray;
export type LayoutItem = NumLayoutItem | BytesLayoutItem | ArrayLayoutItem | SwitchLayoutItem;
export type NamedLayoutItem = LayoutItem & {
    readonly name: string;
};
export type ProperLayout = readonly NamedLayoutItem[];
export type Layout = LayoutItem | ProperLayout;
type NameOrOmitted<T extends {
    name: string;
}> = T extends {
    omit: true;
} ? never : T["name"];
export type LayoutToType<L extends Layout> = Layout extends L ? any : L extends infer LI extends LayoutItem ? LayoutItemToType<LI> : L extends infer P extends ProperLayout ? {
    readonly [I in P[number] as NameOrOmitted<I>]: LayoutItemToType<I>;
} : never;
type MaybeConvert<Id extends PlainId | ConversionId> = Id extends readonly [number, infer Converted] ? Converted : Id;
type IdLayoutPairsToTypeUnion<A extends IdProperLayoutPairs, IdTag extends string> = A extends infer V extends IdProperLayoutPairs ? V extends readonly [infer Head, ...infer Tail extends IdProperLayoutPairs] ? Head extends IdProperLayoutPair<infer MaybeConversionId, infer P extends ProperLayout> ? MaybeConvert<MaybeConversionId> extends infer Id ? LayoutToType<P> extends infer LT extends LayoutObject ? {
    readonly [K in IdTag | keyof LT]: K extends keyof LT ? LT[K] : Id;
} | IdLayoutPairsToTypeUnion<Tail, IdTag> : never : never : never : never : never;
type LayoutItemToType<Item extends LayoutItem> = Item extends infer I extends LayoutItem ? I extends NumLayoutItem ? I["custom"] extends CustomConversion<infer From extends NumType, infer To> ? To : I["custom"] extends FixedConversion<infer From extends NumType, infer To> ? To : I["custom"] extends undefined ? NumSizeToPrimitive<I["size"]> : I["custom"] extends NumType ? I["custom"] : NumSizeToPrimitive<I["size"]> : I extends BytesLayoutItem ? I extends {
    layout: Layout;
} ? I["custom"] extends CustomConversion<infer From extends LayoutObject, infer To> ? To : I["custom"] extends FixedConversion<infer From extends LayoutObject, infer To> ? To : LayoutToType<I["layout"]> : I["custom"] extends CustomConversion<BytesType, infer To> ? To : I["custom"] extends FixedConversion<BytesType, infer To> ? To : BytesType : I extends ArrayLayoutItem ? readonly LayoutToType<I["layout"]>[] : I extends SwitchLayoutItem ? IdLayoutPairsToTypeUnion<I["layouts"], I["idTag"] extends undefined ? "id" : I["idTag"] extends string ? I["idTag"] : "id"> : never : never;
export {};
//# sourceMappingURL=layout.d.ts.map