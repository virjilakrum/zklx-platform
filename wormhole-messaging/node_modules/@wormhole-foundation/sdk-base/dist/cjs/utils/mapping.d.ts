import type { IndexEs, Flatten, InnerFlatten, IsRectangular, Zip, Cartesian, OnlyIndexes, ExcludeIndexes, ElementIndexPairs } from './array.js';
import type { Widen, RoArray, RoArray2D, RoPair } from './metaprogramming.js';
export type ShallowMapping<M extends RoArray<readonly [PropertyKey, unknown]>> = {
    readonly [E in M[number] as E[0]]: E[1];
};
export type MappableKey = PropertyKey | bigint | boolean;
export type MapLevel<K extends MappableKey, V> = RoArray<RoPair<K, V>>;
type MapLevelsTuple = readonly [MappableKey, ...RoArray<MappableKey>, unknown];
export type MapLevels<T extends MapLevelsTuple> = T extends readonly [infer Head extends MappableKey, ...infer Tail extends RoArray<unknown>] ? Tail extends MapLevelsTuple ? MapLevel<Head, MapLevels<Tail>> : MapLevel<Head, Tail[0]> : never;
type Depth = [never, 0, 1, 2, 3, 4];
type ToExtPropKey<T extends MappableKey> = T extends bigint ? `bigint(${T})` : T extends boolean ? `boolean(${T})` : T;
type FromExtPropKey<T extends PropertyKey> = T extends `bigint(${infer V extends bigint})` ? V : T extends `boolean(${infer V extends boolean})` ? V : T;
type MappingEntry<V = unknown> = RoPair<MappableKey, V>;
type MappingEntries<V = unknown> = RoArray<MappingEntry<V>>;
type CombineKeyRowIndexes<K extends MappableKey, T extends MappingEntries<number>, IA extends RoArray<number>, //all values associated with K
U extends MappingEntries<number> = []> = T extends readonly [
    infer Head extends MappingEntry<number>,
    ...infer Tail extends MappingEntries<number>
] ? Head[0] extends K ? CombineKeyRowIndexes<K, Tail, [...IA, Head[1]], U> : CombineKeyRowIndexes<K, Tail, IA, [...U, Head]> : [IA, U];
type ToMapEntries<KCI extends MappingEntries<number>, M extends MappingEntries = []> = KCI extends readonly [infer Head, ...infer Tail extends MappingEntries<number>] ? Head extends RoPair<infer K extends MappableKey, infer V extends number> ? CombineKeyRowIndexes<K, Tail, [V]> extends RoPair<infer IA extends RoArray, infer KCIU extends MappingEntries<number>> ? ToMapEntries<KCIU, [...M, [K, IA]]> : never : never : M;
type CartesianRightRecursive<M extends RoArray> = M extends MappingEntries<RoArray> ? Flatten<[
    ...{
        [K in keyof M]: K extends `${number}` ? InnerFlatten<Cartesian<M[K][0], CartesianRightRecursive<M[K][1]>>> : never;
    }
]> : M extends MappingEntry<RoArray> ? Cartesian<M[0], M[1]> : M;
type Shape = RoPair<IndexEs, IndexEs>;
type CartesianSet<T = unknown> = RoArray2D<T>;
type Transpose<T extends RoArray2D> = Zip<T>;
type ProcessNextKeyColmn<KC extends CartesianSet<MappableKey>, VR extends RoArray> = KC["length"] extends 0 ? VR : ExcludeIndexes<KC, 0> extends infer KCR extends CartesianSet<MappableKey> ? ToMapEntries<ElementIndexPairs<KC[0]>> extends infer KRIA extends MappingEntries<RoArray<number>> ? [
    ...{
        [K in keyof KRIA]: [
            KRIA[K][0],
            ProcessNextKeyColmn<Transpose<OnlyIndexes<Transpose<KCR>, KRIA[K][1]>>, OnlyIndexes<VR, KRIA[K][1]>>
        ];
    }
] : never : never;
type LeafValue<T = unknown> = RoPair<void, T>;
type CombineValueColumnsToLeafValues<VC extends CartesianSet> = (VC["length"] extends 1 ? VC[0] : Transpose<VC>) extends infer VCT extends RoArray ? [...{
    [K in keyof VCT]: K extends `${number}` ? LeafValue<VCT[K]> : never;
}] : never;
type SplitAndReorderKeyValueColumns<R extends CartesianSet, S extends Shape> = Transpose<R> extends infer C extends CartesianSet ? [OnlyIndexes<C, S[0]>, OnlyIndexes<C, S[1]>] : never;
type UnwrapValuesIfAllAreSingletons<M extends MappingEntries, D extends Depth[number]> = D extends 1 ? M extends MappingEntries<readonly [LeafValue]> ? [...{
    [K in keyof M]: K extends `${number}` ? [M[K][0], M[K][1][0][1]] : never;
}] : void : M extends MappingEntries<MappingEntries> ? [
    ...{
        [K in keyof M]: K extends `${number}` ? [M[K][0], UnwrapValuesIfAllAreSingletons<M[K][1], Depth[D]>] : never;
    }
] extends infer U extends MappingEntries ? U : void : never;
type MaybeUnwrapValuesIfAllAreSingletons<M extends MappingEntries, D extends Depth[number]> = UnwrapValuesIfAllAreSingletons<M, D> extends infer V extends MappingEntries ? V : M;
type TransformMapping<M extends MappingEntries, S extends Shape | void = void> = CartesianRightRecursive<M> extends infer CRR extends RoArray2D ? IsRectangular<CRR> extends true ? CRR extends readonly [RoArray, ...RoArray2D] ? S extends Shape ? SplitAndReorderKeyValueColumns<CRR, S> extends [
    infer KC extends CartesianSet<MappableKey>,
    infer VC extends CartesianSet
] ? KC["length"] extends Depth[number] ? CombineValueColumnsToLeafValues<VC> extends infer VR extends RoArray<LeafValue> ? ProcessNextKeyColmn<KC, VR> extends infer TM extends MappingEntries ? [MaybeUnwrapValuesIfAllAreSingletons<TM, KC["length"]>, KC["length"]] : never : never : never : never : CRR[0] extends readonly [...infer KC extends RoArray, unknown] ? KC["length"] extends Depth[number] ? [M, KC["length"]] : never : never : never : never : never;
type ObjectFromMappingEntries<M extends MappingEntries, D extends Depth[number]> = {
    [K in keyof M as (K extends `${number}` ? ToExtPropKey<M[K][0]> : never)]: M[K] extends infer ME extends MappingEntry ? ME[1] extends infer V ? D extends 1 ? V extends LeafValue<infer T> ? T : V extends RoArray<LeafValue> ? [...{
        [K2 in keyof V]: K2 extends `${number}` ? V[K2][1] : never;
    }] : V : V extends MappingEntries ? ObjectFromMappingEntries<V, Depth[D]> : never : never : never;
};
export type ToMappingAndDepth<M extends MappingEntries, S extends Shape | void | undefined> = TransformMapping<M, S extends undefined ? void : S> extends [
    infer TM extends MappingEntries,
    infer D extends Depth[number]
] ? [ObjectFromMappingEntries<TM, D>, D] : never;
export type ToMapping<M extends MappingEntries, S extends Shape | void | undefined = undefined> = ToMappingAndDepth<M, S>[0];
type Mapped = {
    [key: PropertyKey]: unknown | Mapped;
};
type RecursiveAccess<M, KA extends RoArray<MappableKey>> = KA extends readonly [infer Head extends MappableKey, ...infer Tail extends RoArray<MappableKey>] ? M extends Mapped ? RecursiveAccess<M[ToExtPropKey<Head>], Tail> : never : M;
type GenericMappingFunc<M extends Mapped, D extends number> = D extends 1 ? <const K1 extends FromExtPropKey<keyof M>>(...args: [K1]) => RecursiveAccess<M, [K1]> : D extends 2 ? <const K1 extends FromExtPropKey<keyof M>, const K2 extends FromExtPropKey<keyof RecursiveAccess<M, [K1]>>>(...args: [K1, K2]) => RecursiveAccess<M, [K1, K2]> : D extends 3 ? <const K1 extends FromExtPropKey<keyof M>, const K2 extends FromExtPropKey<keyof RecursiveAccess<M, [K1]>>, const K3 extends FromExtPropKey<keyof RecursiveAccess<M, [K1, K2]>>>(...args: [K1, K2, K3]) => RecursiveAccess<M, [K1, K2, K3]> : D extends 4 ? <const K1 extends FromExtPropKey<keyof M>, const K2 extends FromExtPropKey<keyof RecursiveAccess<M, [K1]>>, const K3 extends FromExtPropKey<keyof RecursiveAccess<M, [K1, K2]>>, const K4 extends FromExtPropKey<keyof RecursiveAccess<M, [K1, K2, K3]>>>(...args: [K1, K2, K3, K4]) => RecursiveAccess<M, [K1, K2, K3, K4]> : never;
type SubMap<M extends Mapped, D extends number, K extends PropertyKey> = K extends keyof M ? M[K] extends Mapped ? ConstMap<M[K], Depth[D]> : never : never;
type SubMapFunc<M extends Mapped, D extends number> = {
    readonly subMap: <const K extends FromExtPropKey<keyof M>>(key: K) => SubMap<M, D, ToExtPropKey<K>>;
};
type KeysOfObjectUnion<T extends Object> = T extends Object ? keyof T : never;
type ValsOfObjectUnion<T extends Object> = T extends Object ? T[keyof T] : never;
type WidenedParamsAndRetRec<M extends Mapped, D extends number> = D extends 1 ? [ValsOfObjectUnion<M>] : M[keyof M] extends infer SubMapUnion extends Mapped ? WidenedParamsAndRet<SubMapUnion, Depth[D]> : never;
type WidenedParamsAndRet<M extends Mapped, D extends number> = [
    Widen<FromExtPropKey<KeysOfObjectUnion<M>>>,
    ...WidenedParamsAndRetRec<M, D>
];
type HasGetFuncs<M extends Mapped, D extends number> = WidenedParamsAndRet<M, D> extends [...infer P extends RoArray<unknown>, infer R] ? {
    readonly has: (...args: P) => boolean;
    readonly get: (...args: P) => R | undefined;
} : never;
type ConstMap<M extends Mapped, D extends number> = D extends 1 ? GenericMappingFunc<M, D> & HasGetFuncs<M, D> : GenericMappingFunc<M, D> & HasGetFuncs<M, D> & SubMapFunc<M, D>;
type ToConstMap<M extends MappingEntries, S extends Shape | undefined = undefined> = ToMappingAndDepth<M, S> extends [infer TM extends Mapped, infer D extends Depth[number]] ? ConstMap<TM, D> : never;
export declare const cartesianRightRecursive: <const T extends RoArray>(arr: T) => CartesianRightRecursive<T>;
export declare function constMap<const M extends MappingEntries, const S extends Shape | undefined = undefined>(mappingEntries: M, shape?: S): ToConstMap<M, S>;
export {};
//# sourceMappingURL=mapping.d.ts.map