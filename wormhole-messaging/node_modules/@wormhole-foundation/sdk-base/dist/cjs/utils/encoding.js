"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bytes = exports.bignum = exports.b58 = exports.b64 = exports.hex = exports.stripPrefix = exports.bech32 = void 0;
const base_1 = require("@scure/base");
var base_2 = require("@scure/base");
Object.defineProperty(exports, "bech32", { enumerable: true, get: function () { return base_2.bech32; } });
/** Utility method to strip a given prefix, frequently used to remove '0x' from an address */
const stripPrefix = (prefix, str) => str.startsWith(prefix) ? str.slice(prefix.length) : str;
exports.stripPrefix = stripPrefix;
const isHexRegex = /^(?:0x)?[0-9a-fA-F]+$/;
/** Base16/Hex encoding and decoding utilities */
exports.hex = {
    /** check if a string is valid hex */
    valid: (input) => isHexRegex.test(input),
    /** decode a hex string to Uint8Array */
    decode: (input) => base_1.base16.decode((0, exports.stripPrefix)("0x", input).toUpperCase()),
    /** encode a string or Uint8Array to hex */
    encode: (input, prefix = false) => {
        input = typeof input === "string" ? exports.bytes.encode(input) : input;
        return (prefix ? "0x" : "") + base_1.base16.encode(input).toLowerCase();
    },
};
// regex string to check if the input could possibly be base64 encoded.
// WARNING: There are clear text strings that are NOT base64 encoded that will pass this check.
const isB64Regex = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
/** Base64 encoding and decoding utilities */
exports.b64 = {
    /** check if a string is valid base64 */
    valid: (input) => isB64Regex.test(input),
    /** decode a base64 string to Uint8Array */
    decode: base_1.base64.decode,
    /** encode a string or Uint8Array to base64 */
    encode: (input) => base_1.base64.encode(typeof input === "string" ? exports.bytes.encode(input) : input),
};
/** Base58 encoding and decoding utilities */
exports.b58 = {
    /** decode a base58 string to Uint8Array */
    decode: base_1.base58.decode,
    /** encode a string or Uint8Array to base58 */
    encode: (input) => base_1.base58.encode(typeof input === "string" ? exports.bytes.encode(input) : input),
};
/** BigInt encoding and decoding utilities */
exports.bignum = {
    /** decode a hex string or bytes to a bigint */
    decode: (input) => {
        if (typeof input !== "string")
            input = exports.hex.encode(input, true);
        if (input === "" || input === "0x")
            return 0n;
        return BigInt(input);
    },
    /** encode a bigint as a hex string */
    encode: (input, prefix = false) => exports.bignum.toString(input, prefix),
    /** convert a bigint to a hexstring */
    toString: (input, prefix = false) => {
        let str = input.toString(16);
        str = str.length % 2 === 1 ? (str = "0" + str) : str;
        if (prefix)
            return "0x" + str;
        return str;
    },
    /** convert a bigint or number to bytes,
     *   optionally specify length, left padded with 0s to length
     */
    toBytes: (input, length) => {
        if (typeof input === "number")
            input = exports.bignum.toBigInt(input);
        const b = exports.hex.decode(exports.bignum.toString(input));
        if (!length)
            return b;
        if (length < b.length)
            throw new Error(`Can't fit ${input} into ${length} bytes.`);
        return exports.bytes.zpad(b, length);
    },
    /** safe cast from bigint to number */
    toNumber: (input) => {
        if (input > BigInt(Number.MAX_SAFE_INTEGER))
            throw new Error(`Invalid cast: ${input} exceeds MAX_SAFE_INTEGER`);
        return Number(input);
    },
    /** safe cast from number to bigint */
    toBigInt: (input) => {
        if (input > Number.MAX_SAFE_INTEGER)
            throw new Error(`Invalid cast: ${input} exceeds MAX_SAFE_INTEGER`);
        return BigInt(input);
    }
};
/** Uint8Array encoding and decoding utilities */
exports.bytes = {
    /** encode a string to Uint8Array */
    encode: (value) => new TextEncoder().encode(value),
    /** decode a Uint8Array to string */
    decode: (value) => new TextDecoder().decode(value),
    /** compare two Uint8Arrays for equality */
    equals: (lhs, rhs) => lhs.length === rhs.length && lhs.every((v, i) => v === rhs[i]),
    /** pad a Uint8Array to a given length, optionally specifying padding direction */
    zpad: (arr, length, padStart = true) => padStart
        ? exports.bytes.concat(new Uint8Array(length - arr.length), arr)
        : exports.bytes.concat(arr, new Uint8Array(length - arr.length)),
    /** concatenate multiple Uint8Arrays into a single Uint8Array */
    concat: (...args) => {
        const length = args.reduce((acc, curr) => acc + curr.length, 0);
        const result = new Uint8Array(length);
        let offset = 0;
        args.forEach((arg) => {
            result.set(arg, offset);
            offset += arg.length;
        });
        return result;
    },
};
//# sourceMappingURL=encoding.js.map