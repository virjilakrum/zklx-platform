"use strict";
//The intent of this file is probably best explained by an example:
//
// const example = [[
//   "Mainnet", [
//     ["Ethereum", 1n],
//     ["Bsc", 56n],
//     ['Polygon', 137n],
//   ]], [
//   "Testnet", [
//     ["Ethereum", 5n],
//     ["Sepolia", 11155111n],
//   ]]
// ] as const satisfies MappingEntries;
//
//Our example variable specifies a relationship between EVM chain ids and their respective chains
//  and networks. It is a shortened way to specify the full Cartesian product:
// [
//   ["Mainnet", "Ethereum", 1n],
//   ["Mainnet", "Bsc", 56n],
//   ["Mainnet", 'Polygon', 137n],
//   ["Testnet", "Ethereum", 5n],
//   ["Testnet", "Sepolia", 11155111n],
// ]
//
//Using this full cartesian product, we can define a whole host of mappings, the obvious ones being
//  (network, chain) -> EVM chain id  and its inverse (EVM chain id) -> [network, chain].
//However, we can also define a mapping (chain) -> [list of EVM chain ids].
//
//The purpose of this file is to provide a way to define such mappings in a concise and typesafe
//  manner.
//
//It leverages `as const` specificiations such as the one of example together with a shape parameter
//  which specifies the columns of our full cartesian set which are used as the keys and values
//  respectively.
//The default shape always uses the first n-1 colums as keys and the last column as the value, e.g.
//  for our example the default shape is [[0,1],2] which maps to (network, chain) -> EVM chain id
//  while [2, [0,1]] maps to (EVM chain id) -> [network, chain], and [[0,1],[0,1,2]] maps to
//  (network, chain) -> [network, chain, EVM chain id].
//
//To actually define the type-safe default mapping for our example we write:
//
// const evmChainIdMapping = constMap(example);
//
//Which in turn can then be used to look up EVM chain ids via:
//
// const ethereumMainnetId = evmChainIdMapping("Mainnet", "Ethereum");
//
//evmChainIdMapping enforces that its first argument is of the union type "Mainnet" | "Testnet",
//  and in turn the second argument can only be one of the allowed chains conditional on the given
//  network, i.e. in our case "Ethereum" | "Bsc" | "Polygon". The type of ethereumMainnetId is
//  in turn is the bigint literal 1n.
//
//In short, it behaves exactly as a normal constant object would, but makes it easy to define
//  multiple such mappings giving a single data spec. Additionally, it natively supports bigint
//  and boolean keys which are not supported by normal objects (but which are always converted
//  to strings thus losing the original datatype).
Object.defineProperty(exports, "__esModule", { value: true });
exports.constMap = exports.cartesianRightRecursive = void 0;
const array_js_1 = require("./array.js");
function isMappableKey(key) {
    return ["string", "number", "symbol", "bigint", "boolean"].includes(typeof key);
}
const isRecursiveTuple = (arr) => arr.length === 2 && !Array.isArray(arr[0]) && Array.isArray(arr[1]);
const cartesianRightRecursive = (arr) => (arr.length === 0
    ? []
    : Array.isArray(arr[0])
        ? arr.map(([key, val]) => Array.isArray(val)
            ? (isRecursiveTuple(val) ? (0, exports.cartesianRightRecursive)(val) : val)
                .map(ele => [key, ele].flat())
            : [[key, val]]).flat()
        : isRecursiveTuple(arr)
            ? (0, exports.cartesianRightRecursive)(arr[1]).map((ele) => [arr[0], ele])
            : arr);
exports.cartesianRightRecursive = cartesianRightRecursive;
const toMapping = (mapping, shape) => {
    const crr = (0, exports.cartesianRightRecursive)(mapping);
    if (crr.length === 0)
        throw new Error("Invalid mapping: empty");
    const definedShape = (shape === undefined)
        ? [(0, array_js_1.range)(crr[0].length - 1), [crr[0].length - 1]]
        : shape.map(ind => typeof ind === "number" ? [ind] : ind);
    // store reference to leaf object to unwrap values if all leaves are singletons
    let leafObjects = [];
    let allSingletons = true;
    const buildMappingRecursively = (keyCartesianSet, values) => {
        const distinctKeys = Array.from(new Set(keyCartesianSet[0]).values());
        const keyRows = new Map(distinctKeys.map(key => [key, []]));
        for (const [i, key] of keyCartesianSet[0].entries())
            keyRows.get(key).push(i);
        // termination case
        if (keyCartesianSet.length === 1) {
            const ret = Object.fromEntries(distinctKeys.map(key => [key, keyRows.get(key).map(i => values[i].length === 1 ? values[i][0] : values[i])]));
            if (allSingletons) {
                for (const valRow of keyRows.values())
                    if (valRow.length > 1) {
                        allSingletons = false;
                        return ret;
                    }
                leafObjects.push(ret);
            }
            return ret;
        }
        const droppedKeyCol = (0, array_js_1.zip)(keyCartesianSet.slice(1));
        return Object.fromEntries(distinctKeys.map(key => {
            const rows = keyRows.get(key);
            const keyCartesianSubset = (0, array_js_1.zip)(rows.map(i => droppedKeyCol[i]));
            const valuesSubset = rows.map(i => values[i]);
            return [
                key,
                buildMappingRecursively(keyCartesianSubset, valuesSubset)
            ];
        }));
    };
    const cols = (0, array_js_1.zip)(crr);
    const getCol = (col) => {
        const colArr = cols[col];
        if (colArr === undefined)
            throw new Error(`Invalid shape: column ${col} does not exist`);
        return colArr;
    };
    const [keyCartesianSet, leafValues] = definedShape.map(indx => indx.map(col => getCol(col)));
    if (keyCartesianSet.length === 0)
        throw new Error("Invalid shape: empty key set");
    if (leafValues.length === 0)
        throw new Error("Invalid shape: empty value set");
    for (const keyCol of keyCartesianSet)
        for (const key of keyCol)
            if (!isMappableKey(key))
                throw new Error(`Invalid key: ${key} in ${keyCol}`);
    const ret = buildMappingRecursively(keyCartesianSet, (0, array_js_1.zip)(leafValues));
    if (allSingletons)
        for (const leafObj of leafObjects)
            for (const key of Object.keys(leafObj))
                leafObj[key] = leafObj[key][0];
    return ret;
};
function constMap(mappingEntries, shape) {
    const mapping = toMapping(mappingEntries, shape);
    const genericMappingFunc = ((...args) => args.reduce((subMapping, key) => subMapping ? subMapping[key.toString()] ?? undefined : undefined, mapping));
    return Object.assign(genericMappingFunc, {
        has: (...args) => genericMappingFunc(...args) !== undefined,
        get: (...args) => genericMappingFunc(...args),
        subMap: (key) => mapping[key.toString()],
    });
}
exports.constMap = constMap;
//--- find a bunch of "tests" below
// It's unclear to me how to even properly test Typescript types, seeing how there isn't even an
//  equals operation...
// So this will have to do for now...
// const sample = [
//   [
//     "Mainnet", [
//       ["Ethereum", 1n],
//       ["Bsc", 56n],
//       ['Polygon', 137n],
//     ]
//   ],
//   [
//     "Testnet", [
//       ["Ethereum", 5n],
//       ["Sepolia", 11155111n],
//     ]
//   ]
// ] as const satisfies MappingEntries;
// type Test1 = ToMapping<typeof sample>;
// type Test2 = ToMapping<typeof sample, [[0,1],2]>; //same as Test1
// type Test3 = ToMapping<typeof sample, [[0,1],[2]]>; //same as Test1
// type Test10 = ToMapping<typeof sample, [[0,1],[0,1,2]]>;
// type Test11 = ToMapping<typeof sample, [[0,1],[2,1,0]]>;
// type Element10 = Test10["Mainnet"]["Ethereum"];
// type Element11 = Test11["Mainnet"]["Ethereum"];
// type Test20 = ToMapping<typeof sample, [0,1]>;
// type Test21 = ToMapping<typeof sample, [[0],1]>; //same as Test20
// type Test22 = ToMapping<typeof sample, [0,[1]]>; //same as Test20
// type Test23 = ToMapping<typeof sample, [[0],[1]]>; //same as Test20
// type Test30 = ToMapping<typeof sample, [2,0]>;
// type Test31 = ToMapping<typeof sample, [2,[0,1]]>;
// type Test32 = ToMapping<typeof sample, [[1,0],2]>;
// type Test40 = ToMapping<typeof sample, [1,0]>;
// const test1 = constMap(sample);
// const test1Entry1 = test1("Testnet", "Sepolia"); //11155111n
// const test2 = constMap(sample, [[0,1],2]); //same as test1
// const test2Entry1 = test2("Testnet", "Sepolia"); //same as test1Entry1
// const test2Entry2 = test2.get("doesn't", "exist"); //undefined: <bigint chain ids> | undefined
// const test2Entry3 = test2.has("doesn't", "exist"); //false: boolean
// const test3SubMap = test2.subMap("Testnet");
// const test3Entry1 = test3SubMap("Sepolia"); //11155111n
// const test3Entry2 = test3SubMap("Ethereum"); //5n
// const test10 = constMap(sample, [[0,1],[0,1,2]]);
// const test10Entry1 = test10("Testnet", "Sepolia"); //["Testnet", "Sepolia", 11155111n]
// const test20 = constMap(sample, [0,1]);
// const test20Entry1 = test20("Testnet"); //["Ethereum", "Sepolia"]
// const test30 = constMap(sample, [2,0]);
// const test30Entry1 = test30(1n); //"Mainnet"
// const test31 = constMap(sample, [2,[0,1]]);
// const test31Entry1 = test31(1n); //["Mainnet", "Ethereum"]
// const test31Entry2 = test31(11155111n); //["Testnet", "Sepolia"]
// const test40 = constMap(sample, [1,0]);
// const test40Entry1 = test40("Ethereum"); //["Mainnet", "Testnet"]
// const test40Entry2 = test40("Sepolia"); //["Testnet"]
// const test40Entry3 = test40("Bsc"); //["Mainnet"]
//# sourceMappingURL=mapping.js.map