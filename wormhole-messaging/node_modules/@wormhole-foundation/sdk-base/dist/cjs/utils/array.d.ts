import type { RoArray, RoArray2D, IsUnion } from './metaprogramming.js';
export declare const range: (length: number) => number[];
export type IndexEs = number | RoArray<number>;
export type ElementIndexPairs<T extends RoArray> = [
    ...{
        [K in keyof T]: K extends `${infer N extends number}` ? [T[K], N] : never;
    }
];
export declare const elementIndexPairs: <const T extends RoArray>(arr: T) => [...{ [K in keyof T]: K extends `${infer N extends number}` ? [T[K], N] : never; }];
export type Entries<T extends RoArray> = [
    ...{
        [K in keyof T]: K extends `${infer N extends number}` ? [N, T[K]] : never;
    }
];
export declare const entries: <const T extends RoArray>(arr: T) => [...{ [K in keyof T]: K extends `${infer N extends number}` ? [N, T[K]] : never; }];
export type Flatten<T extends RoArray> = T extends readonly [infer Head, ...infer Tail extends RoArray] ? Head extends RoArray ? [...Head, ...Flatten<Tail>] : [Head, ...Flatten<Tail>] : [];
export type InnerFlatten<T extends RoArray> = [
    ...{
        [K in keyof T]: K extends `${number}` ? T[K] extends RoArray ? Flatten<T[K]> : T[K] : never;
    }
];
export type IsFlat<T extends RoArray> = T extends readonly [infer Head, ...infer Tail extends RoArray] ? Head extends RoArray ? false : IsFlat<Tail> : true;
export type Unflatten<T extends RoArray> = [
    ...{
        [K in keyof T]: K extends `${number}` ? [T[K]] : never;
    }
];
export type AllSameLength<T extends RoArray2D, L extends number | void = void> = T extends readonly [infer Head extends RoArray, ...infer Tail extends RoArray2D] ? L extends void ? AllSameLength<Tail, Head["length"]> : Head["length"] extends L ? AllSameLength<Tail, L> : false : true;
export type IsRectangular<T extends RoArray> = T extends RoArray2D ? AllSameLength<T> : IsFlat<T>;
export type Column<A extends RoArray2D, I extends number> = [
    ...{
        [K in keyof A]: K extends `${number}` ? A[K][I] : never;
    }
];
export declare const column: <const A extends RoArray2D, const I extends number>(tupArr: A, index: I) => [...{ [K in keyof A]: K extends `${number}` ? A[K][I] : never; }];
export type Zip<A extends RoArray2D> = A["length"] extends 0 ? [] : IsRectangular<A> extends true ? A[0] extends infer Head extends RoArray ? [
    ...{
        [K in keyof Head]: K extends `${number}` ? [...{
            [K2 in keyof A]: K extends keyof A[K2] ? A[K2][K] : never;
        }] : never;
    }
] : [] : never;
export declare const zip: <const Args extends RoArray2D>(arr: Args) => [Zip<Args>] extends [never] ? RoArray2D : Zip<Args>;
export type OnlyIndexes<E extends RoArray, I extends IndexEs> = IsUnion<I> extends false ? I extends number ? OnlyIndexes<E, [I]> : I extends readonly [infer Head extends number, ...infer Tail extends RoArray<number>] ? E[Head] extends undefined ? OnlyIndexes<E, Tail> : [E[Head], ...OnlyIndexes<E, Tail>] : [] : never;
type ExcludeIndexesImpl<T extends RoArray, C extends number> = T extends readonly [infer Head, ...infer Tail] ? Head extends readonly [infer I extends number, infer V] ? I extends C ? ExcludeIndexesImpl<Tail, C> : [V, ...ExcludeIndexesImpl<Tail, C>] : never : [];
export type ExcludeIndexes<T extends RoArray, C extends IndexEs> = ExcludeIndexesImpl<Entries<T>, C extends RoArray<number> ? C[number] : C>;
export type Cartesian<L, R> = L extends RoArray ? Flatten<[...{
    [K in keyof L]: K extends `${number}` ? Cartesian<L[K], R> : never;
}]> : R extends RoArray ? [...{
    [K in keyof R]: K extends `${number}` ? [L, R[K]] : never;
}] : [L, R];
export {};
//# sourceMappingURL=array.d.ts.map