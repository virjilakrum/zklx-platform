"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCanonicalToken = exports.getTokenByKey = exports.getTokensBySymbol = exports.getTokenByAddress = exports.getNative = exports.getTokenMap = void 0;
const tokens_js_1 = require("../tokens.js");
const mainnet_js_1 = require("./mainnet.js");
const testnet_js_1 = require("./testnet.js");
function getTokenMap(network, chain) {
    if (network === "Devnet")
        return;
    if (network === "Mainnet") {
        if (!mainnet_js_1.mainnetChainTokens.has(chain))
            return;
        const chainTokens = mainnet_js_1.mainnetChainTokens.get(chain);
        return Object.fromEntries(chainTokens.map(([key, token]) => [key, { ...token, chain, key }]));
    }
    if (network === "Testnet") {
        if (!testnet_js_1.testnetChainTokens.has(chain))
            return;
        const chainTokens = testnet_js_1.testnetChainTokens.get(chain);
        return Object.fromEntries(chainTokens.map(([key, token]) => [key, { ...token, chain, key }]));
    }
    throw "Unsupported network: " + network;
}
exports.getTokenMap = getTokenMap;
// The token that represents the native gas token on a given chain
// also represented as the string 'native' where applicable
function getNative(network, chain) {
    const tokenMap = getTokenMap(network, chain);
    return tokenMap ? tokens_js_1.filters.native(tokenMap) : undefined;
}
exports.getNative = getNative;
// Finds the (first) unique token key for a given chain and address
function getTokenByAddress(network, chain, address) {
    const tokenMap = getTokenMap(network, chain);
    return tokenMap ? tokens_js_1.filters.byAddress(tokenMap, address) : undefined;
}
exports.getTokenByAddress = getTokenByAddress;
function getTokensBySymbol(network, chain, symbol) {
    const tokenMap = getTokenMap(network, chain);
    return tokenMap ? tokens_js_1.filters.bySymbol(tokenMap, symbol) : undefined;
}
exports.getTokensBySymbol = getTokensBySymbol;
// Finds the (first) unique token key for a given chain and symbol
function getTokenByKey(network, chain, key) {
    const tokenMap = getTokenMap(network, chain);
    return tokenMap ? tokens_js_1.filters.byKey(tokenMap, key) : undefined;
}
exports.getTokenByKey = getTokenByKey;
// The Canonical token is the token that the input key resolves to
// from its original chain. For example, if the input key is
// USDCeth, the canonical token is USDC on ETH
function getCanonicalToken(network, chain, key) {
    const token = getTokenByKey(network, chain, key);
    if (!token)
        return;
    if (!token.original)
        return token;
    const original = getTokensBySymbol(network, token.original, token.symbol);
    if (!original)
        return;
    // return the the token with this symbol where no `original` field exists
    return original.find((t) => !t.original);
}
exports.getCanonicalToken = getCanonicalToken;
//# sourceMappingURL=index.js.map