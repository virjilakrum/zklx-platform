"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.toCircleChain = exports.toCircleChainId = exports.asCircleChainId = exports.assertCircleChain = exports.assertCircleChainId = exports.isCircleSupported = exports.isCircleChainId = exports.isCircleChain = exports.circleChainMap = exports.circleNetworks = exports.circleChainIdToChain = exports.circleChainId = exports.usdcContract = exports.circleAPI = void 0;
const index_js_1 = require("./../utils/index.js");
const circleAPIs = [
    ["Mainnet", "https://iris-api.circle.com/v1/attestations"],
    ["Testnet", "https://iris-api-sandbox.circle.com/v1/attestations"],
];
exports.circleAPI = (0, index_js_1.constMap)(circleAPIs);
// prettier-ignore
const usdcContracts = [[
        "Mainnet", [
            ["Ethereum", "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"],
            ["Avalanche", "0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e"],
            ["Optimism", "0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85"],
            ["Arbitrum", "0xaf88d065e77c8cC2239327C5EDb3A432268e5831"],
            ["Solana", "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"],
            ["Base", "0x833589fcd6edb6e08f4c7c32d4f71b54bda02913"],
            ["Polygon", "0x3c499c542cef5e3811e1192ce70d8cc03d5c3359"],
        ]
    ], [
        "Testnet", [
            ["Sepolia", "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238"],
            ["Avalanche", "0x5425890298aed601595a70AB815c96711a31Bc65"],
            ["OptimismSepolia", "0x5fd84259d66Cd46123540766Be93DFE6D43130D7"],
            ["ArbitrumSepolia", "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d"],
            ["Solana", "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU"],
            ["BaseSepolia", "0x036CbD53842c5426634e7929541eC2318f3dCF7e"],
            ["Polygon", "0x9999f7fea5938fd3b1e26a12c3f2fb024e194f97"],
        ]
    ],
];
exports.usdcContract = (0, index_js_1.constMap)(usdcContracts);
// prettier-ignore
// https://developers.circle.com/stablecoin/docs/cctp-technical-reference#domain-list
const circleDomains = [[
        "Mainnet", [
            ["Ethereum", 0],
            ["Avalanche", 1],
            ["Optimism", 2],
            ["Arbitrum", 3],
            ["Solana", 5],
            ["Base", 6],
            ["Polygon", 7],
        ]
    ], [
        "Testnet", [
            ["Sepolia", 0],
            ["Avalanche", 1],
            ["OptimismSepolia", 2],
            ["ArbitrumSepolia", 3],
            ["Solana", 5],
            ["BaseSepolia", 6],
            ["Polygon", 7],
        ]
    ],
];
exports.circleChainId = (0, index_js_1.constMap)(circleDomains, [[0, 1], 2]);
exports.circleChainIdToChain = (0, index_js_1.constMap)(circleDomains, [[0, 2], 1]);
_a = (0, index_js_1.zip)(circleDomains), exports.circleNetworks = _a[0], exports.circleChainMap = _a[1];
const isCircleChain = (network, chain) => exports.circleChainId.has(network, chain);
exports.isCircleChain = isCircleChain;
const isCircleChainId = (network, chainId) => exports.circleChainIdToChain.has(network, chainId);
exports.isCircleChainId = isCircleChainId;
const isCircleSupported = (network, chain) => exports.usdcContract.has(network, chain);
exports.isCircleSupported = isCircleSupported;
function assertCircleChainId(network, chainId) {
    if (!(0, exports.isCircleChainId)(network, chainId))
        throw Error(`Unknown Circle chain id: ${chainId}`);
}
exports.assertCircleChainId = assertCircleChainId;
function assertCircleChain(network, chain) {
    if (!(0, exports.isCircleChain)(network, chain))
        throw Error(`Unknown Circle chain: ${chain}`);
}
exports.assertCircleChain = assertCircleChain;
//safe assertion that allows chaining
const asCircleChainId = (network, chainId) => {
    assertCircleChainId(network, chainId);
    return chainId;
};
exports.asCircleChainId = asCircleChainId;
const toCircleChainId = (network, chain) => {
    switch (typeof chain) {
        case "string":
            if ((0, exports.isCircleChain)(network, chain))
                return exports.circleChainId.get(network, chain);
            break;
        case "number":
            if ((0, exports.isCircleChainId)(network, chain))
                return chain;
            break;
        case "bigint":
            const ci = Number(chain);
            if ((0, exports.isCircleChainId)(network, ci))
                return ci;
            break;
    }
    throw Error(`Cannot convert to ChainId: ${chain}`);
};
exports.toCircleChainId = toCircleChainId;
const toCircleChain = (network, chain) => {
    switch (typeof chain) {
        case "string":
            if ((0, exports.isCircleChain)(network, chain))
                return chain;
            break;
        case "number":
            if ((0, exports.isCircleChainId)(network, chain))
                return (0, exports.circleChainIdToChain)(network, chain);
            break;
        case "bigint":
            const cid = Number(chain);
            if ((0, exports.isCircleChainId)(network, cid))
                return (0, exports.circleChainIdToChain)(network, cid);
            break;
    }
    throw Error(`Cannot convert to Chain: ${chain}`);
};
exports.toCircleChain = toCircleChain;
//# sourceMappingURL=circle.js.map