import type { Chain } from "./chains.js";
export declare const platforms: ["Evm", "Solana", "Cosmwasm", "Btc", "Algorand", "Sui", "Aptos", "Near"];
export type Platform = (typeof platforms)[number];
export declare const platformToChains: (<const K1 extends "Solana" | "Algorand" | "Near" | "Sui" | "Aptos" | "Btc" | "Evm" | "Cosmwasm">(args_0: K1) => {
    readonly Evm: readonly ["Acala", "Arbitrum", "Aurora", "Avalanche", "Base", "Bsc", "Celo", "Ethereum", "Fantom", "Gnosis", "Karura", "Klaytn", "Moonbeam", "Neon", "Oasis", "Optimism", "Polygon", "Rootstock", "Sepolia", "ArbitrumSepolia", "BaseSepolia", "OptimismSepolia", "Holesky", "PolygonSepolia", "Mantle", "Scroll", "Blast", "Xlayer", "Linea", "Berachain", "Seievm"];
    readonly Solana: readonly ["Solana", "Pythnet"];
    readonly Cosmwasm: readonly ["Cosmoshub", "Evmos", "Injective", "Kujira", "Osmosis", "Sei", "Terra", "Terra2", "Wormchain", "Xpla", "Dymension", "Neutron", "Stargaze", "Celestia", "Seda", "Provenance"];
    readonly Btc: readonly ["Btc"];
    readonly Algorand: readonly ["Algorand"];
    readonly Sui: readonly ["Sui"];
    readonly Aptos: readonly ["Aptos"];
    readonly Near: readonly ["Near"];
}[K1 extends bigint ? `bigint(${K1})` : K1 extends boolean ? `boolean(${K1})` : K1]) & {
    readonly has: (args_0: string) => boolean;
    readonly get: (args_0: string) => readonly ["Acala", "Arbitrum", "Aurora", "Avalanche", "Base", "Bsc", "Celo", "Ethereum", "Fantom", "Gnosis", "Karura", "Klaytn", "Moonbeam", "Neon", "Oasis", "Optimism", "Polygon", "Rootstock", "Sepolia", "ArbitrumSepolia", "BaseSepolia", "OptimismSepolia", "Holesky", "PolygonSepolia", "Mantle", "Scroll", "Blast", "Xlayer", "Linea", "Berachain", "Seievm"] | readonly ["Solana", "Pythnet"] | readonly ["Cosmoshub", "Evmos", "Injective", "Kujira", "Osmosis", "Sei", "Terra", "Terra2", "Wormchain", "Xpla", "Dymension", "Neutron", "Stargaze", "Celestia", "Seda", "Provenance"] | readonly ["Btc"] | readonly ["Algorand"] | readonly ["Sui"] | readonly ["Aptos"] | readonly ["Near"] | undefined;
};
export declare const chainToPlatform: (<const K1 extends "Solana" | "Ethereum" | "Terra" | "Bsc" | "Polygon" | "Avalanche" | "Oasis" | "Algorand" | "Aurora" | "Fantom" | "Karura" | "Acala" | "Klaytn" | "Celo" | "Near" | "Moonbeam" | "Neon" | "Terra2" | "Injective" | "Osmosis" | "Sui" | "Aptos" | "Arbitrum" | "Optimism" | "Gnosis" | "Pythnet" | "Xpla" | "Btc" | "Base" | "Sei" | "Rootstock" | "Scroll" | "Mantle" | "Blast" | "Xlayer" | "Linea" | "Berachain" | "Seievm" | "Wormchain" | "Cosmoshub" | "Evmos" | "Kujira" | "Neutron" | "Celestia" | "Stargaze" | "Seda" | "Dymension" | "Provenance" | "Sepolia" | "ArbitrumSepolia" | "BaseSepolia" | "OptimismSepolia" | "Holesky" | "PolygonSepolia">(args_0: K1) => {
    Acala: "Evm";
    Arbitrum: "Evm";
    Aurora: "Evm";
    Avalanche: "Evm";
    Base: "Evm";
    Bsc: "Evm";
    Celo: "Evm";
    Ethereum: "Evm";
    Fantom: "Evm";
    Gnosis: "Evm";
    Karura: "Evm";
    Klaytn: "Evm";
    Moonbeam: "Evm";
    Neon: "Evm";
    Oasis: "Evm";
    Optimism: "Evm";
    Polygon: "Evm";
    Rootstock: "Evm";
    Sepolia: "Evm";
    ArbitrumSepolia: "Evm";
    BaseSepolia: "Evm";
    OptimismSepolia: "Evm";
    Holesky: "Evm";
    PolygonSepolia: "Evm";
    Mantle: "Evm";
    Scroll: "Evm";
    Blast: "Evm";
    Xlayer: "Evm";
    Linea: "Evm";
    Berachain: "Evm";
    Seievm: "Evm";
    Solana: "Solana";
    Pythnet: "Solana";
    Cosmoshub: "Cosmwasm";
    Evmos: "Cosmwasm";
    Injective: "Cosmwasm";
    Kujira: "Cosmwasm";
    Osmosis: "Cosmwasm";
    Sei: "Cosmwasm";
    Terra: "Cosmwasm";
    Terra2: "Cosmwasm";
    Wormchain: "Cosmwasm";
    Xpla: "Cosmwasm";
    Dymension: "Cosmwasm";
    Neutron: "Cosmwasm";
    Stargaze: "Cosmwasm";
    Celestia: "Cosmwasm";
    Seda: "Cosmwasm";
    Provenance: "Cosmwasm";
    Btc: "Btc";
    Algorand: "Algorand";
    Sui: "Sui";
    Aptos: "Aptos";
    Near: "Near";
}[K1 extends bigint ? `bigint(${K1})` : K1 extends boolean ? `boolean(${K1})` : K1]) & {
    readonly has: (args_0: string) => boolean;
    readonly get: (args_0: string) => "Solana" | "Algorand" | "Near" | "Sui" | "Aptos" | "Btc" | "Evm" | "Cosmwasm" | undefined;
};
export declare const isPlatform: (platform: string) => platform is "Solana" | "Algorand" | "Near" | "Sui" | "Aptos" | "Btc" | "Evm" | "Cosmwasm";
export type PlatformToChains<P extends Platform> = ReturnType<typeof platformToChains<P>>[number];
export type ChainToPlatform<C extends Chain> = ReturnType<typeof chainToPlatform<C>>;
declare const platformAddressFormatEntries: readonly [readonly ["Evm", "hex"], readonly ["Solana", "base58"], readonly ["Cosmwasm", "bech32"], readonly ["Btc", "bech32"], readonly ["Algorand", "algorandAppId"], readonly ["Sui", "hex"], readonly ["Aptos", "hex"], readonly ["Near", "sha256"]];
export declare const platformToAddressFormat: (<const K1 extends "Solana" | "Algorand" | "Near" | "Sui" | "Aptos" | "Btc" | "Evm" | "Cosmwasm">(args_0: K1) => {
    readonly Evm: "hex";
    readonly Solana: "base58";
    readonly Cosmwasm: "bech32";
    readonly Btc: "bech32";
    readonly Algorand: "algorandAppId";
    readonly Sui: "hex";
    readonly Aptos: "hex";
    readonly Near: "sha256";
}[K1 extends bigint ? `bigint(${K1})` : K1 extends boolean ? `boolean(${K1})` : K1]) & {
    readonly has: (args_0: string) => boolean;
    readonly get: (args_0: string) => "hex" | "base58" | "bech32" | "algorandAppId" | "sha256" | undefined;
};
export type PlatformAddressFormat = (typeof platformAddressFormatEntries)[number][1];
export {};
//# sourceMappingURL=platforms.d.ts.map