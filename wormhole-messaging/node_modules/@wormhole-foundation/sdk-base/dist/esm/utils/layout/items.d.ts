import type { Endianness, NumberSize, NumSizeToPrimitive, LayoutToType } from './layout.js';
import type { CustomizableBytes, CustomizableBytesReturn } from './utils.js';
export declare function enumItem<const E extends readonly (readonly [string, number])[]>(entries: E, opts?: {
    size?: NumberSize;
    endianness?: Endianness;
}): {
    readonly binary: "uint";
    readonly size: NumberSize;
    readonly endianness: Endianness;
    readonly custom: {
        readonly to: (encoded: number) => E[number][0];
        readonly from: (name: E[number][0]) => number;
    };
};
declare const baseOptionItem: <const T extends CustomizableBytes>(someType: T) => {
    readonly binary: "switch";
    readonly idSize: 1;
    readonly idTag: "isSome";
    readonly layouts: readonly [readonly [readonly [0, false], readonly []], readonly [readonly [1, true], readonly [CustomizableBytesReturn<{
        readonly name: "value";
    }, T>]]];
};
type BaseOptionItem<T extends CustomizableBytes> = LayoutToType<ReturnType<typeof baseOptionItem<T>>>;
type BaseOptionValue<T extends CustomizableBytes> = LayoutToType<CustomizableBytesReturn<{}, T>> | undefined;
export declare function optionItem<const T extends CustomizableBytes>(optVal: T): {
    readonly binary: "bytes";
    readonly layout: {
        readonly binary: "switch";
        readonly idSize: 1;
        readonly idTag: "isSome";
        readonly layouts: readonly [readonly [readonly [0, false], readonly []], readonly [readonly [1, true], readonly [CustomizableBytesReturn<{
            readonly name: "value";
        }, T>]]];
    };
    readonly custom: {
        to: (obj: BaseOptionItem<T>) => BaseOptionValue<T>;
        from: (value: BaseOptionValue<T>) => BaseOptionItem<T>;
    };
};
export type Bitset<B extends readonly (string | undefined)[]> = {
    [K in B[number] as K extends "" | undefined ? never : K]: boolean;
};
type ByteSize = [
    never,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6
];
type BitsizeToBytesize<N extends number> = N extends keyof ByteSize ? ByteSize[N] : number;
export type BitsetItem<B extends readonly (string | undefined)[], S extends number = BitsizeToBytesize<B["length"]>> = {
    binary: "uint";
    size: S;
    custom: {
        to: (encoded: NumSizeToPrimitive<S>) => Bitset<B>;
        from: (obj: Bitset<B>) => NumSizeToPrimitive<S>;
    };
};
export declare function bitsetItem<const B extends readonly (string | undefined)[], const S extends number = BitsizeToBytesize<B["length"]>>(bitnames: B, size?: S): BitsetItem<B, S>;
export {};
//# sourceMappingURL=items.d.ts.map