import { binaryLiterals } from "./layout.js";
export const isNumType = (x) => typeof x === "number" || typeof x === "bigint";
export const isBytesType = (x) => x instanceof Uint8Array;
export const isPrimitiveType = (x) => isNumType(x) || isBytesType(x);
export const isLayoutItem = (x) => binaryLiterals.includes(x?.binary);
export const isLayout = (x) => isLayoutItem(x) || Array.isArray(x) && x.every(isLayoutItem);
const isFixedNumberConversion = (custom) => typeof custom?.from === "number";
const isFixedBigintConversion = (custom) => typeof custom?.from === "bigint";
export const isFixedUintConversion = (custom) => isFixedNumberConversion(custom) || isFixedBigintConversion(custom);
export const isFixedBytesConversion = (custom) => isBytesType(custom?.from);
export const isFixedPrimitiveConversion = (custom) => isFixedUintConversion(custom) || isFixedBytesConversion(custom);
export const customizableBytes = (base, spec) => ({
    ...base,
    binary: "bytes",
    ...(() => {
        if (spec === undefined)
            return {};
        if (isLayout(spec))
            return { layout: spec };
        if (spec instanceof Uint8Array || isFixedBytesConversion(spec) || !Array.isArray(spec))
            return { custom: spec };
        return { layout: spec[0], custom: spec[1] };
    })()
});
export const checkSize = (layoutSize, dataSize) => {
    if (layoutSize !== dataSize)
        throw new Error(`size mismatch: layout size: ${layoutSize}, data size: ${dataSize}`);
    return dataSize;
};
export const checkItemSize = (item, dataSize) => ("size" in item && item.size !== undefined) ? checkSize(item.size, dataSize) : dataSize;
export const checkNumEquals = (custom, data) => {
    if (custom != data)
        throw new Error(`value mismatch: (constant) layout value: ${custom}, data value: ${data}`);
};
export const checkBytesTypeEqual = (custom, data, opts) => {
    const toSlice = (bytes, slice) => slice === undefined
        ? [0, bytes.length]
        : Array.isArray(slice)
            ? slice
            : [slice, bytes.length];
    const [customStart, customEnd] = toSlice(custom, opts?.customSlice);
    const [dataStart, dataEnd] = toSlice(data, opts?.dataSlize);
    const length = customEnd - customStart;
    checkSize(length, dataEnd - dataStart);
    for (let i = 0; i < custom.length; ++i)
        if (custom[i + customStart] !== data[i + dataStart])
            throw new Error(`binary data mismatch: ` +
                `layout value: ${custom}, offset: ${customStart}, data value: ${data}, offset: ${dataStart}`);
};
export function findIdLayoutPair(item, data) {
    const id = data[item.idTag ?? "id"];
    return item.layouts.find(([idOrConversionId]) => (Array.isArray(idOrConversionId) ? idOrConversionId[1] : idOrConversionId) == id);
}
//# sourceMappingURL=utils.js.map