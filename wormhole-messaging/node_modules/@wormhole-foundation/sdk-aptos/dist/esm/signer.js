import { encoding } from "@wormhole-foundation/sdk-connect";
import { AptosAccount } from "aptos";
import { AptosPlatform } from "./platform.js";
// returns a SignOnlySigner for the Aptos platform
export async function getAptosSigner(rpc, privateKey) {
    const [_, chain] = await AptosPlatform.chainFromRpc(rpc);
    return new AptosSigner(chain, new AptosAccount(encoding.hex.decode(privateKey)), rpc);
}
export class AptosSigner {
    _chain;
    _account;
    _rpc;
    _debug;
    constructor(_chain, _account, _rpc, _debug) {
        this._chain = _chain;
        this._account = _account;
        this._rpc = _rpc;
        this._debug = _debug;
    }
    chain() {
        return this._chain;
    }
    address() {
        return this._account.address().hex();
    }
    async signAndSend(tx) {
        const txhashes = [];
        for (const txn of tx) {
            const { description, transaction } = txn;
            if (this._debug)
                console.log(`Signing: ${description} for ${this.address()}`);
            // overwriting `max_gas_amount` and `gas_unit_price` defaults
            // rest of defaults are defined here: https://aptos-labs.github.io/ts-sdk-doc/classes/AptosClient.html#generateTransaction
            const customOpts = {
                gas_unit_price: "100",
                max_gas_amount: "30000",
                expiration_timestamp_secs: (BigInt(Date.now() + 8 * 60 * 60 * 1000) / 1000n).toString(),
            };
            const tx = await this._rpc.generateTransaction(this._account.address(), transaction, customOpts);
            const { hash } = await this._simSignSend(tx);
            txhashes.push(hash);
        }
        return txhashes;
    }
    async _simSignSend(rawTx) {
        // simulate transaction
        await this._rpc.simulateTransaction(this._account, rawTx).then((sims) => sims.forEach((tx) => {
            if (!tx.success) {
                throw new Error(`Transaction failed: ${tx.vm_status}\n${JSON.stringify(tx, null, 2)}`);
            }
        }));
        // sign & submit transaction
        return this._rpc
            .signTransaction(this._account, rawTx)
            .then((signedTx) => this._rpc.submitTransaction(signedTx))
            .then((pendingTx) => this._rpc.waitForTransactionWithResult(pendingTx.hash));
    }
}
//# sourceMappingURL=signer.js.map