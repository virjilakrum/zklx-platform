"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AptosAddress = exports.ensureFullAptosAddress = exports.AptosZeroAddress = void 0;
const sdk_connect_1 = require("@wormhole-foundation/sdk-connect");
const constants_js_1 = require("./constants.js");
const types_js_1 = require("./types.js");
exports.AptosZeroAddress = "0x";
// Sometimes Aptos addresses will be trimmed of leading 0s
// add them back if necessary
function ensureFullAptosAddress(address) {
    if (address.length % 2 !== 0 || address.length < 66) {
        address = address.startsWith("0x") ? address.slice(2) : address;
        return "0x" + address.padStart(64, "0");
    }
    return address;
}
exports.ensureFullAptosAddress = ensureFullAptosAddress;
class AptosAddress {
    static byteSize = 32;
    static platform = types_js_1._platform;
    type = "Native";
    // Full 32 bytes of Address
    address;
    // Optional module and contract name
    module;
    constructor(address) {
        if (AptosAddress.instanceof(address)) {
            this.address = address.address;
            this.module = address.module;
        }
        else if (sdk_connect_1.UniversalAddress.instanceof(address)) {
            this.address = address.toUint8Array();
        }
        else if (typeof address === "string") {
            // If we've got an address of the form `0x1234...::module::...` then
            // stuff anything after the first `::` into the module field
            // and continue processing the address
            if ((0, types_js_1.isValidAptosType)(address)) {
                const chunks = address.split(constants_js_1.APTOS_SEPARATOR);
                this.module = chunks.slice(1).join(constants_js_1.APTOS_SEPARATOR);
                address = chunks[0];
            }
            address = ensureFullAptosAddress(address);
            if (!sdk_connect_1.encoding.hex.valid(address))
                throw new Error("Invalid Aptos address: " + address);
            this.address = sdk_connect_1.encoding.hex.decode(address);
        }
        else {
            this.address = address;
        }
    }
    unwrap() {
        const addr = sdk_connect_1.encoding.hex.encode(this.address).replace(/^0+/, "");
        const module = this.module ? constants_js_1.APTOS_SEPARATOR + this.module : "";
        return `0x${addr}${module}`;
    }
    toString() {
        return this.unwrap();
    }
    toNative() {
        return this;
    }
    toUint8Array() {
        return this.address;
    }
    toUniversalAddress() {
        return new sdk_connect_1.UniversalAddress(this.toUint8Array());
    }
    static instanceof(address) {
        return address.constructor.platform === AptosAddress.platform;
    }
    equals(other) {
        if (AptosAddress.instanceof(other)) {
            return other.unwrap() === this.unwrap();
        }
        else {
            return this.toUniversalAddress().equals(other);
        }
    }
}
exports.AptosAddress = AptosAddress;
(0, sdk_connect_1.registerNative)(types_js_1._platform, AptosAddress);
//# sourceMappingURL=address.js.map