"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmPorticoBridge = void 0;
const sdk_connect_1 = require("@wormhole-foundation/sdk-connect");
const sdk_evm_1 = require("@wormhole-foundation/sdk-evm");
const ethers_1 = require("ethers");
const abis_js_1 = require("./abis.js");
const api_js_1 = require("./api.js");
const consts_js_1 = require("./consts.js");
const tokens_1 = require("@wormhole-foundation/sdk-connect/tokens");
const sdk_evm_core_1 = require("@wormhole-foundation/sdk-evm-core");
require("@wormhole-foundation/sdk-evm-tokenbridge");
class EvmPorticoBridge {
    network;
    chain;
    provider;
    contracts;
    chainId;
    porticoAddress;
    uniswapAddress;
    porticoContract;
    uniswapContract;
    core;
    constructor(network, chain, provider, contracts) {
        this.network = network;
        this.chain = chain;
        this.provider = provider;
        this.contracts = contracts;
        if (!contracts.portico)
            throw new Error('Unsupported chain, no contract addresses for: ' + chain);
        this.core = new sdk_evm_core_1.EvmWormholeCore(network, chain, provider, contracts);
        const { portico: porticoAddress, uniswapQuoterV2: uniswapAddress } = contracts.portico;
        this.porticoAddress = porticoAddress;
        this.uniswapAddress = uniswapAddress;
        this.chainId = sdk_connect_1.nativeChainIds.networkChainToNativeChainId.get(network, chain);
        this.porticoContract = new ethers_1.ethers.Contract(this.porticoAddress, abis_js_1.porticoAbi.fragments, this.provider);
        this.uniswapContract = new ethers_1.ethers.Contract(this.uniswapAddress, abis_js_1.uniswapQuoterV2Abi.fragments, this.provider);
    }
    static async fromRpc(provider, config) {
        const [network, chain] = await sdk_evm_1.EvmPlatform.chainFromRpc(provider);
        const conf = config[chain];
        if (conf.network !== network)
            throw new Error(`Network mismatch: ${conf.network} != ${network}`);
        return new EvmPorticoBridge(network, chain, provider, conf.contracts);
    }
    async *transfer(sender, receiver, token, amount, destToken, quote) {
        const { minAmountStart, minAmountFinish } = quote.swapAmounts;
        if (minAmountStart === 0n)
            throw new Error('Invalid min swap amount');
        if (minAmountFinish === 0n)
            throw new Error('Invalid min swap amount');
        const senderAddress = new sdk_evm_1.EvmAddress(sender).toString();
        const [isStartTokenNative, startToken] = (0, sdk_connect_1.resolveWrappedToken)(this.network, this.chain, token);
        const [isFinalTokenNative, finalToken] = (0, sdk_connect_1.resolveWrappedToken)(this.network, receiver.chain, destToken);
        const startTokenAddress = (0, sdk_connect_1.canonicalAddress)(startToken);
        const cannonTokenAddress = (0, sdk_connect_1.canonicalAddress)(this.getTransferrableToken(startTokenAddress));
        const receiverAddress = (0, sdk_connect_1.canonicalAddress)(receiver);
        const finalTokenAddress = (0, sdk_connect_1.canonicalAddress)(finalToken);
        const destinationPorticoAddress = sdk_connect_1.contracts.portico.get(this.network, receiver.chain).portico;
        const nonce = new Date().valueOf() % 2 ** 4;
        const flags = sdk_connect_1.PorticoBridge.serializeFlagSet({
            flags: {
                shouldWrapNative: isStartTokenNative,
                shouldUnwrapNative: isFinalTokenNative,
            },
            recipientChain: (0, sdk_connect_1.toChainId)(receiver.chain),
            bridgeNonce: nonce,
            feeTierStart: consts_js_1.FEE_TIER,
            feeTierFinish: consts_js_1.FEE_TIER,
            padding: new Uint8Array(19),
        });
        const transactionData = abis_js_1.porticoAbi.encodeFunctionData('start', [
            [
                flags,
                startTokenAddress.toLowerCase(),
                cannonTokenAddress,
                finalTokenAddress.toLowerCase(),
                receiverAddress,
                destinationPorticoAddress,
                amount.toString(),
                minAmountStart.toString(),
                minAmountFinish.toString(),
                quote.relayerFee.toString(),
            ],
        ]);
        // Approve the token if necessary
        if (!isStartTokenNative)
            yield* this.approve(startTokenAddress, senderAddress, amount, this.porticoAddress);
        const messageFee = await this.core.getMessageFee();
        const tx = {
            to: this.porticoAddress,
            data: transactionData,
            value: messageFee + (isStartTokenNative ? amount : 0n),
        };
        yield this.createUnsignedTransaction((0, sdk_evm_1.addFrom)(tx, senderAddress), 'PorticoBridge.Transfer');
    }
    async *redeem(sender, vaa) {
        const txReq = await this.porticoContract
            .getFunction('receiveMessageAndSwap')
            .populateTransaction((0, sdk_connect_1.serialize)(vaa));
        const address = new sdk_evm_1.EvmAddress(sender).toString();
        yield this.createUnsignedTransaction((0, sdk_evm_1.addFrom)(txReq, address), 'PorticoBridge.Redeem');
    }
    async quoteSwap(input, output, amount) {
        const [, inputTokenId] = (0, sdk_connect_1.resolveWrappedToken)(this.network, this.chain, input);
        const [, outputTokenId] = (0, sdk_connect_1.resolveWrappedToken)(this.network, this.chain, output);
        const inputAddress = (0, sdk_connect_1.canonicalAddress)(inputTokenId);
        const outputAddress = (0, sdk_connect_1.canonicalAddress)(outputTokenId);
        if ((0, sdk_connect_1.isEqualCaseInsensitive)(inputAddress, outputAddress))
            return amount;
        const result = await this.uniswapContract
            .getFunction('quoteExactInputSingle')
            .staticCall([inputAddress, outputAddress, amount, consts_js_1.FEE_TIER, 0]);
        return result[0];
    }
    async quoteRelay(startToken, endToken) {
        return await api_js_1.PorticoApi.quoteRelayer(this.chain, startToken, endToken);
    }
    // For a given token, return the corresponding
    // Wormhole wrapped token that originated on Ethereum
    getTransferrableToken(address) {
        if (this.chain === 'Ethereum')
            return sdk_connect_1.Wormhole.tokenId('Ethereum', address);
        // get the nativeTokenDetails
        const nToken = (0, tokens_1.getTokenByAddress)(this.network, this.chain, address);
        if (!nToken)
            throw new Error('Unsupported source token: ' + address);
        const xToken = (0, tokens_1.getTokensBySymbol)(this.network, this.chain, nToken.symbol)?.find((orig) => {
            return orig.original === 'Ethereum';
        });
        if (!xToken)
            throw new Error(`Unsupported symbol for chain ${nToken.symbol}: ${this.chain} `);
        return sdk_connect_1.Wormhole.tokenId(xToken.chain, xToken.address);
    }
    async *approve(token, senderAddr, amount, contract) {
        const tokenContract = sdk_evm_1.EvmPlatform.getTokenImplementation(this.provider, token);
        const allowance = await tokenContract.allowance(senderAddr, contract);
        if (allowance < amount) {
            const txReq = await tokenContract.approve.populateTransaction(contract, amount);
            yield this.createUnsignedTransaction((0, sdk_evm_1.addFrom)(txReq, senderAddr), 'PorticoBridge.Approve');
        }
    }
    createUnsignedTransaction(txReq, description) {
        return new sdk_evm_1.EvmUnsignedTransaction((0, sdk_evm_1.addChainId)(txReq, this.chainId), this.network, this.chain, description, false);
    }
}
exports.EvmPorticoBridge = EvmPorticoBridge;
//# sourceMappingURL=bridge.js.map