"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SuiPlatform = void 0;
const sdk_connect_1 = require("@wormhole-foundation/sdk-connect");
const client_1 = require("@mysten/sui.js/client");
const address_js_1 = require("./address.js");
const chain_js_1 = require("./chain.js");
const constants_js_1 = require("./constants.js");
const types_js_1 = require("./types.js");
const utils_js_1 = require("./utils.js");
/**
 * @category Sui
 */
class SuiPlatform extends sdk_connect_1.PlatformContext {
    static _platform = types_js_1._platform;
    constructor(network, _config) {
        super(network, _config ?? (0, sdk_connect_1.networkPlatformConfigs)(network, SuiPlatform._platform));
    }
    getRpc(chain) {
        if (chain in this.config)
            return new client_1.SuiClient({ url: this.config[chain].rpc });
        throw new Error("No configuration available for chain: " + chain);
    }
    getChain(chain) {
        if (chain in this.config)
            return new chain_js_1.SuiChain(chain, this);
        throw new Error("No configuration available for chain: " + chain);
    }
    static nativeTokenId(network, chain) {
        if (!SuiPlatform.isSupportedChain(chain))
            throw new Error(`invalid chain for ${types_js_1._platform}: ${chain}`);
        return sdk_connect_1.Wormhole.tokenId(chain, constants_js_1.SUI_COIN);
    }
    static isNativeTokenId(network, chain, tokenId) {
        if (!SuiPlatform.isSupportedChain(chain))
            return false;
        if (tokenId.chain !== chain)
            return false;
        const native = this.nativeTokenId(network, chain);
        return native === tokenId;
    }
    static isSupportedChain(chain) {
        const platform = (0, sdk_connect_1.chainToPlatform)(chain);
        return platform === SuiPlatform._platform;
    }
    static async getDecimals(chain, rpc, token) {
        if ((0, sdk_connect_1.isNative)(token))
            return sdk_connect_1.decimals.nativeDecimals(SuiPlatform._platform);
        const parsedAddress = new address_js_1.SuiAddress(token);
        try {
            const fields = await (0, utils_js_1.getObjectFields)(rpc, parsedAddress.toString());
            if (fields && "decimals" in fields)
                return fields["decimals"];
        }
        catch { }
        const metadata = await rpc.getCoinMetadata({ coinType: parsedAddress.getCoinType() });
        if (metadata === null)
            throw new Error(`Can't fetch decimals for token ${parsedAddress.toString()}`);
        return metadata.decimals;
    }
    static async getCoins(connection, account, coinType) {
        let coins = [];
        let cursor = null;
        const owner = new address_js_1.SuiAddress(account).toString();
        do {
            const result = await connection.getCoins({
                owner,
                coinType,
                cursor,
            });
            coins = [...coins, ...result.data];
            cursor = result.hasNextPage ? result.nextCursor : null;
        } while (cursor);
        return coins;
    }
    static async getBalance(chain, rpc, walletAddr, token) {
        if ((0, sdk_connect_1.isNative)(token)) {
            const { totalBalance } = await rpc.getBalance({
                owner: walletAddr,
            });
            return BigInt(totalBalance);
        }
        const { totalBalance } = await rpc.getBalance({
            owner: walletAddr,
            coinType: token.toString(),
        });
        return BigInt(totalBalance);
    }
    static async getBalances(chain, rpc, walletAddr, tokens) {
        const balancesArr = await Promise.all(tokens.map(async (token) => {
            const balance = await this.getBalance(chain, rpc, walletAddr, token);
            const address = (0, sdk_connect_1.isNative)(token) ? "native" : new address_js_1.SuiAddress(token).toString();
            return { [address]: balance };
        }));
        return balancesArr.reduce((obj, item) => Object.assign(obj, item), {});
    }
    static async sendWait(chain, rpc, stxns) {
        const txhashes = [];
        for (const stxn of stxns) {
            const pendingTx = await rpc.executeTransactionBlock(stxn);
            await rpc.waitForTransactionBlock({ digest: pendingTx.digest });
            txhashes.push(pendingTx.digest);
        }
        return txhashes;
    }
    static async getLatestBlock(rpc) {
        return Number(await rpc.getLatestCheckpointSequenceNumber());
    }
    static async getLatestFinalizedBlock(rpc) {
        return this.getLatestBlock(rpc);
    }
    static chainFromChainId(chainId) {
        const networkChainPair = sdk_connect_1.nativeChainIds.platformNativeChainIdToNetworkChain(SuiPlatform._platform, chainId);
        if (networkChainPair === undefined)
            throw new Error(`Unknown native chain id ${chainId}`);
        const [network, chain] = networkChainPair;
        return [network, chain];
    }
    static async chainFromRpc(rpc) {
        const result = await rpc.call("sui_getChainIdentifier", []);
        return this.chainFromChainId(result);
    }
}
exports.SuiPlatform = SuiPlatform;
//# sourceMappingURL=platform.js.map