"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SuiAddress = exports.getTableKeyType = exports.getPackageIdFromType = exports.getCoinTypeFromPackageId = exports.normalizeSuiType = exports.zpadSuiAddress = exports.trimSuiType = exports.isValidSuiType = exports.SuiZeroAddress = void 0;
const utils_1 = require("@mysten/sui.js/utils");
const sdk_connect_1 = require("@wormhole-foundation/sdk-connect");
const constants_js_1 = require("./constants.js");
const types_js_1 = require("./types.js");
exports.SuiZeroAddress = "0x";
const isValidSuiType = (str) => /^(0x)?[0-9a-fA-F]+::\w+::\w+$/.test(str);
exports.isValidSuiType = isValidSuiType;
// Removes leading 0s from the address
const trimSuiType = (type) => type.replace(/(0x)(0*)/g, "0x");
exports.trimSuiType = trimSuiType;
// Adds leading 0s to the address to make it 32 bytes long
function zpadSuiAddress(address) {
    address = address.startsWith("0x") ? address.slice(2) : address;
    address = address.length % 2 === 0 ? address : "0" + address;
    const zpadded = address.length === 64
        ? address
        : sdk_connect_1.encoding.hex.encode(sdk_connect_1.encoding.bytes.zpad(sdk_connect_1.encoding.hex.decode(address), 32));
    return `0x${zpadded}`;
}
exports.zpadSuiAddress = zpadSuiAddress;
const normalizeSuiType = (type) => {
    const tokens = type.split(constants_js_1.SUI_SEPARATOR);
    if (tokens.length !== 3)
        throw new Error(`Invalid Sui type: ${type}`);
    return [(0, utils_1.normalizeSuiAddress)(tokens[0]), tokens[1], tokens[2]].join(constants_js_1.SUI_SEPARATOR);
};
exports.normalizeSuiType = normalizeSuiType;
const getCoinTypeFromPackageId = (packageId) => {
    return new SuiAddress(packageId).getCoinType();
};
exports.getCoinTypeFromPackageId = getCoinTypeFromPackageId;
const getPackageIdFromType = (type) => {
    return new SuiAddress(type).getPackageId();
};
exports.getPackageIdFromType = getPackageIdFromType;
const getTableKeyType = (tableType) => {
    const match = (0, exports.trimSuiType)(tableType).match(/0x2::table::Table<(.*)>/);
    if (!match)
        throw new Error(`Invalid table type: ${tableType}`);
    if (match.length < 2)
        throw new Error(`Invalid table type: ${tableType}`);
    const [keyType] = match[1].split(",");
    if (!keyType || !(0, exports.isValidSuiType)(keyType))
        throw new Error(`Invalid key type: ${keyType}`);
    return keyType;
};
exports.getTableKeyType = getTableKeyType;
class SuiAddress {
    static byteSize = 32;
    static platform = types_js_1._platform;
    // Full 32 bytes of Address
    address;
    // Optional module and contract name
    module;
    constructor(address) {
        if (SuiAddress.instanceof(address)) {
            this.address = address.address;
            this.module = address.module;
        }
        else if (sdk_connect_1.UniversalAddress.instanceof(address)) {
            this.address = address.toUint8Array();
        }
        else if (typeof address === "string") {
            // If we've got an address of the form `0x1234...::module::...` then
            // stuff anything after the first `::` into the module field
            // and continue processing the address
            if ((0, exports.isValidSuiType)(address)) {
                const chunks = address.split(constants_js_1.SUI_SEPARATOR);
                this.module = chunks.slice(1).join(constants_js_1.SUI_SEPARATOR);
                address = chunks[0];
            }
            address = zpadSuiAddress(address);
            if (!sdk_connect_1.encoding.hex.valid(address))
                throw new Error("Invalid Sui address: " + address);
            this.address = sdk_connect_1.encoding.hex.decode(address);
        }
        else {
            this.address = address;
        }
    }
    unwrap() {
        const packageId = this.getPackageId();
        const module = this.module ? constants_js_1.SUI_SEPARATOR + this.module : "";
        return `${packageId}${module}`;
    }
    toString() {
        return this.unwrap();
    }
    toNative() {
        return this;
    }
    toUint8Array() {
        return this.address;
    }
    toUniversalAddress() {
        return new sdk_connect_1.UniversalAddress(this.toUint8Array());
    }
    getPackageId() {
        return zpadSuiAddress(sdk_connect_1.encoding.hex.encode(this.address));
    }
    getCoinType() {
        // Special case for the native gas coin
        if (this.module === "sui::SUI") {
            return constants_js_1.SUI_COIN;
        }
        return [this.getPackageId(), "coin", "COIN"].join(constants_js_1.SUI_SEPARATOR);
    }
    static instanceof(address) {
        return address.constructor.platform === SuiAddress.platform;
    }
    equals(other) {
        if (SuiAddress.instanceof(other)) {
            return other.unwrap() === this.unwrap();
        }
        else {
            return this.toUniversalAddress().equals(other);
        }
    }
}
exports.SuiAddress = SuiAddress;
(0, sdk_connect_1.registerNative)("Sui", SuiAddress);
//# sourceMappingURL=address.js.map