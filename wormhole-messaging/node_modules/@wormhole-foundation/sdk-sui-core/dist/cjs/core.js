"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SuiWormholeCore = void 0;
const sdk_connect_1 = require("@wormhole-foundation/sdk-connect");
const sdk_sui_1 = require("@wormhole-foundation/sdk-sui");
class SuiWormholeCore {
    network;
    chain;
    provider;
    contracts;
    chainId;
    coreBridgePackageId;
    constructor(network, chain, provider, contracts) {
        this.network = network;
        this.chain = chain;
        this.provider = provider;
        this.contracts = contracts;
        this.chainId = (0, sdk_connect_1.toChainId)(chain);
        const coreBridgeAddress = contracts.coreBridge;
        if (!coreBridgeAddress)
            throw new Error(`CoreBridge contract Address for chain ${chain} not found`);
        this.coreBridgePackageId = coreBridgeAddress;
    }
    getGuardianSet(index) {
        throw new Error("Method not implemented.");
    }
    getMessageFee() {
        throw new Error("Method not implemented.");
    }
    static async fromRpc(connection, config) {
        const [network, chain] = await sdk_sui_1.SuiPlatform.chainFromRpc(connection);
        const conf = config[chain];
        if (conf.network !== network)
            throw new Error(`Network mismatch: ${conf.network} !== ${network}`);
        return new SuiWormholeCore(network, chain, connection, conf.contracts);
    }
    async *verifyMessage(sender, vaa) {
        throw new Error("Method not implemented.");
    }
    async *publishMessage(sender, message) {
        throw new Error("Method not implemented.");
    }
    async parseTransaction(txid) {
        const messages = await this.parseMessages(txid);
        return messages.map((message) => {
            return {
                emitter: message.emitterAddress,
                sequence: message.sequence,
                chain: this.chain,
            };
        });
    }
    async getGuardianSetIndex() {
        throw new Error("Method not implemented.");
    }
    async parseMessages(txid) {
        const txBlock = await this.provider.getTransactionBlock({
            digest: txid,
            options: { showEvents: true, showEffects: true, showInput: true },
        });
        const messages = txBlock.events?.filter((event) => event.type.endsWith("WormholeMessage"));
        if (!messages || messages.length == 0)
            throw new Error("WormholeMessage not found");
        return messages.map((message) => {
            const msg = message.parsedJson;
            return (0, sdk_connect_1.createVAA)("Uint8Array", {
                emitterChain: this.chain,
                emitterAddress: new sdk_sui_1.SuiAddress(msg.sender).toUniversalAddress(),
                sequence: BigInt(msg.sequence),
                guardianSet: 0, // TODO: need to implement guardian set idx
                timestamp: Number(msg.timestamp),
                consistencyLevel: msg.consistency_level,
                nonce: msg.nonce,
                signatures: [],
                payload: new Uint8Array(msg.payload),
            });
        });
    }
}
exports.SuiWormholeCore = SuiWormholeCore;
//# sourceMappingURL=core.js.map