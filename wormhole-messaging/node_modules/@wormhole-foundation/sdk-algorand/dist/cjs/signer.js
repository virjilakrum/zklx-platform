"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlgorandSigner = exports.getAlgorandSigner = void 0;
const algosdk_1 = require("algosdk");
const platform_js_1 = require("./platform.js");
async function getAlgorandSigner(rpc, mnemonic) {
    const [network, chain] = await platform_js_1.AlgorandPlatform.chainFromRpc(rpc);
    return new AlgorandSigner(chain, rpc, mnemonic);
}
exports.getAlgorandSigner = getAlgorandSigner;
// AlgorandSigner implements SignOnlySender
class AlgorandSigner {
    _chain;
    _debug;
    _account;
    constructor(_chain, _rpc, mnemonic, _debug = false) {
        this._chain = _chain;
        this._debug = _debug;
        this._account = (0, algosdk_1.mnemonicToSecretKey)(mnemonic);
    }
    chain() {
        return this._chain;
    }
    address() {
        return this._account.addr;
    }
    async sign(unsignedTxns) {
        const signed = [];
        const ungrouped = unsignedTxns.map((val, idx) => {
            return val.transaction.tx;
        });
        const grouped = (0, algosdk_1.assignGroupID)(ungrouped);
        // Replace the ungrouped Transactions with grouped Transactions
        const groupedAlgoUnsignedTxns = unsignedTxns.map((val, idx) => {
            val.transaction.tx = grouped[idx];
            return val;
        });
        for (const algoUnsignedTxn of groupedAlgoUnsignedTxns) {
            const { description, transaction: tsp } = algoUnsignedTxn;
            const { tx, signer } = tsp;
            if (this._debug) {
                console.log(tx._getDictForDisplay());
                console.log(tx.txID());
            }
            if (signer) {
                if (this._debug)
                    console.log(`Signing: ${description} with signer ${signer.address} for address ${this.address()}`);
                signed.push(await signer.signTxn(tx));
            }
            else {
                if (this._debug)
                    console.log(`Signing: ${description} without signer for address ${this.address()}`);
                signed.push(tx.signTxn(this._account.sk));
            }
        }
        return signed;
    }
}
exports.AlgorandSigner = AlgorandSigner;
//# sourceMappingURL=signer.js.map