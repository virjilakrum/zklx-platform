import { assignGroupID, mnemonicToSecretKey } from "algosdk";
import { AlgorandPlatform } from "./platform.js";
export async function getAlgorandSigner(rpc, mnemonic) {
    const [network, chain] = await AlgorandPlatform.chainFromRpc(rpc);
    return new AlgorandSigner(chain, rpc, mnemonic);
}
// AlgorandSigner implements SignOnlySender
export class AlgorandSigner {
    _chain;
    _debug;
    _account;
    constructor(_chain, _rpc, mnemonic, _debug = false) {
        this._chain = _chain;
        this._debug = _debug;
        this._account = mnemonicToSecretKey(mnemonic);
    }
    chain() {
        return this._chain;
    }
    address() {
        return this._account.addr;
    }
    async sign(unsignedTxns) {
        const signed = [];
        const ungrouped = unsignedTxns.map((val, idx) => {
            return val.transaction.tx;
        });
        const grouped = assignGroupID(ungrouped);
        // Replace the ungrouped Transactions with grouped Transactions
        const groupedAlgoUnsignedTxns = unsignedTxns.map((val, idx) => {
            val.transaction.tx = grouped[idx];
            return val;
        });
        for (const algoUnsignedTxn of groupedAlgoUnsignedTxns) {
            const { description, transaction: tsp } = algoUnsignedTxn;
            const { tx, signer } = tsp;
            if (this._debug) {
                console.log(tx._getDictForDisplay());
                console.log(tx.txID());
            }
            if (signer) {
                if (this._debug)
                    console.log(`Signing: ${description} with signer ${signer.address} for address ${this.address()}`);
                signed.push(await signer.signTxn(tx));
            }
            else {
                if (this._debug)
                    console.log(`Signing: ${description} without signer for address ${this.address()}`);
                signed.push(tx.signTxn(this._account.sk));
            }
        }
        return signed;
    }
}
//# sourceMappingURL=signer.js.map