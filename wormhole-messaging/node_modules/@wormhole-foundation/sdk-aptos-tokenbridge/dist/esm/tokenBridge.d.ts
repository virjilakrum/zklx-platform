import type { ChainAddress, ChainId, ChainsConfig, Contracts, Network, TokenBridge, TokenId } from "@wormhole-foundation/sdk-connect";
import { UniversalAddress } from "@wormhole-foundation/sdk-connect";
import type { AnyAptosAddress, AptosChains, AptosPlatformType } from "@wormhole-foundation/sdk-aptos";
import { AptosUnsignedTransaction } from "@wormhole-foundation/sdk-aptos";
import type { AptosClient } from "aptos";
export declare class AptosTokenBridge<N extends Network, C extends AptosChains> implements TokenBridge<N, C> {
    readonly network: N;
    readonly chain: C;
    readonly connection: AptosClient;
    readonly contracts: Contracts;
    readonly chainId: ChainId;
    readonly tokenBridgeAddress: string;
    constructor(network: N, chain: C, connection: AptosClient, contracts: Contracts);
    static fromRpc<N extends Network>(connection: AptosClient, config: ChainsConfig<N, AptosPlatformType>): Promise<AptosTokenBridge<N, AptosChains>>;
    isWrappedAsset(token: AnyAptosAddress): Promise<boolean>;
    getOriginalAsset(token: AnyAptosAddress): Promise<TokenId>;
    getTokenUniversalAddress(token: AnyAptosAddress): Promise<UniversalAddress>;
    hasWrappedAsset(token: TokenId): Promise<boolean>;
    getWrappedAsset(token: TokenId): Promise<import("@wormhole-foundation/sdk-connect").ChainToPlatform<C> extends infer T ? T extends import("@wormhole-foundation/sdk-connect").ChainToPlatform<C> ? T extends "Aptos" ? import("@wormhole-foundation/sdk-connect").WormholeRegistry.PlatformToNativeAddressMapping[T] : never : never : never>;
    isTransferCompleted(vaa: TokenBridge.TransferVAA): Promise<boolean>;
    getWrappedNative(): Promise<import("@wormhole-foundation/sdk-connect").ChainToPlatform<C> extends infer T ? T extends import("@wormhole-foundation/sdk-connect").ChainToPlatform<C> ? T extends "Aptos" ? import("@wormhole-foundation/sdk-connect").WormholeRegistry.PlatformToNativeAddressMapping[T] : never : never : never>;
    createAttestation(token: AnyAptosAddress, payer?: AnyAptosAddress): AsyncGenerator<AptosUnsignedTransaction<N, C>>;
    submitAttestation(vaa: TokenBridge.AttestVAA, payer?: AnyAptosAddress): AsyncGenerator<AptosUnsignedTransaction<N, C>>;
    transfer(sender: AnyAptosAddress, recipient: ChainAddress, token: AnyAptosAddress, amount: bigint, payload?: Uint8Array): AsyncGenerator<AptosUnsignedTransaction<N, C>>;
    redeem(sender: AnyAptosAddress, vaa: TokenBridge.TransferVAA, unwrapNative?: boolean): AsyncGenerator<AptosUnsignedTransaction<N, C>>;
    getAssetFullyQualifiedType(tokenId: TokenId): Promise<string | null>;
    /**
     * Given a hash, returns the fully qualified type by querying the corresponding TypeInfo.
     * @param address Hash of fully qualified type
     * @returns The fully qualified type associated with the given hash
     */
    getTypeFromExternalAddress(address: string): Promise<string | null>;
    /**
     * Derive the module address for an asset defined by the given origin chain and address.
     * @param tokenBridgeAddress Address of token bridge (32 bytes)
     * @param originChain Chain ID of chain that original asset is from
     * @param originAddress Native address of asset
     * @returns The module address for the given asset
     */
    static getForeignAssetAddress(chain: AptosChains, tokenBridgeAddress: string, tokenId: TokenId): string;
    private createUnsignedTx;
}
//# sourceMappingURL=tokenBridge.d.ts.map