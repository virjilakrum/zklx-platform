import { PlatformContext, Wormhole, chainToPlatform, decimals, nativeChainIds, networkPlatformConfigs, isNative, } from '@wormhole-foundation/sdk-connect';
import { SolanaChain } from './chain.js';
import { TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { Connection, PublicKey } from '@solana/web3.js';
import { SolanaAddress, SolanaZeroAddress } from './address.js';
import { _platform } from './types.js';
/**
 * @category Solana
 */
export class SolanaPlatform extends PlatformContext {
    static _platform = _platform;
    constructor(network, config) {
        super(network, config ?? networkPlatformConfigs(network, SolanaPlatform._platform));
    }
    getRpc(chain, config = {
        commitment: 'confirmed',
        disableRetryOnRateLimit: true,
    }) {
        if (chain in this.config)
            return new Connection(this.config[chain].rpc, config);
        throw new Error('No configuration available for chain: ' + chain);
    }
    getChain(chain, rpc) {
        if (chain in this.config)
            return new SolanaChain(chain, this, rpc);
        throw new Error('No configuration available for chain: ' + chain);
    }
    static nativeTokenId(network, chain) {
        if (!SolanaPlatform.isSupportedChain(chain))
            throw new Error(`invalid chain: ${chain}`);
        return Wormhole.chainAddress(chain, SolanaZeroAddress);
    }
    static isNativeTokenId(network, chain, tokenId) {
        if (!this.isSupportedChain(chain))
            return false;
        if (tokenId.chain !== chain)
            return false;
        const native = this.nativeTokenId(network, chain);
        return native == tokenId;
    }
    static isSupportedChain(chain) {
        const platform = chainToPlatform(chain);
        return platform === SolanaPlatform._platform;
    }
    static async getDecimals(chain, rpc, token) {
        if (isNative(token))
            return decimals.nativeDecimals(SolanaPlatform._platform);
        let mint = await rpc.getParsedAccountInfo(new SolanaAddress(token).unwrap());
        if (!mint || !mint.value)
            throw new Error('could not fetch token details');
        const { decimals: numDecimals } = mint.value.data
            .parsed.info;
        return numDecimals;
    }
    static async getBalance(chain, rpc, walletAddress, token) {
        const address = new PublicKey(walletAddress);
        if (isNative(token))
            return BigInt(await rpc.getBalance(address));
        // Check to see if we were passed wallet address or token account
        const splToken = await rpc.getTokenAccountsByOwner(address, {
            mint: new SolanaAddress(token).unwrap(),
        });
        // Use the first token account if it exists, otherwise fall back to wallet address
        const checkAddress = splToken.value.length > 0 ? splToken.value[0].pubkey : address;
        const balance = await rpc.getTokenAccountBalance(checkAddress);
        return BigInt(balance.value.amount);
    }
    static async getBalances(chain, rpc, walletAddress, tokens) {
        let native;
        if (tokens.includes('native')) {
            native = BigInt(await rpc.getBalance(new PublicKey(walletAddress)));
        }
        const splParsedTokenAccounts = await rpc.getParsedTokenAccountsByOwner(new PublicKey(walletAddress), {
            programId: new PublicKey(TOKEN_PROGRAM_ID),
        });
        const balancesArr = tokens.map((token) => {
            if (isNative(token)) {
                return { ['native']: native };
            }
            const addrString = new SolanaAddress(token).toString();
            const amount = splParsedTokenAccounts.value.find((v) => v?.account.data.parsed?.info?.mint === token)?.account.data.parsed?.info?.tokenAmount?.amount;
            if (!amount)
                return { [addrString]: null };
            return { [addrString]: BigInt(amount) };
        });
        return balancesArr.reduce((obj, item) => Object.assign(obj, item), {});
    }
    static async sendWait(chain, rpc, stxns, opts) {
        const results = await Promise.all(stxns.map((stxn) => this.sendTxWithRetry(rpc, stxn, opts)));
        const txhashes = results.map((r) => r.signature);
        const erroredTxs = results
            .filter((r) => r.response.value.err)
            .map((r) => r.response.value.err);
        if (erroredTxs.length > 0)
            throw new Error(`Failed to confirm transaction: ${erroredTxs}`);
        return txhashes;
    }
    static async sendTxWithRetry(rpc, tx, sendOpts = {}, retryInterval = 5000) {
        const commitment = sendOpts.preflightCommitment ?? rpc.commitment;
        const signature = await rpc.sendRawTransaction(tx, {
            ...sendOpts,
            skipPreflight: false, // The first send should not skip preflight to catch any errors
            maxRetries: 0,
            preflightCommitment: commitment,
        });
        // TODO: Use the lastValidBlockHeight that corresponds to the blockhash used in the transaction.
        const { blockhash, lastValidBlockHeight } = await rpc.getLatestBlockhash();
        const confirmTransactionPromise = rpc.confirmTransaction({
            signature,
            blockhash,
            lastValidBlockHeight,
        }, commitment);
        // This loop will break once the transaction has been confirmed or the block height is exceeded.
        // An exception will be thrown if the block height is exceeded by the confirmTransactionPromise.
        // The transaction will be resent if it hasn't been confirmed after the interval.
        let confirmedTx = null;
        while (!confirmedTx) {
            confirmedTx = await Promise.race([
                confirmTransactionPromise,
                new Promise((resolve) => setTimeout(() => {
                    resolve(null);
                }, retryInterval)),
            ]);
            if (confirmedTx) {
                break;
            }
            await rpc.sendRawTransaction(tx, {
                ...sendOpts,
                skipPreflight: true,
                maxRetries: 0,
                preflightCommitment: commitment,
            });
        }
        return { signature, response: confirmedTx };
    }
    static async latestBlock(rpc, commitment) {
        return rpc.getLatestBlockhash(commitment ?? rpc.commitment);
    }
    static async getLatestBlock(rpc) {
        return await rpc.getSlot();
    }
    static async getLatestFinalizedBlock(rpc) {
        const { lastValidBlockHeight } = await this.latestBlock(rpc, 'finalized');
        return lastValidBlockHeight;
    }
    static chainFromChainId(genesisHash) {
        const netChain = nativeChainIds.platformNativeChainIdToNetworkChain(SolanaPlatform._platform, genesisHash);
        if (!netChain)
            throw new Error(`No matching genesis hash to determine network and chain: ${genesisHash}`);
        const [network, chain] = netChain;
        return [network, chain];
    }
    static async chainFromRpc(rpc) {
        try {
            const gh = await rpc.getGenesisHash();
            return SolanaPlatform.chainFromChainId(gh);
        }
        catch (e) {
            // Override for devnet which will often have a new Genesis hash
            if (rpc.rpcEndpoint.includes('http://127') ||
                rpc.rpcEndpoint.includes('http://localhost') ||
                rpc.rpcEndpoint === 'http://solana-devnet:8899') {
                return ['Devnet', 'Solana'];
            }
            throw e;
        }
    }
}
//# sourceMappingURL=platform.js.map