/// <reference types="node" />
import type { Connection, SendOptions, Transaction, TransactionInstruction, VersionedTransaction } from '@solana/web3.js';
import { Keypair } from '@solana/web3.js';
import type { Network, SignAndSendSigner, SignOnlySigner, Signer, UnsignedTransaction } from '@wormhole-foundation/sdk-connect';
import type { SolanaChains } from './types.js';
import { type SolanaUnsignedTransaction } from './unsignedTransaction.js';
/** Options for setting the priority fee for a transaction */
export type PriorityFeeOptions = {
    /** The percentile of recent fees to use as a base fee */
    percentile?: number;
    /** The multiple to apply to the percentile base fee  */
    percentileMultiple?: number;
    /** The minimum priority fee to use */
    min?: number;
    /** The maximum priority fee to use */
    max?: number;
};
/** Recommended priority fee options */
export declare const DefaultPriorityFeeOptions: PriorityFeeOptions;
/** Options for the SolanaSendSigner  */
export type SolanaSendSignerOptions = {
    /** log details of transaction attempts  */
    debug?: boolean;
    /** determine compute budget and priority fees to land a transaction */
    priorityFee?: PriorityFeeOptions;
    /** any send options from solana/web3.js */
    sendOpts?: SendOptions;
    /** how many times to attempt resubmitting the transaction to the network with a new blockhash */
    retries?: number;
};
export declare function getSolanaSigner(rpc: Connection, privateKey: string): Promise<Signer>;
export declare function getSolanaSignAndSendSigner(rpc: Connection, privateKey: string | Keypair, opts?: SolanaSendSignerOptions): Promise<Signer>;
export declare class SolanaSendSigner<N extends Network, C extends SolanaChains = 'Solana'> implements SignAndSendSigner<N, C> {
    private _rpc;
    private _chain;
    private _keypair;
    private _debug;
    private _priorityFee;
    private _maxResubmits;
    private _sendOpts?;
    constructor(_rpc: Connection, _chain: C, _keypair: Keypair, _debug: boolean, _priorityFee: PriorityFeeOptions, _maxResubmits?: number, _sendOpts?: SendOptions | undefined);
    chain(): C;
    address(): string;
    private retryable;
    signAndSend(tx: UnsignedTransaction[]): Promise<any[]>;
}
export declare function logTxDetails(transaction: Transaction | VersionedTransaction): void;
/**
 *
 * @param connection a Solana/web3.js Connection to the network
 * @param transaction the transaction to determine the compute budget for
 * @param feePercentile the percentile of recent fees to use
 * @param multiple the multiple to apply to the percentile fee
 * @param minPriorityFee the minimum priority fee to use
 * @param maxPriorityFee the maximum priority fee to use
 * @returns an array of TransactionInstructions to set the compute budget and priority fee for the transaction
 */
export declare function createPriorityFeeInstructions(connection: Connection, transaction: Transaction | VersionedTransaction, feePercentile?: number, multiple?: number, minPriorityFee?: number, maxPriorityFee?: number): Promise<TransactionInstruction[]>;
/**
 * A helper function to determine the compute budget to use for a transaction
 * @param connection Solana/web3.js Connection to the network
 * @param transaction The transaction to determine the compute budget for
 * @returns the compute budget to use for the transaction
 */
export declare function determineComputeBudget(connection: Connection, transaction: Transaction | VersionedTransaction): Promise<number>;
/**
 * A helper function to determine the priority fee to use for a transaction
 *
 * @param connection Solana/web3.js Connection to the network
 * @param transaction The transaction to determine the priority fee for
 * @param percentile The percentile of recent fees to use
 * @param multiple The multiple to apply to the percentile fee
 * @param minPriorityFee The minimum priority fee to use
 * @param maxPriorityFee The maximum priority fee to use
 * @returns the priority fee to use according to the recent transactions and the given parameters
 */
export declare function determinePriorityFee(connection: Connection, transaction: Transaction | VersionedTransaction, percentile?: number, multiple?: number, minPriorityFee?: number, maxPriorityFee?: number): Promise<number>;
export declare class SolanaSigner<N extends Network, C extends SolanaChains = 'Solana'> implements SignOnlySigner<N, C> {
    private _chain;
    private _keypair;
    private _rpc;
    private _debug;
    constructor(_chain: C, _keypair: Keypair, _rpc: Connection, _debug?: boolean);
    chain(): C;
    address(): string;
    sign(tx: SolanaUnsignedTransaction<N>[]): Promise<Buffer[]>;
}
//# sourceMappingURL=signer.d.ts.map