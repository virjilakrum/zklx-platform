import type { AccountAddress, AutomaticTokenBridge, Chain, ChainAddress, ChainsConfig, Contracts, NativeAddress, Network, TokenAddress } from '@wormhole-foundation/sdk-connect';
import type { EvmChains, EvmPlatformType } from '@wormhole-foundation/sdk-evm';
import { EvmUnsignedTransaction } from '@wormhole-foundation/sdk-evm';
import type { Provider } from 'ethers';
import { ethers_contracts } from './index.js';
import '@wormhole-foundation/sdk-evm-core';
export declare class EvmAutomaticTokenBridge<N extends Network, C extends EvmChains> implements AutomaticTokenBridge<N, C> {
    readonly network: N;
    readonly chain: C;
    readonly provider: Provider;
    readonly contracts: Contracts;
    readonly tokenBridgeRelayer: ethers_contracts.TokenBridgeRelayer;
    readonly tokenBridge: ethers_contracts.TokenBridgeContract;
    readonly chainId: bigint;
    constructor(network: N, chain: C, provider: Provider, contracts: Contracts);
    redeem(sender: AccountAddress<C>, vaa: AutomaticTokenBridge.VAA): AsyncGenerator<EvmUnsignedTransaction<N, C>>;
    static fromRpc<N extends Network>(provider: Provider, config: ChainsConfig<N, EvmPlatformType>): Promise<EvmAutomaticTokenBridge<N, EvmChains>>;
    transfer(sender: AccountAddress<C>, recipient: ChainAddress, token: TokenAddress<C>, amount: bigint, nativeGas?: bigint): AsyncGenerator<EvmUnsignedTransaction<N, C>>;
    getRelayerFee(destination: Chain, token: TokenAddress<C>): Promise<bigint>;
    nativeTokenAmount(token: TokenAddress<C>, amount: bigint): Promise<bigint>;
    maxSwapAmount(token: TokenAddress<C>): Promise<bigint>;
    getRegisteredTokens(): Promise<NativeAddress<C>[]>;
    isRegisteredToken(token: TokenAddress<C>): Promise<boolean>;
    private tokenAddress;
    private createUnsignedTx;
}
//# sourceMappingURL=automaticTokenBridge.d.ts.map