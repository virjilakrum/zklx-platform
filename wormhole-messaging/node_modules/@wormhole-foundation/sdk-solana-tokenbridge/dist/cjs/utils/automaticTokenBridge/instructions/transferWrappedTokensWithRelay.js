"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTransferWrappedTokensWithRelayInstruction = void 0;
const web3_js_1 = require("@solana/web3.js");
const cpi_js_1 = require("../../tokenBridge/cpi.js");
const program_js_1 = require("../program.js");
const index_js_1 = require("./../accounts/index.js");
const spl_token_1 = require("@solana/spl-token");
const index_js_2 = require("./../../tokenBridge/index.js");
const signerSequence_js_1 = require("../accounts/signerSequence.js");
const sdk_connect_1 = require("@wormhole-foundation/sdk-connect");
const bn_js_1 = __importDefault(require("bn.js"));
async function createTransferWrappedTokensWithRelayInstruction(connection, programId, payer, tokenBridgeProgramId, wormholeProgramId, mint, amount, toNativeTokenAmount, recipientAddress, recipientChain, batchId) {
    const { methods: { transferWrappedTokensWithRelay }, account: { signerSequence }, } = (0, program_js_1.createTokenBridgeRelayerProgramInterface)(programId, connection);
    const signerSequenceAddress = (0, signerSequence_js_1.deriveSignerSequenceAddress)(programId, payer);
    const sequence = await signerSequence
        .fetch(signerSequenceAddress)
        .then(({ value }) => value)
        .catch((e) => {
        if (e.message?.includes('Account does not exist')) {
            // first time transferring
            return new bn_js_1.default(0);
        }
        throw e;
    });
    const message = (0, index_js_1.deriveTokenTransferMessageAddress)(programId, payer, sequence);
    const fromTokenAccount = (0, spl_token_1.getAssociatedTokenAddressSync)(new web3_js_1.PublicKey(mint), new web3_js_1.PublicKey(payer));
    const { chain, tokenAddress } = await (0, index_js_2.getWrappedMeta)(connection, tokenBridgeProgramId, mint);
    const tmpTokenAccount = (0, index_js_1.deriveTmpTokenAccountAddress)(programId, mint);
    const tokenBridgeAccounts = (0, cpi_js_1.getTransferWrappedWithPayloadCpiAccounts)(programId, tokenBridgeProgramId, wormholeProgramId, payer, message, fromTokenAccount, chain, tokenAddress);
    return transferWrappedTokensWithRelay(new bn_js_1.default(amount.toString()), new bn_js_1.default(toNativeTokenAmount.toString()), (0, sdk_connect_1.toChainId)(recipientChain), [...recipientAddress], batchId)
        .accounts({
        config: (0, index_js_1.deriveSenderConfigAddress)(programId),
        payerSequence: signerSequenceAddress,
        foreignContract: (0, index_js_1.deriveForeignContractAddress)(programId, recipientChain),
        registeredToken: (0, index_js_1.deriveRegisteredTokenAddress)(programId, new web3_js_1.PublicKey(mint)),
        tmpTokenAccount,
        tokenBridgeProgram: new web3_js_1.PublicKey(tokenBridgeProgramId),
        ...tokenBridgeAccounts,
    })
        .instruction();
}
exports.createTransferWrappedTokensWithRelayInstruction = createTransferWrappedTokensWithRelayInstruction;
//# sourceMappingURL=transferWrappedTokensWithRelay.js.map