import type { ChainAddress, ChainId, ChainsConfig, Contracts, Network, Platform, TokenBridge, TokenId } from '@wormhole-foundation/sdk-connect';
import { UniversalAddress } from '@wormhole-foundation/sdk-connect';
import type { AnySolanaAddress, SolanaChains } from '@wormhole-foundation/sdk-solana';
import { SolanaUnsignedTransaction } from '@wormhole-foundation/sdk-solana';
import { SolanaWormholeCore } from '@wormhole-foundation/sdk-solana-core';
import type { Program } from '@coral-xyz/anchor';
import type { Connection } from '@solana/web3.js';
import type { TokenBridge as TokenBridgeContract } from './tokenBridgeType.js';
import '@wormhole-foundation/sdk-solana-core';
export declare class SolanaTokenBridge<N extends Network, C extends SolanaChains> implements TokenBridge<N, C> {
    readonly network: N;
    readonly chain: C;
    readonly connection: Connection;
    readonly contracts: Contracts;
    readonly chainId: ChainId;
    readonly coreBridge: SolanaWormholeCore<N, C>;
    readonly tokenBridge: Program<TokenBridgeContract>;
    constructor(network: N, chain: C, connection: Connection, contracts: Contracts);
    static fromRpc<N extends Network>(connection: Connection, config: ChainsConfig<N, Platform>): Promise<SolanaTokenBridge<N, SolanaChains>>;
    isWrappedAsset(token: AnySolanaAddress): Promise<boolean>;
    getOriginalAsset(token: AnySolanaAddress): Promise<TokenId>;
    getTokenUniversalAddress(token: AnySolanaAddress): Promise<UniversalAddress>;
    hasWrappedAsset(token: TokenId): Promise<boolean>;
    getWrappedAsset(token: TokenId): Promise<import("@wormhole-foundation/sdk-connect").ChainToPlatform<C> extends infer T ? T extends import("@wormhole-foundation/sdk-connect").ChainToPlatform<C> ? T extends "Solana" ? import("@wormhole-foundation/sdk-connect").WormholeRegistry.PlatformToNativeAddressMapping[T] : never : never : never>;
    isTransferCompleted(vaa: TokenBridge.TransferVAA): Promise<boolean>;
    getWrappedNative(): Promise<import("@wormhole-foundation/sdk-connect").ChainToPlatform<C> extends infer T ? T extends import("@wormhole-foundation/sdk-connect").ChainToPlatform<C> ? T extends "Solana" ? import("@wormhole-foundation/sdk-connect").WormholeRegistry.PlatformToNativeAddressMapping[T] : never : never : never>;
    createAttestation(token: AnySolanaAddress, payer?: AnySolanaAddress): AsyncGenerator<SolanaUnsignedTransaction<N, C>>;
    submitAttestation(vaa: TokenBridge.AttestVAA, payer?: AnySolanaAddress): AsyncGenerator<SolanaUnsignedTransaction<N, C>>;
    private transferSol;
    transfer(sender: AnySolanaAddress, recipient: ChainAddress, token: AnySolanaAddress, amount: bigint, payload?: Uint8Array): AsyncGenerator<SolanaUnsignedTransaction<N, C>>;
    private redeemAndUnwrap;
    private createAta;
    redeem(sender: AnySolanaAddress, vaa: TokenBridge.TransferVAA, unwrapNative?: boolean): AsyncGenerator<SolanaUnsignedTransaction<N, C>, void, unknown>;
    private createUnsignedTx;
}
//# sourceMappingURL=tokenBridge.d.ts.map