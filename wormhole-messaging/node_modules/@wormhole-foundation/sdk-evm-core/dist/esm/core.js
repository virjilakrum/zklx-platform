import { nativeChainIds, createVAA, isWormholeMessageId, encoding, serialize, } from '@wormhole-foundation/sdk-connect';
import { ethers_contracts } from './index.js';
import { EvmAddress, EvmPlatform, EvmUnsignedTransaction, addChainId, addFrom, } from '@wormhole-foundation/sdk-evm';
export class EvmWormholeCore {
    network;
    chain;
    provider;
    contracts;
    chainId;
    coreAddress;
    core;
    coreIface;
    constructor(network, chain, provider, contracts) {
        this.network = network;
        this.chain = chain;
        this.provider = provider;
        this.contracts = contracts;
        this.chainId = nativeChainIds.networkChainToNativeChainId.get(network, chain);
        this.coreIface = ethers_contracts.Implementation__factory.createInterface();
        const address = this.contracts.coreBridge;
        if (!address)
            throw new Error('Core bridge address not found');
        this.coreAddress = address;
        this.core = ethers_contracts.Implementation__factory.connect(address, provider);
    }
    async getMessageFee() {
        return await this.core.messageFee.staticCall();
    }
    async getGuardianSetIndex() {
        return Number(await this.core.getCurrentGuardianSetIndex.staticCall());
    }
    async getGuardianSet(index) {
        const guardianSet = await this.core.getGuardianSet(index);
        return {
            index: index,
            keys: guardianSet[0],
            expiry: guardianSet[1],
        };
    }
    static async fromRpc(provider, config) {
        const [network, chain] = await EvmPlatform.chainFromRpc(provider);
        const conf = config[chain];
        if (conf.network !== network)
            throw new Error(`Network mismatch: ${conf.network} != ${network}`);
        return new EvmWormholeCore(network, chain, provider, conf.contracts);
    }
    async *publishMessage(sender, message, nonce, consistencyLevel) {
        const senderAddr = new EvmAddress(sender).toString();
        const txReq = await this.core.publishMessage.populateTransaction(nonce, message, consistencyLevel);
        yield this.createUnsignedTx(addFrom(txReq, senderAddr), 'WormholeCore.publishMessage');
    }
    async *verifyMessage(sender, vaa) {
        const senderAddr = new EvmAddress(sender).toString();
        const txReq = await this.core.parseAndVerifyVM.populateTransaction(serialize(vaa));
        yield this.createUnsignedTx(addFrom(txReq, senderAddr), 'WormholeCore.verifyMessage');
    }
    async parseTransaction(txid) {
        const receipt = await this.provider.getTransactionReceipt(txid);
        if (receipt === null)
            return [];
        return receipt.logs
            .filter((l) => {
            return l.address === this.coreAddress;
        })
            .map((log) => {
            const { topics, data } = log;
            const parsed = this.coreIface.parseLog({
                topics: topics.slice(),
                data,
            });
            if (parsed === null)
                return undefined;
            const emitterAddress = new EvmAddress(parsed.args['sender']);
            return {
                chain: this.chain,
                emitter: emitterAddress.toUniversalAddress(),
                sequence: parsed.args['sequence'],
            };
        })
            .filter(isWormholeMessageId);
    }
    async parseMessages(txid) {
        const receipt = await this.provider.getTransactionReceipt(txid);
        if (receipt === null)
            throw new Error('Could not get transaction receipt');
        const gsIdx = await this.getGuardianSetIndex();
        return receipt.logs
            .filter((l) => {
            return l.address === this.coreAddress;
        })
            .map((log) => {
            const { topics, data } = log;
            const parsed = this.coreIface.parseLog({
                topics: topics.slice(),
                data,
            });
            if (parsed === null)
                return null;
            const emitterAddress = new EvmAddress(parsed.args['sender']);
            return createVAA('Uint8Array', {
                guardianSet: gsIdx, // TODO: should we get this from the contract on init?
                timestamp: 0, // TODO: Would need to get the full block to get the timestamp
                emitterChain: this.chain,
                emitterAddress: emitterAddress.toUniversalAddress(),
                consistencyLevel: Number(parsed.args['consistencyLevel']),
                sequence: BigInt(parsed.args['sequence']),
                nonce: Number(parsed.args['nonce']),
                signatures: [],
                payload: encoding.hex.decode(parsed.args['payload']),
            });
        })
            .filter((vaa) => !!vaa);
    }
    createUnsignedTx(txReq, description, parallelizable = false) {
        return new EvmUnsignedTransaction(addChainId(txReq, this.chainId), this.network, this.chain, description, parallelizable);
    }
}
//# sourceMappingURL=core.js.map