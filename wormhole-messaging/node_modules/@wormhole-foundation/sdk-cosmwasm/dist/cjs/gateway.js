"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Gateway = void 0;
const sdk_connect_1 = require("@wormhole-foundation/sdk-connect");
const address_js_1 = require("./address.js");
const chain_js_1 = require("./chain.js");
const constants_js_1 = require("./constants.js");
const platform_js_1 = require("./platform.js");
class Gateway extends chain_js_1.CosmwasmChain {
    static chain = "Wormchain";
    static gatewayAddress = (network) => sdk_connect_1.CONFIG[network].chains[Gateway.chain].contracts.gateway;
    static tokenBridgeAddress = (network) => sdk_connect_1.CONFIG[network].chains[Gateway.chain].contracts.tokenBridge;
    static coreAddress = (network) => sdk_connect_1.CONFIG[network].chains[Gateway.chain].contracts.coreBridge;
    // Get the wrapped version of an asset created on wormchain
    async getWrappedAsset(token) {
        const tb = await this.getTokenBridge();
        const wrappedAsset = new address_js_1.CosmwasmAddress(await tb.getWrappedAsset(token));
        // Encode the original address to base58 and add it
        // to the factory address for cw20 style factory token address
        const encodedAddress = sdk_connect_1.encoding.b58.encode(wrappedAsset.toUniversalAddress().toUint8Array());
        const factoryAddress = `factory/${Gateway.gatewayAddress(this.network)}/${encodedAddress}`;
        return new address_js_1.CosmwasmAddress(factoryAddress);
    }
    // Gets the the source channel for outgoing transfers from wormchain
    static getGatewaySourceChannel(network, chain) {
        const channels = platform_js_1.CosmwasmPlatform.getIbcChannels(network, chain);
        if (!channels)
            throw new Error("No channels configured for chain " + chain);
        if (!(Gateway.chain in channels))
            throw new Error("No channel configured for chain " + chain);
        return channels[Gateway.chain];
    }
    // derive the ics20 token denom from the
    // wrapped denom and destination channel
    static deriveIbcDenom(network, chain, denom) {
        // Otherwise compute the ibc address from the channel and denom
        const channel = this.getGatewaySourceChannel(network, chain);
        const hashData = sdk_connect_1.encoding.bytes.encode(`${constants_js_1.IBC_TRANSFER_PORT}/${channel}/${denom}`);
        const hash = sdk_connect_1.encoding.hex.encode((0, sdk_connect_1.sha256)(hashData));
        return new address_js_1.CosmwasmAddress(`ibc/${hash.toUpperCase()}`);
    }
    // Util to convert a factory address to a CW20 address
    // expects the denom to be base58 encoded
    // e.g. factoryToCw20("wormhole", "8sYgCzLRJC3J7qPn2bNbx6PiGcarhyx8rBhVaNnfvHCA")
    static factoryToCw20(address) {
        if (address.denomType !== "factory")
            throw new Error("Invalid address type");
        return new address_js_1.CosmwasmAddress(address_js_1.CosmwasmAddress.encode(address.domain, sdk_connect_1.encoding.b58.decode(address.denom)));
    }
    static cw20ToFactory(network, address) {
        // Encode the original address to base58 and add it
        // to the factory address for cw20 style factory token address
        const encodedAddress = sdk_connect_1.encoding.b58.encode(address.toUniversalAddress().toUint8Array());
        return new address_js_1.CosmwasmAddress(`factory/${Gateway.gatewayAddress(network)}/${encodedAddress}`);
    }
    static makeTransferMsg(chain, recipient, fee = 0n, payload, nonce) {
        // Address of recipient is b64 encoded Cosmos bech32 address
        const address = sdk_connect_1.encoding.b64.encode(recipient.toUint8Array());
        const common = {
            chain: (0, sdk_connect_1.toChainId)(chain),
            recipient: address,
            fee: fee.toString(),
            nonce: nonce ?? Math.round(Math.random() * 100000),
        };
        const msg = payload
            ? {
                gateway_transfer_with_payload: { ...common, payload: payload },
            }
            : { gateway_transfer: { ...common } };
        return msg;
    }
}
exports.Gateway = Gateway;
//# sourceMappingURL=gateway.js.map