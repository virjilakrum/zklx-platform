"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CosmwasmUnsignedTransaction = exports.buildExecuteMsg = exports.computeFee = void 0;
const stargate_1 = require("@cosmjs/stargate");
const sdk_connect_1 = require("@wormhole-foundation/sdk-connect");
const tx_js_1 = require("cosmjs-types/cosmwasm/wasm/v1/tx.js");
const constants_js_1 = require("./constants.js");
const platform_js_1 = require("./platform.js");
function computeFee(network, chain) {
    let avgFee = constants_js_1.averageGasPrices.get(network, chain);
    if (!avgFee)
        avgFee = "0.1";
    return (0, stargate_1.calculateFee)(constants_js_1.DEFAULT_FEE * 1.5, `${avgFee}${platform_js_1.CosmwasmPlatform.getNativeDenom(network, chain)}`);
}
exports.computeFee = computeFee;
function buildExecuteMsg(sender, contract, msg, funds) {
    return {
        typeUrl: constants_js_1.MSG_EXECUTE_CONTRACT_TYPE_URL,
        value: tx_js_1.MsgExecuteContract.fromPartial({
            sender: sender,
            contract: contract,
            msg: sdk_connect_1.encoding.bytes.encode(JSON.stringify(msg)),
            funds,
        }),
    };
}
exports.buildExecuteMsg = buildExecuteMsg;
class CosmwasmUnsignedTransaction {
    transaction;
    network;
    chain;
    description;
    parallelizable;
    constructor(transaction, network, chain, description, parallelizable = false) {
        this.transaction = transaction;
        this.network = network;
        this.chain = chain;
        this.description = description;
        this.parallelizable = parallelizable;
    }
}
exports.CosmwasmUnsignedTransaction = CosmwasmUnsignedTransaction;
//# sourceMappingURL=unsignedTransaction.js.map