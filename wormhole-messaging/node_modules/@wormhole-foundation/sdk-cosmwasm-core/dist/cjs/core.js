"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CosmwasmWormholeCore = void 0;
const sdk_connect_1 = require("@wormhole-foundation/sdk-connect");
const sdk_cosmwasm_1 = require("@wormhole-foundation/sdk-cosmwasm");
class CosmwasmWormholeCore {
    network;
    chain;
    rpc;
    contracts;
    coreAddress;
    constructor(network, chain, rpc, contracts) {
        this.network = network;
        this.chain = chain;
        this.rpc = rpc;
        this.contracts = contracts;
        const coreAddress = this.contracts.coreBridge;
        if (!coreAddress)
            throw new Error(`Wormhole Token Bridge contract for domain ${chain} not found`);
        this.coreAddress = coreAddress;
    }
    getGuardianSet(index) {
        throw new Error("Method not implemented.");
    }
    getGuardianSetIndex() {
        throw new Error("Method not implemented.");
    }
    getMessageFee() {
        throw new Error("Method not implemented.");
    }
    static async fromRpc(rpc, config) {
        const [network, chain] = await sdk_cosmwasm_1.CosmwasmPlatform.chainFromRpc(rpc);
        const conf = config[chain];
        if (conf.network !== network)
            throw new Error(`Network mismatch: ${conf.network} != ${network}`);
        return new CosmwasmWormholeCore(network, chain, rpc, conf.contracts);
    }
    async *publishMessage(sender, message, nonce, consistencyLevel) {
        throw new Error("Method not implemented.");
    }
    async *verifyMessage(sender, vaa) {
        throw new Error("Not implemented.");
    }
    async parseTransaction(txid) {
        const tx = await this.rpc.getTx(txid);
        if (!tx)
            throw new Error("No transaction found for txid: " + txid);
        return [CosmwasmWormholeCore.parseWormholeMessageId(this.chain, this.coreAddress, tx)];
    }
    async parseMessages(txid) {
        const tx = await this.rpc.getTx(txid);
        if (!tx)
            throw new Error("No transaction found for txid: " + txid);
        return [CosmwasmWormholeCore.parseWormholeMessage(this.chain, this.coreAddress, tx)];
    }
    static parseWormholeMessage(chain, coreAddress, tx) {
        const events = tx.events.filter((ev) => ev.type === "wasm" &&
            ev.attributes[0].key === "_contract_address" &&
            ev.attributes[0].value === coreAddress);
        if (events.length === 0)
            throw new Error("No wormhole message found in tx");
        if (events.length > 1)
            console.error(`Expected single message, found ${events.length}`);
        const [wasm] = events;
        const obj = Object.fromEntries(wasm.attributes.map((attr) => {
            return [attr.key.split(".")[1], attr.value];
        }));
        return (0, sdk_connect_1.createVAA)("Uint8Array", {
            emitterChain: chain,
            emitterAddress: new sdk_connect_1.UniversalAddress(sdk_connect_1.encoding.hex.decode(obj["sender"])),
            sequence: BigInt(obj["sequence"]),
            guardianSet: 0, // TODO: need to implement guardian set idx
            timestamp: Number(obj["block_time"]),
            consistencyLevel: 0,
            nonce: Number(obj["nonce"]),
            signatures: [],
            payload: sdk_connect_1.encoding.hex.decode(obj["message"]),
        });
    }
    static parseWormholeMessageId(chain, coreAddress, tx) {
        const unsignedVaa = CosmwasmWormholeCore.parseWormholeMessage(chain, coreAddress, tx);
        return {
            chain: unsignedVaa.emitterChain,
            emitter: unsignedVaa.emitterAddress,
            sequence: unsignedVaa.sequence,
        };
    }
}
exports.CosmwasmWormholeCore = CosmwasmWormholeCore;
//# sourceMappingURL=core.js.map