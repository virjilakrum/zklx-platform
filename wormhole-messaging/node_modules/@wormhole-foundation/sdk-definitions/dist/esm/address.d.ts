import type { Chain, ChainToPlatform, Platform } from "@wormhole-foundation/sdk-base";
import type { WormholeRegistry } from "./registry.js";
import { UniversalAddress } from "./universalAddress.js";
/**
 * Address is the base interface all address types must implement.
 *
 * Represents a parsed address
 */
export interface Address {
    /**
     * unwrap returns the underlying native address type, e.g.:
     * a Uint8Array for UniversalAddress
     * a checksum hex string string for EVM(ethers)
     * a PublicKey for Solana
     * etc.
     */
    unwrap(): unknown;
    /** Return the address in its canonical string format */
    toString(): string;
    /** Return the bytes for the address */
    toUint8Array(): Uint8Array;
    /** Return an Address that has been converted to its Universal representation */
    toUniversalAddress(): UniversalAddress;
}
export interface ChainSpecificAddress extends Address {
    setChain(chain: Chain): void;
}
export declare function isChainSpecificAddress(thing: any): thing is ChainSpecificAddress;
export type MappedPlatforms = keyof WormholeRegistry.PlatformToNativeAddressMapping;
/** Utility type to map platform to its native address implementation */
type GetNativeAddress<P extends Platform> = P extends MappedPlatforms ? WormholeRegistry.PlatformToNativeAddressMapping[P] : never;
export type NativeAddressCtr = new (ua: UniversalAddress | string | Uint8Array) => Address;
/** An address that has been parsed into its Native Address type */
export type NativeAddress<C extends Chain> = GetNativeAddress<ChainToPlatform<C>>;
/** A union type representing a parsed address */
export type UniversalOrNative<C extends Chain> = UniversalAddress | NativeAddress<C>;
/** An address that represents an account  */
export type AccountAddress<C extends Chain> = UniversalOrNative<C>;
/**
 * ChainAddress represents the parsed address for a given chain
 * and comes with the context of which chain its relevant for
 */
export type ChainAddress<C extends Chain = Chain> = {
    readonly chain: C;
    readonly address: UniversalOrNative<C>;
};
export declare function registerNative<P extends Platform>(platform: P, ctr: NativeAddressCtr): void;
export declare function nativeIsRegistered<C extends Chain>(chain: C): boolean;
/** Parse an address into its NativeAddress representation */
export declare function toNative<C extends Chain>(chain: C, ua: UniversalAddress | string | Uint8Array): NativeAddress<C>;
export declare function toUniversal<C extends Chain>(chain: C, address: string | Uint8Array): UniversalAddress;
export {};
//# sourceMappingURL=address.d.ts.map