import { guardians } from "@wormhole-foundation/sdk-base";
import { Signature, SignatureUtils, createVAA, deserialize, serialize, } from "../../index.js";
import { keccak256 } from "../../utils.js";
export class MockGuardians {
    setIndex;
    signers;
    constructor(setIndex, keys) {
        this.setIndex = setIndex;
        this.signers = keys.map((key, index) => {
            return { index, key };
        });
    }
    getPublicKeys() {
        return this.signers.map((guardian) => SignatureUtils.toPubkey(guardian.key));
    }
    addSignatures(message, guardianIndices) {
        if (!guardianIndices || guardianIndices.length === 0)
            guardianIndices = Array.from(Array(this.signers.length).keys());
        const signers = this.signers.filter((signer) => guardianIndices.includes(signer.index));
        const vaa = message instanceof Uint8Array ? deserialize("Uint8Array", message) : message;
        if (vaa.guardianSet === 0)
            // @ts-expect-error -- wants readonly
            vaa.guardianSet = this.setIndex;
        if (vaa.guardianSet != this.setIndex)
            throw new Error(`Mismatched guardian set index: ${vaa.guardianSet} != ${this.setIndex}`);
        for (let i = 0; i < signers.length; ++i) {
            const signer = signers.at(i);
            if (!signer)
                throw Error("No signer with index: " + i);
            const signature = SignatureUtils.sign(signer.key, keccak256(vaa.hash));
            const s = new Signature(signature.r, signature.s, signature.recovery);
            // @ts-expect-error -- wants readonly
            vaa.signatures.push({ guardianIndex: i, signature: s });
        }
        return vaa;
    }
    setSignatures(message) {
        const vaa = message instanceof Uint8Array ? deserialize("Uint8Array", message) : message;
        // @ts-expect-error -- wants readonly
        vaa.signatures = [];
        return this.addSignatures(vaa);
    }
}
export class MockEmitter {
    chain;
    address;
    sequence;
    constructor(emitterAddress, chain, startSequence) {
        this.chain = chain;
        this.address = emitterAddress;
        this.sequence = startSequence == undefined ? 0n : startSequence;
    }
    publishMessage(nonce, payload, consistencyLevel, timestamp, uptickSequence = true) {
        if (uptickSequence) {
            ++this.sequence;
        }
        return serialize(createVAA("Uint8Array", {
            guardianSet: 0,
            signatures: [],
            nonce: nonce,
            timestamp: timestamp ?? 0,
            sequence: this.sequence,
            emitterChain: this.chain,
            emitterAddress: this.address,
            consistencyLevel: consistencyLevel,
            payload: payload,
        }));
    }
}
export const devnetGuardianSet = () => new MockGuardians(0, [guardians.devnetGuardianPrivateKey]);
//# sourceMappingURL=guardian.js.map