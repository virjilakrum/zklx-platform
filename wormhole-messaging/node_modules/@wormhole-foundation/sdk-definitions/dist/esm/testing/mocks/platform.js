import { PlatformContext } from "./../../index.js";
import { MockChain } from "./chain.js";
import { MockRpc } from "./rpc.js";
export function mockPlatformFactory(platform, config) {
    class ConcreteMockPlatform extends MockPlatform {
        static _platform = platform;
        constructor(network, _config) {
            super(network, _config ? _config : config);
        }
    }
    // @ts-ignore
    return ConcreteMockPlatform;
}
// Note: don't use this directly, instead create a ConcreteMockPlatform with the
// mockPlatformFactory
export class MockPlatform extends PlatformContext {
    constructor(network, config) {
        super(network, config);
    }
    static getProtocol(protocol) {
        throw new Error("Method not implemented.");
    }
    // static nativeTokenId<C extends PlatformToChains<P>>(chain: C): TokenId<C> {
    //   throw new Error("Method not implemented.");
    // }
    // static isNativeTokenId<C extends PlatformToChains<P>>(chain: C, tokenId: TokenId<C>): boolean {
    //   throw new Error("Method not implemented.");
    // }
    // static isSupportedChain(chain: Chain): boolean {
    //   throw new Error("Method not implemented.");
    // }
    // static getDecimals<C extends PlatformToChains<P>>(
    //   chain: C,
    //   rpc: RpcConnection<P>,
    //   token: TokenAddress<P>,
    // ): Promise<bigint> {
    //   throw new Error("Method not implemented.");
    // }
    // static getBalance<C extends PlatformToChains<P>>(
    //   chain: C,
    //   rpc: RpcConnection<P>,
    //   walletAddr: string,
    //   token: TokenAddress<P>,
    // ): Promise<bigint | null> {
    //   throw new Error("Method not implemented.");
    // }
    // static getBalances<C extends PlatformToChains<P>>(
    //   chain: C,
    //   rpc: RpcConnection<Platform>,
    //   walletAddress: string,
    //   tokens: TokenAddress<P>[],
    // ): Promise<Balances> {
    //   throw new Error("method not implemented");
    // }
    // static async getTokenBalance<C extends PlatformToChains<P>>(
    //   chain: C,
    //   rpc: RpcConnection<P>,
    //   walletAddr: string,
    //   token: TokenId<C>,
    // ): Promise<bigint | null> {
    //   return 10n;
    // }
    // static getProtocolInitializer<PN extends ProtocolName>(
    //   protocol: PN,
    // ): ProtocolInitializer<P, PN> {
    //   throw new Error("Method not implemented.");
    // }
    // static async sendWait(chain: Chain, rpc: RpcConnection<P>, stxns: any[]): Promise<TxHash[]> {
    //   throw new Error("Method not implemented.");
    // }
    getChain(chain) {
        // @ts-ignore
        if (chain in this.config)
            return new MockChain(chain, this);
        throw new Error("No configuration available for chain: " + chain);
    }
    getRpc(chain) {
        return new MockRpc(chain);
    }
    async getWrappedAsset(chain, rpc, token) {
        throw new Error("Method not implemented.");
    }
    async getTokenDecimals(rpc, token) {
        return 8n;
    }
    async getNativeBalance(rpc, walletAddr) {
        return 0n;
    }
    getDecimals(chain, rpc, token) {
        throw new Error("Method not implemented.");
    }
}
//# sourceMappingURL=platform.js.map