import { encoding, serializeLayout, throws } from "@wormhole-foundation/sdk-base";
import { toNative } from "./address.js";
import { sha256, sha512_256 } from "./utils.js";
const algorandAppIdLayout = [
    { name: "appIdPrefix", binary: "bytes", custom: encoding.bytes.encode("appID"), omit: true },
    { name: "appId", binary: "uint", size: 8 },
];
/**
 * The UniversalAddress represents an address that has been parsed into its
 * byte representation and possibly modified to ensure it is exactly 32 bytes long
 */
export class UniversalAddress {
    static byteSize = 32;
    static type = "Universal";
    address;
    constructor(address, format = "hex") {
        this.address =
            typeof address === "string" ? UniversalAddress.stringToUint8Array(address, format) : address;
    }
    toNative(chainOrPlatform) {
        return toNative(chainOrPlatform, this.toUint8Array());
    }
    unwrap() {
        return this.address;
    }
    toString() {
        return encoding.hex.encode(this.address, true);
    }
    toUint8Array() {
        return this.address;
    }
    toUniversalAddress() {
        return this;
    }
    equals(other) {
        return encoding.bytes.equals(this.address, other.address);
    }
    static isValidAddress(address, format = "hex") {
        return !throws(() => UniversalAddress.stringToUint8Array(address, format));
    }
    static instanceof(address) {
        return (typeof address === "object" &&
            "constructor" in address &&
            address.constructor.type === UniversalAddress.type);
    }
    static stringToUint8Array(address, format) {
        const decoded = (() => {
            switch (format) {
                case "hex":
                    if (![40, 2 * this.byteSize].includes(address.length - (address.startsWith("0x") ? 2 : 0)))
                        throw new Error(`string ${address} has invalid length for format ${format}`);
                    return encoding.hex.decode(address);
                case "base58":
                    return encoding.b58.decode(address);
                case "bech32":
                    return encoding.bech32.decodeToBytes(address).bytes;
                case "algorandAppId":
                    return sha512_256(serializeLayout(algorandAppIdLayout, { appId: BigInt(address) }));
                case "sha256":
                    return sha256(address);
            }
        })();
        if (decoded.length > UniversalAddress.byteSize)
            throw new Error(`string ${address} has invalid length for format ${format}`);
        return decoded.length < UniversalAddress.byteSize
            ? encoding.bytes.zpad(decoded, UniversalAddress.byteSize)
            : decoded;
    }
}
//# sourceMappingURL=universalAddress.js.map