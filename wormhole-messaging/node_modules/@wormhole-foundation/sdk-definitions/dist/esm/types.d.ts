import type { Chain, ChainToPlatform, Network, Platform, PlatformToChains } from "@wormhole-foundation/sdk-base";
import { explorer } from "@wormhole-foundation/sdk-base";
import type { ChainTokens, Token } from "@wormhole-foundation/sdk-base";
import type { ChainAddress, UniversalOrNative } from "./address.js";
import type { Contracts } from "./contracts.js";
/** Alias for string, used to look up transaction details */
export type TxHash = string;
/** The sequence number assigned to a given message by the core bridge */
export type SequenceId = bigint;
/** A signed transaction in its canonical format */
export type SignedTx = any;
/**
 * An address representing an asset
 * @remarks the string literal 'native' is used to represent the native gas token
 */
export type TokenAddress<C extends Chain> = UniversalOrNative<C> | "native";
export declare function isNative(thing: any): thing is "native";
/**  Utility to create a TokenId with the address set to the string "native" */
export declare function nativeTokenId<C extends Chain>(chain: C): TokenId<C>;
/**
 * A TokenId is a unique identifier for a token on a given chain
 *
 * @interface TokenId
 */
export type TokenId<C extends Chain = Chain> = {
    chain: C;
    address: TokenAddress<C>;
};
export declare function isTokenId<C extends Chain>(thing: any): thing is TokenId<C>;
export declare function isSameToken(a: TokenId, b: TokenId): boolean;
/** Utility function to return the string representation of a ChainAddress or TokenId */
export declare function canonicalAddress(ca: ChainAddress | TokenId): string;
export declare function universalAddress(ca: ChainAddress | TokenId): string;
/**
 * Given a token id, address, or the const string 'native' return
 * a TokenId representing either the token itself or the wrapped version
 */
export declare function resolveWrappedToken<N extends Network, C extends Chain>(network: N, chain: C, token: TokenId<C> | TokenAddress<C>): [boolean, TokenId<C>];
export type Balances = {
    [key: string]: bigint | null;
};
/**  Fully qualified Transaction ID */
export type TransactionId<C extends Chain = Chain> = {
    chain: C;
    txid: TxHash;
};
export declare function isTransactionIdentifier(thing: TransactionId | any): thing is TransactionId;
/** Configuration for a given Chain */
export type ChainConfig<N extends Network, C extends Chain> = {
    key: C;
    network: N;
    platform: ChainToPlatform<C>;
    /** Wormhole Chain Id for this chain */
    chainId: number;
    /** Contract addresses for this chain */
    contracts: Contracts;
    /** Number of blocks before a transaction is considered final */
    finalityThreshold: number;
    /** Average block time in milliseconds */
    blockTime: number;
    /** Number of decimal places for the native gas token (e.g. 18 for ETH) */
    nativeTokenDecimals: number;
    /**
     * Native chain id may be eip155 or genesis hash or network moninker or something else
     * depending on the platform
     */
    nativeChainId: string | bigint;
    /**
     * Rpc address for this chain
     */
    rpc: string;
    tokenMap?: ChainTokens;
    wrappedNative?: Token;
    explorer?: explorer.ExplorerSettings;
};
export type ChainsConfig<N extends Network, P extends Platform> = {
    [K in PlatformToChains<P>]?: ChainConfig<N, K>;
};
export declare function buildConfig<N extends Network>(n: N): ChainsConfig<N, Platform>;
//# sourceMappingURL=types.d.ts.map