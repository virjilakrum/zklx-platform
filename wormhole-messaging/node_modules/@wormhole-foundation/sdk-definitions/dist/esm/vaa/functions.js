import { deserializeLayout, encoding, layoutDiscriminator, serializeLayout, } from "@wormhole-foundation/sdk-base";
import { composeLiteral, payloadFactory } from "./registration.js";
import { baseLayout, decomposeLiteral, envelopeLayout, headerLayout } from "./vaa.js";
import { sequenceItem, universalAddressItem } from "../layout-items/index.js";
import { keccak256 } from "../utils.js";
export function getPayloadLayout(layoutLiteral) {
    const layout = payloadFactory.get(layoutLiteral);
    if (!layout)
        throw new Error(`No layout registered for payload type ${layoutLiteral}`);
    return layout;
}
export function payloadLiteralToPayloadItemLayout(payloadLiteral) {
    return {
        name: "payload",
        binary: "bytes",
        ...(payloadLiteral === "Uint8Array" ? {} : { layout: getPayloadLayout(payloadLiteral) }),
    };
}
/**
 * serialize a VAA to a Uint8Array
 * @param vaa the VAA to serialize
 * @returns a Uint8Array representation of the VAA
 * @throws if the VAA is not valid
 */
export function serialize(vaa) {
    const layout = [
        ...baseLayout,
        payloadLiteralToPayloadItemLayout(vaa.payloadLiteral),
    ];
    return serializeLayout(layout, vaa);
}
/**
 * serialize a VAA payload to a Uint8Array
 *
 * @param payloadLiteral The payload literal to use for serialization
 * @param payload  The dynamic properties to include in the payload
 * @returns a Uint8Array representation of the VAA Payload
 */
export function serializePayload(payloadLiteral, payload) {
    if (payloadLiteral === "Uint8Array")
        return payload;
    const layout = getPayloadLayout(payloadLiteral);
    return serializeLayout(layout, payload);
}
export function payloadDiscriminator(payloadLiterals, allowAmbiguous) {
    const literals = (() => {
        if (Array.isArray(payloadLiterals[0]))
            return payloadLiterals.flatMap(([protocol, payloadNames]) => payloadNames.map((name) => composeLiteral(protocol, name)));
        if (typeof payloadLiterals[1] === "string")
            return payloadLiterals;
        const [protocol, payloadNames] = payloadLiterals;
        return payloadNames.map((name) => composeLiteral(protocol, name));
    })();
    const discriminator = layoutDiscriminator(literals.map((literal) => getPayloadLayout(literal)), !!allowAmbiguous);
    return ((data) => {
        if (typeof data === "string")
            data = encoding.hex.decode(data);
        const cands = discriminator(data);
        return Array.isArray(cands)
            ? cands.map((c) => literals[c])
            : cands !== null
                ? literals[cands]
                : null;
    });
}
/**
 * deserialize a VAA from a Uint8Array
 *
 * @param payloadDet The payload literal or discriminator to use for deserialization
 * @param data the data to deserialize
 * @returns a VAA object with the given payload literal or discriminator
 * @throws if the data is not a valid VAA
 */
export function deserialize(payloadDet, data) {
    if (typeof data === "string")
        data = encoding.hex.decode(data);
    const [header, envelopeOffset] = deserializeLayout(headerLayout, data, { consumeAll: false });
    //ensure that guardian signature indicies are unique and in ascending order - see:
    //https://github.com/wormhole-foundation/wormhole/blob/8e0cf4c31f39b5ba06b0f6cdb6e690d3adf3d6a3/ethereum/contracts/Messages.sol#L121
    for (let i = 1; i < header.signatures.length; ++i)
        if (header.signatures[i].guardianIndex <= header.signatures[i - 1].guardianIndex)
            throw new Error("Guardian signatures must be in ascending order of guardian set index");
    const [envelope, payloadOffset] = deserializeLayout(envelopeLayout, data, {
        offset: envelopeOffset,
        consumeAll: false,
    });
    const [payloadLiteral, payload] = typeof payloadDet === "string"
        ? [
            payloadDet,
            deserializePayload(payloadDet, data, payloadOffset),
        ]
        : deserializePayload(payloadDet, data, payloadOffset);
    const [protocolName, payloadName] = decomposeLiteral(payloadLiteral);
    const hash = keccak256(data.slice(envelopeOffset));
    return {
        protocolName,
        payloadName,
        payloadLiteral,
        ...header,
        ...envelope,
        payload,
        hash,
    };
}
/**
 * deserialize a payload from a Uint8Array
 *
 * @param payloadDet the payload literal or discriminator to use for deserialization
 * @param data the data to deserialize
 * @param offset the offset to start deserializing from
 * @returns the deserialized payload
 * @throws if the data is not a valid payload
 */
export function deserializePayload(payloadDet, data, offset = 0) {
    return (() => {
        if (typeof data === "string")
            data = encoding.hex.decode(data);
        if (payloadDet === "Uint8Array")
            return data.slice(offset);
        if (typeof payloadDet === "string")
            return deserializeLayout(getPayloadLayout(payloadDet), data, { offset });
        //kinda unfortunate that we have to slice here, future improvement would be passing an optional
        //  offset to the discriminator
        const candidate = payloadDet(data.slice(offset));
        if (candidate === null)
            throw new Error(`Encoded data does not match any of the given payload types - ${data}`);
        return [candidate, deserializeLayout(getPayloadLayout(candidate), data, { offset })];
    })();
}
/**
 * Attempt to deserialize a payload from a Uint8Array using all registered layouts
 *
 * @param data the data to deserialize
 * @returns an array of all possible deserialized payloads
 * @throws if the data is not a valid payload
 */
export const exhaustiveDeserialize = (() => {
    const rebuildDiscrimininator = () => {
        const layoutLiterals = Array.from(payloadFactory.keys());
        const layouts = layoutLiterals.map((l) => payloadFactory.get(l));
        return [layoutLiterals, layoutDiscriminator(layouts, true)];
    };
    let layoutLiterals = [];
    return (data) => {
        if (payloadFactory.size !== layoutLiterals.length)
            [layoutLiterals] = rebuildDiscrimininator();
        const candidates = layoutLiterals;
        return candidates.reduce((acc, literal) => {
            try {
                acc.push([literal, deserializePayload(literal, data)]);
            }
            catch { }
            return acc;
        }, []);
    };
})();
/**
 * Blindly deserialize a payload from a Uint8Array
 *
 * @param data the data to deserialize
 * @returns an array of all possible deserialized payloads
 * @throws if the data is not a valid payload
 */
export const blindDeserializePayload = (() => {
    const rebuildDiscrimininator = () => {
        const layoutLiterals = Array.from(payloadFactory.keys());
        const layouts = layoutLiterals.map((l) => payloadFactory.get(l));
        return [layoutLiterals, layoutDiscriminator(layouts, true)];
    };
    let layoutLiterals = [];
    let discriminator = (_) => [];
    return (data) => {
        if (payloadFactory.size !== layoutLiterals.length)
            [layoutLiterals, discriminator] = rebuildDiscrimininator();
        if (typeof data === "string")
            data = encoding.hex.decode(data);
        const candidates = discriminator(data).map((c) => layoutLiterals[c]);
        return candidates.reduce((acc, literal) => {
            try {
                acc.push([literal, deserializePayload(literal, data)]);
            }
            catch { }
            return acc;
        }, []);
    };
})();
/**
 * Allows deserialization of a VAA with a chain id that is not yet known
 * by the SDK.
 * @param data The raw VAA to deserialize
 * @returns an object with the VAA data and the payload as a Uint8Array
 */
export const deserializeUnknownVaa = (data) => {
    const envelopeLayout = [
        { name: "timestamp", binary: "uint", size: 4 },
        { name: "nonce", binary: "uint", size: 4 },
        // Note: This is the only difference currently between this and
        // the envelopeLayout defined in vaa.ts where chain is typechecked
        { name: "emitterChain", binary: "uint", size: 2 },
        { name: "emitterAddress", ...universalAddressItem },
        { name: "sequence", ...sequenceItem },
        { name: "consistencyLevel", binary: "uint", size: 1 },
    ];
    const [header, offset] = deserializeLayout(headerLayout, data, { consumeAll: false });
    const [envelope, offset2] = deserializeLayout(envelopeLayout, data, {
        offset: offset,
        consumeAll: false,
    });
    return {
        ...header,
        ...envelope,
        payload: data.slice(offset2),
    };
};
//# sourceMappingURL=functions.js.map