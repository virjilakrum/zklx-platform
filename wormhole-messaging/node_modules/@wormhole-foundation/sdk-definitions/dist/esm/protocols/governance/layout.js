import { column, encoding, constMap, platformToChains, enumItem, calcStaticLayoutSize, deserializeLayout, serializeLayout } from "@wormhole-foundation/sdk-base";
import { modificationKinds } from "./globalAccountant.js";
import { amountItem, chainItem, sequenceItem, fixedLengthStringItem, guardianSetItem, universalAddressItem, stringConversion } from "../../layout-items/index.js";
import { registerPayloadTypes } from "../../vaa/index.js";
const rawEvmAddressItem = {
    binary: "bytes",
    size: 20,
    custom: {
        to: (encoded) => encoding.hex.encode(encoded, true),
        from: (decoded) => encoding.hex.decode(decoded),
    }
};
const contractActions = [
    ["UpgradeContract", [false, [{ name: "newContract", ...universalAddressItem }]]],
    ["RegisterChain", [true, [
                { name: "foreignChain", ...chainItem() },
                { name: "foreignAddress", ...universalAddressItem },
            ]]
    ],
    //a word on the chainId for RecoverChainId:
    //The EVM contracts accept an arbitrary number when recovering chain ids however I don't think you
    //  ever want to set the wormhole chain id of a contract (even on a fork) to 0 since this would
    //  mean that afterwards all the checks that use `vaa.chainId == this.chainId` in the contract
    //  would suddenly accept "broadcast VAAs" which is almost certainly not what's intended.
    //TODO should we define governance actions that are platform specific here?
    //     (reason against: we might want to deserialize types that are specific to the platform)
    ["RecoverChainId", [false, [
                { name: "evmChainId", binary: "uint", size: 32 },
                { name: "newChainId", ...chainItem({ allowedChains: platformToChains("Evm") }) },
            ]]
    ],
    ["GuardianSetUpgrade", [true, [
                { name: "guardianSet", ...guardianSetItem },
                { name: "guardians", binary: "array", lengthSize: 1, layout: rawEvmAddressItem },
            ]]
    ],
    ["SetMessageFee", [false, [{ name: "messageFee", binary: "uint", size: 32 }]]],
    ["TransferFees", [true, [
                { name: "amount", binary: "uint", size: 32 },
                { name: "recipient", ...universalAddressItem },
            ]]
    ],
    ["UpdateDefaultProvider", [false, [{ name: "defaultProvider", ...universalAddressItem }]]],
    ["RegisterEmitterAndDomain", [true, [
                { name: "emitterChain", ...chainItem() },
                { name: "emitterAddress", ...universalAddressItem },
                { name: "domain", binary: "uint", size: 4 },
            ]]
    ],
    ["UpdateFinality", [false, [{ name: "finality", binary: "uint", size: 1 }]]],
];
const wasmHashItem = { binary: "bytes", size: 32 };
const wasmContractLayout = [
    { name: "contractAddr", ...universalAddressItem },
    { name: "codeId", binary: "uint", size: 8 },
];
const wormchainActions = [
    ["StoreCode", [false, [{ name: "wasmHash", ...wasmHashItem }]]],
    ["InstantiateContract", [false, [{ name: "instantiationParamsHash", ...wasmHashItem }]]],
    ["MigrateContract", [false, [{ name: "migrationParamsHash", ...wasmHashItem }]]],
    ["AddWasmInstantiateAllowlist", [false, wasmContractLayout]],
    ["DeleteWasmInstantiateAllowlist", [false, wasmContractLayout]],
];
// The Gateway schedule upgrade action is quite a doozy:
// It has a variable length string that has no length prefix as its first item followed by a uint.
// So deserialization has to reason backwards to determine the length.
// see: https://github.com/wormhole-foundation/wormhole/blob/2eb5cca8e72c5379cd444ae3f25a012c1e04ad65/sdk/vaa/payloads.go#L396-L407
// We have to do a bit of footwork here to accomodate this oddity.
const gatewayScheduleUpgradeItem = (() => {
    const stringBytesLayout = (size) => ({ binary: "bytes", size, custom: stringConversion });
    const gsuTailLayout = [
        { name: "height", binary: "uint", size: 8 }
    ];
    const gsuTailSize = calcStaticLayoutSize(gsuTailLayout);
    const gsuLayout = (size) => [
        { name: "name", ...stringBytesLayout(size) },
        ...gsuTailLayout
    ];
    return {
        binary: "bytes",
        custom: {
            to: (encoded) => deserializeLayout(gsuLayout(encoded.length - gsuTailSize), encoded),
            from: (decoded) => serializeLayout(gsuLayout(decoded.name.length), decoded),
        },
    };
})();
const gatewayActions = [
    ["ScheduleUpgrade", [false, gatewayScheduleUpgradeItem]],
    ["CancelUpgrade", [true, []]],
    ["SetIbcComposabilityMwContract", [false, [
                { name: "contractAddress", ...universalAddressItem },
            ]]
    ],
];
const globalAccountantActions = [
    ["ModifyBalance", [false, [
                { name: "sequence", ...sequenceItem },
                { name: "modifiedChain", ...chainItem() },
                { name: "tokenChain", ...chainItem() },
                { name: "tokenAddress", ...universalAddressItem },
                { name: "kind", ...enumItem(modificationKinds) },
                { name: "amount", ...amountItem },
                { name: "reason", ...fixedLengthStringItem(32) }
            ]]
    ],
];
const ibcReceiverActions = [
    ["ActionUpdateChannelChain", [false, [
                { name: "channelId", ...fixedLengthStringItem(64) },
                //TODO previous name was "chainId" which is definitely wrong - check new name
                { name: "channelChain", ...chainItem({ allowedChains: platformToChains("Cosmwasm") }) }
            ]]
    ],
];
const generalPurposeActions = [
    ["GeneralPurposeEvm", [false, [
                { name: "governanceContract", ...rawEvmAddressItem },
                { name: "targetContract", ...rawEvmAddressItem },
                { name: "payload", binary: "bytes", lengthSize: 2 }
            ]]
    ],
    ["GeneralPurposeSolana", [false, [
                { name: "governanceContract", ...universalAddressItem },
                { name: "payload", binary: "bytes" }
            ]]
    ],
];
const actionTuples = [
    ...contractActions,
    ...wormchainActions,
    ...gatewayActions,
    ...globalAccountantActions,
    ...ibcReceiverActions,
    ...generalPurposeActions,
];
const actions = column(actionTuples, 0);
const actionMapping = Object.fromEntries(actionTuples);
const sdkProtocolNameAndGovernanceVaaModuleEntries = [
    ["WormholeCore", "Core"],
    ["TokenBridge", "TokenBridge"],
    ["NftBridge", "NftBridge"],
    ["Relayer", "WormholeRelayer"],
    ["CircleBridge", "CircleIntegration"],
    ["IbcBridge", "IbcTranslator"],
    ["IbcReceiver", "IbcReceiver"],
    ["GlobalAccountant", "GlobalAccountant"],
    ["GeneralPurposeGovernance", "GeneralPurposeGovernance"],
    ["WormchainGovernance", "WasmdModule"],
    ["GatewayGovernance", "GatewayModule"]
];
const sdkProtocolNameToGovernanceVaaModuleMapping = constMap(sdkProtocolNameAndGovernanceVaaModuleEntries);
const protocolConversion = (protocol) => ({
    to: protocol,
    from: (() => {
        const moduleBytesSize = 32;
        const bytes = new Uint8Array(moduleBytesSize);
        const vaaModule = sdkProtocolNameToGovernanceVaaModuleMapping(protocol);
        for (let i = 1; i <= vaaModule.length; ++i)
            bytes[moduleBytesSize - i] = vaaModule.charCodeAt(vaaModule.length - i);
        return bytes;
    })(),
});
const actionConversion = (action, num) => ({
    to: action,
    from: num,
});
const governanceLayout = (protocol, action, num) => [
    { name: "protocol", binary: "bytes", custom: protocolConversion(protocol) },
    { name: "action", binary: "uint", size: 1, custom: actionConversion(action, num) },
    { name: "chain", ...chainItem({ allowNull: actionMapping[action][0] }) },
    { name: "actionArgs", binary: "bytes", layout: actionMapping[action][1] },
];
const governancePayload = (protocol, action, num) => [action, governanceLayout(protocol, action, num)];
const coreBridgePayloads = [
    //see wormhole ethereum/contracts/GovernanceStructs.sol
    //and wormhole solana/bridge/program/src/types.rs
    governancePayload("WormholeCore", "UpgradeContract", 1),
    governancePayload("WormholeCore", "GuardianSetUpgrade", 2),
    governancePayload("WormholeCore", "SetMessageFee", 3),
    governancePayload("WormholeCore", "TransferFees", 4),
    governancePayload("WormholeCore", "RecoverChainId", 5), //only evm
];
const tokenBridgePayloads = [
    //see wormhole ethereum/contracts/bridge/BridgeGovernance.sol
    governancePayload("TokenBridge", "RegisterChain", 1),
    governancePayload("TokenBridge", "UpgradeContract", 2),
    governancePayload("TokenBridge", "RecoverChainId", 3),
];
const nftBridgePayloads = [
    //see wormhole ethereum/contracts/nft/NFTBridgeGovernance.sol
    governancePayload("NftBridge", "RegisterChain", 1),
    governancePayload("NftBridge", "UpgradeContract", 2),
    governancePayload("NftBridge", "RecoverChainId", 3),
];
const relayerPayloads = [
    //see wormhole ethereum/contracts/relayer/wormholeRelayer/WormholeRelayerGovernance.sol
    governancePayload("Relayer", "RegisterChain", 1),
    governancePayload("Relayer", "UpgradeContract", 2),
    governancePayload("Relayer", "UpdateDefaultProvider", 3),
];
const cctpPayloads = [
    //see wormhole-circle-integration evm/src/circle_integration/CircleIntegrationGovernance.sol
    governancePayload("CircleBridge", "UpdateFinality", 1),
    governancePayload("CircleBridge", "RegisterEmitterAndDomain", 2),
    governancePayload("CircleBridge", "UpgradeContract", 3),
];
const ibcBridgePayloads = [
    //see wormhole cosmwasm/contracts/ibc-translator/src/execute.rs submit_update_chain_to_channel_map
    governancePayload("IbcBridge", "ActionUpdateChannelChain", 1),
];
const ibcReceiverPayloads = [
    //see wormhole cosmwasm/contracts/wormchain-ibc-receiver/src/contract.rs
    governancePayload("IbcReceiver", "ActionUpdateChannelChain", 1),
];
const globalAccountantPayloads = [
    //see wormhole cosmwasm/contracts/global-accountant/src/contract.rs handle_accountant_governance_vaa
    governancePayload("GlobalAccountant", "ModifyBalance", 1),
];
const generalPurposeGovernancePayloads = [
    governancePayload("GeneralPurposeGovernance", "GeneralPurposeEvm", 1),
    governancePayload("GeneralPurposeGovernance", "GeneralPurposeSolana", 2),
];
const wormchainGovernancePayloads = [
    //see wormhole wormchain/x/wormhole/keeper/msg_server_wasmd.go
    governancePayload("WormchainGovernance", "StoreCode", 1),
    governancePayload("WormchainGovernance", "InstantiateContract", 2),
    governancePayload("WormchainGovernance", "MigrateContract", 3),
    //see wormhole wormchain/x/wormhole/keeper/msg_server_wasm_instantiate_allowlist.go
    governancePayload("WormchainGovernance", "AddWasmInstantiateAllowlist", 4),
    governancePayload("WormchainGovernance", "DeleteWasmInstantiateAllowlist", 5),
];
const gatewayGovernancePayloads = [
    //see wormhole wormchain/x/wormhole/keeper/msg_server_execute_gateway_governance_vaa.go
    governancePayload("GatewayGovernance", "ScheduleUpgrade", 1),
    governancePayload("GatewayGovernance", "CancelUpgrade", 2),
    governancePayload("GatewayGovernance", "SetIbcComposabilityMwContract", 3),
];
// factory registration:
import "../../registry.js";
registerPayloadTypes("WormholeCore", coreBridgePayloads);
registerPayloadTypes("TokenBridge", tokenBridgePayloads);
registerPayloadTypes("NftBridge", nftBridgePayloads);
registerPayloadTypes("Relayer", relayerPayloads);
registerPayloadTypes("CircleBridge", cctpPayloads);
registerPayloadTypes("IbcBridge", ibcBridgePayloads);
registerPayloadTypes("IbcReceiver", ibcReceiverPayloads);
registerPayloadTypes("GlobalAccountant", globalAccountantPayloads);
registerPayloadTypes("GeneralPurposeGovernance", generalPurposeGovernancePayloads);
registerPayloadTypes("WormchainGovernance", wormchainGovernancePayloads);
registerPayloadTypes("GatewayGovernance", gatewayGovernancePayloads);
//# sourceMappingURL=layout.js.map