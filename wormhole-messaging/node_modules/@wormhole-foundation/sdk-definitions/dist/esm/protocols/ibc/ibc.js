import { encoding, toChain, toChainId } from "@wormhole-foundation/sdk-base";
import "../../registry.js";
export function isGatewayTransferMsg(thing) {
    return thing.gateway_transfer !== undefined;
}
export function isGatewayTransferWithPayloadMsg(thing) {
    return thing.gateway_transfer_with_payload !== undefined;
}
export function isGatewayIbcTransferMsg(thing) {
    return thing.gateway_ibc_token_bridge_payload !== undefined;
}
export function isGatewayTransferDetails(thing) {
    return (thing.token !== undefined &&
        thing.amount !== undefined &&
        thing.from !== undefined &&
        thing.to !== undefined);
}
// Get the underlying payload from a gateway message
// without prefix
export function toGatewayMsg(msg) {
    if (typeof msg === "string")
        msg = JSON.parse(msg);
    if (isGatewayIbcTransferMsg(msg))
        msg = msg.gateway_ibc_token_bridge_payload;
    if (isGatewayTransferMsg(msg))
        return msg.gateway_transfer;
    if (isGatewayTransferWithPayloadMsg(msg))
        return msg.gateway_transfer_with_payload;
    throw new Error(`Unrecognized payload: ${msg}`);
}
export function gatewayTransferMsg(gtd) {
    if (isGatewayTransferDetails(gtd)) {
        // If we've already got a payload, b64 encode it so it works in json
        const _payload = gtd.payload ? encoding.b64.encode(gtd.payload) : undefined;
        // Encode the payload so the gateway contract knows where to forward the
        // newly minted tokens
        return makeGatewayTransferMsg(gtd.to.chain, gtd.to.address.toNative(gtd.to.chain), gtd.fee, gtd.nonce ?? Math.round(Math.random() * 100000), _payload);
    }
    // Encode the payload so the gateway contract knows where to forward the
    // newly minted tokens
    return makeGatewayTransferMsg(toChain(gtd.chain), gtd.recipient, BigInt(gtd.fee), gtd.nonce, gtd.payload);
}
export function makeGatewayTransferMsg(chain, recipient, fee = 0n, nonce, payload) {
    // Address of recipient is b64 encoded Cosmos bech32 address
    // If its already a string, assume its been b64 encoded
    const address = typeof recipient === "string"
        ? recipient
        : // @ts-ignore
            encoding.b64.encode(recipient.toString());
    const common = {
        chain: toChainId(chain),
        recipient: address,
        fee: fee.toString(),
        nonce: nonce,
    };
    const msg = payload
        ? {
            gateway_transfer_with_payload: { ...common, payload: payload },
        }
        : { gateway_transfer: { ...common } };
    return msg;
}
export function isIbcTransferInfo(thing) {
    return (thing.id !== undefined &&
        thing.pending !== undefined &&
        thing.data !== undefined);
}
//# sourceMappingURL=ibc.js.map