"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.devnetGuardianSet = exports.MockEmitter = exports.MockGuardians = void 0;
const sdk_base_1 = require("@wormhole-foundation/sdk-base");
const index_js_1 = require("../../index.js");
const utils_js_1 = require("../../utils.js");
class MockGuardians {
    setIndex;
    signers;
    constructor(setIndex, keys) {
        this.setIndex = setIndex;
        this.signers = keys.map((key, index) => {
            return { index, key };
        });
    }
    getPublicKeys() {
        return this.signers.map((guardian) => index_js_1.SignatureUtils.toPubkey(guardian.key));
    }
    addSignatures(message, guardianIndices) {
        if (!guardianIndices || guardianIndices.length === 0)
            guardianIndices = Array.from(Array(this.signers.length).keys());
        const signers = this.signers.filter((signer) => guardianIndices.includes(signer.index));
        const vaa = message instanceof Uint8Array ? (0, index_js_1.deserialize)("Uint8Array", message) : message;
        if (vaa.guardianSet === 0)
            // @ts-expect-error -- wants readonly
            vaa.guardianSet = this.setIndex;
        if (vaa.guardianSet != this.setIndex)
            throw new Error(`Mismatched guardian set index: ${vaa.guardianSet} != ${this.setIndex}`);
        for (let i = 0; i < signers.length; ++i) {
            const signer = signers.at(i);
            if (!signer)
                throw Error("No signer with index: " + i);
            const signature = index_js_1.SignatureUtils.sign(signer.key, (0, utils_js_1.keccak256)(vaa.hash));
            const s = new index_js_1.Signature(signature.r, signature.s, signature.recovery);
            // @ts-expect-error -- wants readonly
            vaa.signatures.push({ guardianIndex: i, signature: s });
        }
        return vaa;
    }
    setSignatures(message) {
        const vaa = message instanceof Uint8Array ? (0, index_js_1.deserialize)("Uint8Array", message) : message;
        // @ts-expect-error -- wants readonly
        vaa.signatures = [];
        return this.addSignatures(vaa);
    }
}
exports.MockGuardians = MockGuardians;
class MockEmitter {
    chain;
    address;
    sequence;
    constructor(emitterAddress, chain, startSequence) {
        this.chain = chain;
        this.address = emitterAddress;
        this.sequence = startSequence == undefined ? 0n : startSequence;
    }
    publishMessage(nonce, payload, consistencyLevel, timestamp, uptickSequence = true) {
        if (uptickSequence) {
            ++this.sequence;
        }
        return (0, index_js_1.serialize)((0, index_js_1.createVAA)("Uint8Array", {
            guardianSet: 0,
            signatures: [],
            nonce: nonce,
            timestamp: timestamp ?? 0,
            sequence: this.sequence,
            emitterChain: this.chain,
            emitterAddress: this.address,
            consistencyLevel: consistencyLevel,
            payload: payload,
        }));
    }
}
exports.MockEmitter = MockEmitter;
const devnetGuardianSet = () => new MockGuardians(0, [sdk_base_1.guardians.devnetGuardianPrivateKey]);
exports.devnetGuardianSet = devnetGuardianSet;
//# sourceMappingURL=guardian.js.map