import type { Layout } from "@wormhole-foundation/sdk-base";
import type { WormholeRegistry } from "../registry.js";
import type { ProtocolName } from "../protocol.js";
export type LayoutLiteral = keyof WormholeRegistry.PayloadLiteralToLayoutMapping & string;
export type PayloadLiteral = LayoutLiteral | "Uint8Array";
export type LayoutOf<LL extends LayoutLiteral> = LL extends infer V extends LayoutLiteral ? WormholeRegistry.PayloadLiteralToLayoutMapping[V] : never;
type ToLiteralFormat<PN extends ProtocolName, PayloadName extends string> = PN extends null ? PayloadName : `${PN}:${PayloadName}`;
export type ComposeLiteral<ProtocolN extends ProtocolName, PayloadN extends string, Literal> = ToLiteralFormat<ProtocolN, PayloadN> extends infer L extends Literal ? L : never;
export declare const composeLiteral: <ProtocolN extends keyof WormholeRegistry.ProtocolToInterfaceMapping<"Mainnet" | "Testnet" | "Devnet", "Solana" | "Ethereum" | "Terra" | "Bsc" | "Polygon" | "Avalanche" | "Oasis" | "Algorand" | "Aurora" | "Fantom" | "Karura" | "Acala" | "Klaytn" | "Celo" | "Near" | "Moonbeam" | "Neon" | "Terra2" | "Injective" | "Osmosis" | "Sui" | "Aptos" | "Arbitrum" | "Optimism" | "Gnosis" | "Pythnet" | "Xpla" | "Btc" | "Base" | "Sei" | "Rootstock" | "Scroll" | "Mantle" | "Blast" | "Xlayer" | "Linea" | "Berachain" | "Seievm" | "Wormchain" | "Cosmoshub" | "Evmos" | "Kujira" | "Neutron" | "Celestia" | "Stargaze" | "Seda" | "Dymension" | "Provenance" | "Sepolia" | "ArbitrumSepolia" | "BaseSepolia" | "OptimismSepolia" | "Holesky" | "PolygonSepolia">, PayloadN extends string>(protocol: ProtocolN, payloadName: PayloadN) => ComposeLiteral<ProtocolN, PayloadN, PayloadLiteral>;
export declare const payloadFactory: Map<LayoutLiteral, Layout>;
export declare function registerPayloadType(protocol: ProtocolName, name: string, layout: Layout): void;
type AtLeast1<T> = readonly [T, ...T[]];
export type NamedPayloads = AtLeast1<readonly [string, Layout]>;
export type RegisterPayloadTypes<ProtocolN extends ProtocolName, NP extends NamedPayloads> = {
    readonly [E in NP[number] as ToLiteralFormat<ProtocolN, E[0]>]: E[1];
};
export declare function registerPayloadTypes(protocol: ProtocolName, payloads: NamedPayloads): void;
export {};
//# sourceMappingURL=registration.d.ts.map