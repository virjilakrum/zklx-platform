import type { ComposeLiteral, LayoutLiteral, LayoutOf, PayloadLiteral } from "./registration.js";
import type { DistributiveVAA, LayoutLiteralToPayload, Payload, VAA } from "./vaa.js";
import type { ProtocolName } from "../protocol.js";
export declare function getPayloadLayout<LL extends LayoutLiteral>(layoutLiteral: LL): LayoutOf<LL>;
export type PayloadLiteralToPayloadItemLayout<PL extends PayloadLiteral> = PL extends infer V ? V extends LayoutLiteral ? {
    name: "payload";
    binary: "bytes";
    layout: LayoutOf<V>;
} : V extends "Uint8Array" ? {
    name: "payload";
    binary: "bytes";
} : never : never;
export declare function payloadLiteralToPayloadItemLayout<PL extends PayloadLiteral>(payloadLiteral: PL): PayloadLiteralToPayloadItemLayout<PL>;
/**
 * serialize a VAA to a Uint8Array
 * @param vaa the VAA to serialize
 * @returns a Uint8Array representation of the VAA
 * @throws if the VAA is not valid
 */
export declare function serialize<PL extends PayloadLiteral>(vaa: VAA<PL>): Uint8Array;
/**
 * serialize a VAA payload to a Uint8Array
 *
 * @param payloadLiteral The payload literal to use for serialization
 * @param payload  The dynamic properties to include in the payload
 * @returns a Uint8Array representation of the VAA Payload
 */
export declare function serializePayload<PL extends PayloadLiteral>(payloadLiteral: PL, payload: Payload<PL>): Uint8Array;
type AtLeast1<T> = readonly [T, ...T[]];
type AtLeast2<T> = readonly [T, T, ...T[]];
type Byteish = Uint8Array | string;
export type PayloadDiscriminator<LL extends LayoutLiteral = LayoutLiteral, AllowAmbiguous extends boolean = false> = (data: Byteish) => AllowAmbiguous extends false ? LL | null : readonly LL[];
type PayloadGroup = readonly [ProtocolName, AtLeast1<string>];
type PayloadGroupToLayoutLiterals<PG extends PayloadGroup> = ComposeLiteral<PG[0], PG[1][number], LayoutLiteral>;
type PayloadGroupsToLayoutLiteralsRecursive<PGA extends readonly PayloadGroup[]> = PGA extends readonly [infer PG extends PayloadGroup, ...infer T extends readonly PayloadGroup[]] ? PayloadGroupToLayoutLiterals<PG> | PayloadGroupsToLayoutLiteralsRecursive<T> : never;
type PayloadGroupsToLayoutLiterals<PGA extends readonly PayloadGroup[]> = PayloadGroupsToLayoutLiteralsRecursive<PGA> extends infer Value extends LayoutLiteral ? Value : never;
type LLDtoLLs<LLD extends AtLeast2<LayoutLiteral> | readonly [ProtocolName, AtLeast2<string>] | AtLeast2<PayloadGroup>> = LLD extends AtLeast2<LayoutLiteral> ? LLD[number] : LLD extends readonly [ProtocolName, AtLeast2<string>] ? PayloadGroupToLayoutLiterals<LLD> : LLD extends AtLeast2<PayloadGroup> ? PayloadGroupsToLayoutLiterals<LLD> : never;
export declare function payloadDiscriminator<const LLD extends AtLeast2<LayoutLiteral> | readonly [ProtocolName, AtLeast2<string>] | AtLeast2<PayloadGroup>, B extends boolean = false>(payloadLiterals: LLD, allowAmbiguous?: B): PayloadDiscriminator<LLDtoLLs<LLD>, B>;
type ExtractLiteral<T> = T extends PayloadDiscriminator<infer LL> ? LL : T;
/**
 * deserialize a VAA from a Uint8Array
 *
 * @param payloadDet The payload literal or discriminator to use for deserialization
 * @param data the data to deserialize
 * @returns a VAA object with the given payload literal or discriminator
 * @throws if the data is not a valid VAA
 */
export declare function deserialize<T extends PayloadLiteral | PayloadDiscriminator>(payloadDet: T, data: Byteish): DistributiveVAA<ExtractLiteral<T>>;
type DeserializedPair<LL extends LayoutLiteral = LayoutLiteral> = LL extends LayoutLiteral ? readonly [LL, LayoutLiteralToPayload<LL>] : never;
type DeserializePayloadReturn<T> = T extends infer PL extends PayloadLiteral ? Payload<PL> : T extends PayloadDiscriminator<infer LL> ? DeserializedPair<LL> : never;
/**
 * deserialize a payload from a Uint8Array
 *
 * @param payloadDet the payload literal or discriminator to use for deserialization
 * @param data the data to deserialize
 * @param offset the offset to start deserializing from
 * @returns the deserialized payload
 * @throws if the data is not a valid payload
 */
export declare function deserializePayload<T extends PayloadLiteral | PayloadDiscriminator>(payloadDet: T, data: Byteish, offset?: number): DeserializePayloadReturn<T>;
/**
 * Attempt to deserialize a payload from a Uint8Array using all registered layouts
 *
 * @param data the data to deserialize
 * @returns an array of all possible deserialized payloads
 * @throws if the data is not a valid payload
 */
export declare const exhaustiveDeserialize: (data: Byteish) => readonly DeserializedPair[];
/**
 * Blindly deserialize a payload from a Uint8Array
 *
 * @param data the data to deserialize
 * @returns an array of all possible deserialized payloads
 * @throws if the data is not a valid payload
 */
export declare const blindDeserializePayload: (data: Byteish) => readonly DeserializedPair[];
/**
 * Allows deserialization of a VAA with a chain id that is not yet known
 * by the SDK.
 * @param data The raw VAA to deserialize
 * @returns an object with the VAA data and the payload as a Uint8Array
 */
export declare const deserializeUnknownVaa: (data: Uint8Array) => {
    payload: Uint8Array;
    timestamp: number;
    nonce: number;
    emitterChain: number;
    emitterAddress: import("../universalAddress.js").UniversalAddress;
    sequence: bigint;
    consistencyLevel: number;
    guardianSet: number;
    signatures: readonly {
        readonly guardianIndex: number;
        readonly signature: import("../signature.js").Signature;
    }[];
};
export {};
//# sourceMappingURL=functions.d.ts.map