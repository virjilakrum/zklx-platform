import type { LayoutToType } from "@wormhole-foundation/sdk-base";
import type { LayoutLiteral, PayloadLiteral, LayoutOf, ComposeLiteral } from "./registration.js";
import type { ProtocolName } from "../protocol.js";
export type LayoutLiteralToPayload<LL extends LayoutLiteral> = LayoutToType<LayoutOf<LL>>;
export type Payload<PL extends PayloadLiteral> = PL extends LayoutLiteral ? LayoutLiteralToPayload<PL> : Uint8Array;
export type DecomposeLiteral<PL extends PayloadLiteral> = PL extends `${infer Protocol}:${infer LayoutName}` ? [Protocol, LayoutName] : [null, PL];
export declare function decomposeLiteral<PL extends PayloadLiteral>(payloadLiteral: PL): DecomposeLiteral<PL>;
export declare const headerLayout: readonly [{
    readonly name: "version";
    readonly binary: "uint";
    readonly size: 1;
    readonly custom: 1;
    readonly omit: true;
}, {
    readonly binary: "uint";
    readonly size: 4;
    readonly name: "guardianSet";
}, {
    readonly name: "signatures";
    readonly binary: "array";
    readonly lengthSize: 1;
    readonly layout: readonly [{
        readonly name: "guardianIndex";
        readonly binary: "uint";
        readonly size: 1;
    }, {
        readonly binary: "bytes";
        readonly layout: readonly [{
            readonly name: "r";
            readonly binary: "uint";
            readonly size: 32;
        }, {
            readonly name: "s";
            readonly binary: "uint";
            readonly size: 32;
        }, {
            readonly name: "v";
            readonly binary: "uint";
            readonly size: 1;
        }];
        readonly custom: {
            readonly to: (val: {
                readonly r: bigint;
                readonly s: bigint;
                readonly v: number;
            }) => import("../signature.js").Signature;
            readonly from: (val: import("../signature.js").Signature) => {
                r: bigint;
                s: bigint;
                v: number;
            };
        };
        readonly name: "signature";
    }];
}];
export declare const envelopeLayout: readonly [{
    readonly name: "timestamp";
    readonly binary: "uint";
    readonly size: 4;
}, {
    readonly name: "nonce";
    readonly binary: "uint";
    readonly size: 4;
}, {
    readonly custom: {
        to: (val: number) => "Solana" | "Ethereum" | "Terra" | "Bsc" | "Polygon" | "Avalanche" | "Oasis" | "Algorand" | "Aurora" | "Fantom" | "Karura" | "Acala" | "Klaytn" | "Celo" | "Near" | "Moonbeam" | "Neon" | "Terra2" | "Injective" | "Osmosis" | "Sui" | "Aptos" | "Arbitrum" | "Optimism" | "Gnosis" | "Pythnet" | "Xpla" | "Btc" | "Base" | "Sei" | "Rootstock" | "Scroll" | "Mantle" | "Blast" | "Xlayer" | "Linea" | "Berachain" | "Seievm" | "Wormchain" | "Cosmoshub" | "Evmos" | "Kujira" | "Neutron" | "Celestia" | "Stargaze" | "Seda" | "Dymension" | "Provenance" | "Sepolia" | "ArbitrumSepolia" | "BaseSepolia" | "OptimismSepolia" | "Holesky" | "PolygonSepolia";
        from: (val: "Solana" | "Ethereum" | "Terra" | "Bsc" | "Polygon" | "Avalanche" | "Oasis" | "Algorand" | "Aurora" | "Fantom" | "Karura" | "Acala" | "Klaytn" | "Celo" | "Near" | "Moonbeam" | "Neon" | "Terra2" | "Injective" | "Osmosis" | "Sui" | "Aptos" | "Arbitrum" | "Optimism" | "Gnosis" | "Pythnet" | "Xpla" | "Btc" | "Base" | "Sei" | "Rootstock" | "Scroll" | "Mantle" | "Blast" | "Xlayer" | "Linea" | "Berachain" | "Seievm" | "Wormchain" | "Cosmoshub" | "Evmos" | "Kujira" | "Neutron" | "Celestia" | "Stargaze" | "Seda" | "Dymension" | "Provenance" | "Sepolia" | "ArbitrumSepolia" | "BaseSepolia" | "OptimismSepolia" | "Holesky" | "PolygonSepolia") => number;
    };
    readonly binary: "uint";
    readonly size: 2;
    readonly name: "emitterChain";
}, {
    readonly binary: "bytes";
    readonly size: 32;
    readonly custom: {
        to: (val: Uint8Array) => import("../universalAddress.js").UniversalAddress;
        from: (val: import("../universalAddress.js").UniversalAddress) => Uint8Array;
    };
    readonly name: "emitterAddress";
}, {
    readonly binary: "uint";
    readonly size: 8;
    readonly name: "sequence";
}, {
    readonly name: "consistencyLevel";
    readonly binary: "uint";
    readonly size: 1;
}];
export declare const baseLayout: readonly [{
    readonly name: "version";
    readonly binary: "uint";
    readonly size: 1;
    readonly custom: 1;
    readonly omit: true;
}, {
    readonly binary: "uint";
    readonly size: 4;
    readonly name: "guardianSet";
}, {
    readonly name: "signatures";
    readonly binary: "array";
    readonly lengthSize: 1;
    readonly layout: readonly [{
        readonly name: "guardianIndex";
        readonly binary: "uint";
        readonly size: 1;
    }, {
        readonly binary: "bytes";
        readonly layout: readonly [{
            readonly name: "r";
            readonly binary: "uint";
            readonly size: 32;
        }, {
            readonly name: "s";
            readonly binary: "uint";
            readonly size: 32;
        }, {
            readonly name: "v";
            readonly binary: "uint";
            readonly size: 1;
        }];
        readonly custom: {
            readonly to: (val: {
                readonly r: bigint;
                readonly s: bigint;
                readonly v: number;
            }) => import("../signature.js").Signature;
            readonly from: (val: import("../signature.js").Signature) => {
                r: bigint;
                s: bigint;
                v: number;
            };
        };
        readonly name: "signature";
    }];
}, {
    readonly name: "timestamp";
    readonly binary: "uint";
    readonly size: 4;
}, {
    readonly name: "nonce";
    readonly binary: "uint";
    readonly size: 4;
}, {
    readonly custom: {
        to: (val: number) => "Solana" | "Ethereum" | "Terra" | "Bsc" | "Polygon" | "Avalanche" | "Oasis" | "Algorand" | "Aurora" | "Fantom" | "Karura" | "Acala" | "Klaytn" | "Celo" | "Near" | "Moonbeam" | "Neon" | "Terra2" | "Injective" | "Osmosis" | "Sui" | "Aptos" | "Arbitrum" | "Optimism" | "Gnosis" | "Pythnet" | "Xpla" | "Btc" | "Base" | "Sei" | "Rootstock" | "Scroll" | "Mantle" | "Blast" | "Xlayer" | "Linea" | "Berachain" | "Seievm" | "Wormchain" | "Cosmoshub" | "Evmos" | "Kujira" | "Neutron" | "Celestia" | "Stargaze" | "Seda" | "Dymension" | "Provenance" | "Sepolia" | "ArbitrumSepolia" | "BaseSepolia" | "OptimismSepolia" | "Holesky" | "PolygonSepolia";
        from: (val: "Solana" | "Ethereum" | "Terra" | "Bsc" | "Polygon" | "Avalanche" | "Oasis" | "Algorand" | "Aurora" | "Fantom" | "Karura" | "Acala" | "Klaytn" | "Celo" | "Near" | "Moonbeam" | "Neon" | "Terra2" | "Injective" | "Osmosis" | "Sui" | "Aptos" | "Arbitrum" | "Optimism" | "Gnosis" | "Pythnet" | "Xpla" | "Btc" | "Base" | "Sei" | "Rootstock" | "Scroll" | "Mantle" | "Blast" | "Xlayer" | "Linea" | "Berachain" | "Seievm" | "Wormchain" | "Cosmoshub" | "Evmos" | "Kujira" | "Neutron" | "Celestia" | "Stargaze" | "Seda" | "Dymension" | "Provenance" | "Sepolia" | "ArbitrumSepolia" | "BaseSepolia" | "OptimismSepolia" | "Holesky" | "PolygonSepolia") => number;
    };
    readonly binary: "uint";
    readonly size: 2;
    readonly name: "emitterChain";
}, {
    readonly binary: "bytes";
    readonly size: 32;
    readonly custom: {
        to: (val: Uint8Array) => import("../universalAddress.js").UniversalAddress;
        from: (val: import("../universalAddress.js").UniversalAddress) => Uint8Array;
    };
    readonly name: "emitterAddress";
}, {
    readonly binary: "uint";
    readonly size: 8;
    readonly name: "sequence";
}, {
    readonly name: "consistencyLevel";
    readonly binary: "uint";
    readonly size: 1;
}];
type VAABase = LayoutToType<typeof baseLayout>;
/**
 * A VAA is a Verifiable Action Assertion, a signed message that contains
 * information about an action that has occurred on a chain.
 *
 * See {@link https://docs.wormhole.com/wormhole/explore-wormhole/vaa | this link} for more.
 *
 */
export interface VAA<PL extends PayloadLiteral = PayloadLiteral> extends VAABase {
    readonly protocolName: DecomposeLiteral<PL>[0];
    readonly payloadName: DecomposeLiteral<PL>[1];
    readonly payloadLiteral: PL;
    readonly payload: Payload<PL>;
    readonly hash: Uint8Array;
}
export type DistributiveVAA<PL extends PayloadLiteral> = PL extends PayloadLiteral ? VAA<PL> : never;
/** A  utility type that maps a protocol and payload name to its defined structure */
export type ProtocolVAA<PN extends ProtocolName, PayloadName extends string> = ComposeLiteral<PN, PayloadName, PayloadLiteral> extends infer PL extends PayloadLiteral ? DistributiveVAA<PL> : never;
export type DistributivePayload<PL extends PayloadLiteral> = PL extends PayloadLiteral ? Payload<PL> : never;
export type ProtocolPayload<PN extends ProtocolName, PayloadName extends string> = ComposeLiteral<PN, PayloadName, PayloadLiteral> extends infer PL extends PayloadLiteral ? DistributivePayload<PL> : never;
export {};
//# sourceMappingURL=vaa.d.ts.map