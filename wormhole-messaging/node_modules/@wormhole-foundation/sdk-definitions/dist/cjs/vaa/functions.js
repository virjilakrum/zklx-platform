"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeUnknownVaa = exports.blindDeserializePayload = exports.exhaustiveDeserialize = exports.deserializePayload = exports.deserialize = exports.payloadDiscriminator = exports.serializePayload = exports.serialize = exports.payloadLiteralToPayloadItemLayout = exports.getPayloadLayout = void 0;
const sdk_base_1 = require("@wormhole-foundation/sdk-base");
const registration_js_1 = require("./registration.js");
const vaa_js_1 = require("./vaa.js");
const index_js_1 = require("../layout-items/index.js");
const utils_js_1 = require("../utils.js");
function getPayloadLayout(layoutLiteral) {
    const layout = registration_js_1.payloadFactory.get(layoutLiteral);
    if (!layout)
        throw new Error(`No layout registered for payload type ${layoutLiteral}`);
    return layout;
}
exports.getPayloadLayout = getPayloadLayout;
function payloadLiteralToPayloadItemLayout(payloadLiteral) {
    return {
        name: "payload",
        binary: "bytes",
        ...(payloadLiteral === "Uint8Array" ? {} : { layout: getPayloadLayout(payloadLiteral) }),
    };
}
exports.payloadLiteralToPayloadItemLayout = payloadLiteralToPayloadItemLayout;
/**
 * serialize a VAA to a Uint8Array
 * @param vaa the VAA to serialize
 * @returns a Uint8Array representation of the VAA
 * @throws if the VAA is not valid
 */
function serialize(vaa) {
    const layout = [
        ...vaa_js_1.baseLayout,
        payloadLiteralToPayloadItemLayout(vaa.payloadLiteral),
    ];
    return (0, sdk_base_1.serializeLayout)(layout, vaa);
}
exports.serialize = serialize;
/**
 * serialize a VAA payload to a Uint8Array
 *
 * @param payloadLiteral The payload literal to use for serialization
 * @param payload  The dynamic properties to include in the payload
 * @returns a Uint8Array representation of the VAA Payload
 */
function serializePayload(payloadLiteral, payload) {
    if (payloadLiteral === "Uint8Array")
        return payload;
    const layout = getPayloadLayout(payloadLiteral);
    return (0, sdk_base_1.serializeLayout)(layout, payload);
}
exports.serializePayload = serializePayload;
function payloadDiscriminator(payloadLiterals, allowAmbiguous) {
    const literals = (() => {
        if (Array.isArray(payloadLiterals[0]))
            return payloadLiterals.flatMap(([protocol, payloadNames]) => payloadNames.map((name) => (0, registration_js_1.composeLiteral)(protocol, name)));
        if (typeof payloadLiterals[1] === "string")
            return payloadLiterals;
        const [protocol, payloadNames] = payloadLiterals;
        return payloadNames.map((name) => (0, registration_js_1.composeLiteral)(protocol, name));
    })();
    const discriminator = (0, sdk_base_1.layoutDiscriminator)(literals.map((literal) => getPayloadLayout(literal)), !!allowAmbiguous);
    return ((data) => {
        if (typeof data === "string")
            data = sdk_base_1.encoding.hex.decode(data);
        const cands = discriminator(data);
        return Array.isArray(cands)
            ? cands.map((c) => literals[c])
            : cands !== null
                ? literals[cands]
                : null;
    });
}
exports.payloadDiscriminator = payloadDiscriminator;
/**
 * deserialize a VAA from a Uint8Array
 *
 * @param payloadDet The payload literal or discriminator to use for deserialization
 * @param data the data to deserialize
 * @returns a VAA object with the given payload literal or discriminator
 * @throws if the data is not a valid VAA
 */
function deserialize(payloadDet, data) {
    if (typeof data === "string")
        data = sdk_base_1.encoding.hex.decode(data);
    const [header, envelopeOffset] = (0, sdk_base_1.deserializeLayout)(vaa_js_1.headerLayout, data, { consumeAll: false });
    //ensure that guardian signature indicies are unique and in ascending order - see:
    //https://github.com/wormhole-foundation/wormhole/blob/8e0cf4c31f39b5ba06b0f6cdb6e690d3adf3d6a3/ethereum/contracts/Messages.sol#L121
    for (let i = 1; i < header.signatures.length; ++i)
        if (header.signatures[i].guardianIndex <= header.signatures[i - 1].guardianIndex)
            throw new Error("Guardian signatures must be in ascending order of guardian set index");
    const [envelope, payloadOffset] = (0, sdk_base_1.deserializeLayout)(vaa_js_1.envelopeLayout, data, {
        offset: envelopeOffset,
        consumeAll: false,
    });
    const [payloadLiteral, payload] = typeof payloadDet === "string"
        ? [
            payloadDet,
            deserializePayload(payloadDet, data, payloadOffset),
        ]
        : deserializePayload(payloadDet, data, payloadOffset);
    const [protocolName, payloadName] = (0, vaa_js_1.decomposeLiteral)(payloadLiteral);
    const hash = (0, utils_js_1.keccak256)(data.slice(envelopeOffset));
    return {
        protocolName,
        payloadName,
        payloadLiteral,
        ...header,
        ...envelope,
        payload,
        hash,
    };
}
exports.deserialize = deserialize;
/**
 * deserialize a payload from a Uint8Array
 *
 * @param payloadDet the payload literal or discriminator to use for deserialization
 * @param data the data to deserialize
 * @param offset the offset to start deserializing from
 * @returns the deserialized payload
 * @throws if the data is not a valid payload
 */
function deserializePayload(payloadDet, data, offset = 0) {
    return (() => {
        if (typeof data === "string")
            data = sdk_base_1.encoding.hex.decode(data);
        if (payloadDet === "Uint8Array")
            return data.slice(offset);
        if (typeof payloadDet === "string")
            return (0, sdk_base_1.deserializeLayout)(getPayloadLayout(payloadDet), data, { offset });
        //kinda unfortunate that we have to slice here, future improvement would be passing an optional
        //  offset to the discriminator
        const candidate = payloadDet(data.slice(offset));
        if (candidate === null)
            throw new Error(`Encoded data does not match any of the given payload types - ${data}`);
        return [candidate, (0, sdk_base_1.deserializeLayout)(getPayloadLayout(candidate), data, { offset })];
    })();
}
exports.deserializePayload = deserializePayload;
/**
 * Attempt to deserialize a payload from a Uint8Array using all registered layouts
 *
 * @param data the data to deserialize
 * @returns an array of all possible deserialized payloads
 * @throws if the data is not a valid payload
 */
exports.exhaustiveDeserialize = (() => {
    const rebuildDiscrimininator = () => {
        const layoutLiterals = Array.from(registration_js_1.payloadFactory.keys());
        const layouts = layoutLiterals.map((l) => registration_js_1.payloadFactory.get(l));
        return [layoutLiterals, (0, sdk_base_1.layoutDiscriminator)(layouts, true)];
    };
    let layoutLiterals = [];
    return (data) => {
        if (registration_js_1.payloadFactory.size !== layoutLiterals.length)
            [layoutLiterals] = rebuildDiscrimininator();
        const candidates = layoutLiterals;
        return candidates.reduce((acc, literal) => {
            try {
                acc.push([literal, deserializePayload(literal, data)]);
            }
            catch { }
            return acc;
        }, []);
    };
})();
/**
 * Blindly deserialize a payload from a Uint8Array
 *
 * @param data the data to deserialize
 * @returns an array of all possible deserialized payloads
 * @throws if the data is not a valid payload
 */
exports.blindDeserializePayload = (() => {
    const rebuildDiscrimininator = () => {
        const layoutLiterals = Array.from(registration_js_1.payloadFactory.keys());
        const layouts = layoutLiterals.map((l) => registration_js_1.payloadFactory.get(l));
        return [layoutLiterals, (0, sdk_base_1.layoutDiscriminator)(layouts, true)];
    };
    let layoutLiterals = [];
    let discriminator = (_) => [];
    return (data) => {
        if (registration_js_1.payloadFactory.size !== layoutLiterals.length)
            [layoutLiterals, discriminator] = rebuildDiscrimininator();
        if (typeof data === "string")
            data = sdk_base_1.encoding.hex.decode(data);
        const candidates = discriminator(data).map((c) => layoutLiterals[c]);
        return candidates.reduce((acc, literal) => {
            try {
                acc.push([literal, deserializePayload(literal, data)]);
            }
            catch { }
            return acc;
        }, []);
    };
})();
/**
 * Allows deserialization of a VAA with a chain id that is not yet known
 * by the SDK.
 * @param data The raw VAA to deserialize
 * @returns an object with the VAA data and the payload as a Uint8Array
 */
const deserializeUnknownVaa = (data) => {
    const envelopeLayout = [
        { name: "timestamp", binary: "uint", size: 4 },
        { name: "nonce", binary: "uint", size: 4 },
        // Note: This is the only difference currently between this and
        // the envelopeLayout defined in vaa.ts where chain is typechecked
        { name: "emitterChain", binary: "uint", size: 2 },
        { name: "emitterAddress", ...index_js_1.universalAddressItem },
        { name: "sequence", ...index_js_1.sequenceItem },
        { name: "consistencyLevel", binary: "uint", size: 1 },
    ];
    const [header, offset] = (0, sdk_base_1.deserializeLayout)(vaa_js_1.headerLayout, data, { consumeAll: false });
    const [envelope, offset2] = (0, sdk_base_1.deserializeLayout)(envelopeLayout, data, {
        offset: offset,
        consumeAll: false,
    });
    return {
        ...header,
        ...envelope,
        payload: data.slice(offset2),
    };
};
exports.deserializeUnknownVaa = deserializeUnknownVaa;
//# sourceMappingURL=functions.js.map