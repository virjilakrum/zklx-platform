"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignatureUtils = exports.Signature = void 0;
const sdk_base_1 = require("@wormhole-foundation/sdk-base");
const index_js_1 = require("./layout-items/index.js");
const utils_js_1 = require("./utils.js");
/** Signature represents the secp256k1 signature of a Guardian */
class Signature {
    r;
    s;
    v;
    constructor(r, s, v) {
        this.r = r;
        this.s = s;
        this.v = v;
    }
    encode() {
        return (0, sdk_base_1.serializeLayout)(index_js_1.signatureItem, this);
    }
    static decode(data) {
        return (0, sdk_base_1.deserializeLayout)(index_js_1.signatureItem, data);
    }
}
exports.Signature = Signature;
var SignatureUtils;
(function (SignatureUtils) {
    function toPubkey(privateKey) {
        return utils_js_1.secp256k1.getPublicKey(privateKey);
    }
    SignatureUtils.toPubkey = toPubkey;
    function sign(privateKey, hash) {
        if (hash.length != 32)
            throw new Error("hash.length != 32");
        return utils_js_1.secp256k1.sign(hash, privateKey);
    }
    SignatureUtils.sign = sign;
    function validate(signature, publicKey, hash) {
        const { r, s } = signature;
        return utils_js_1.secp256k1.verify({ r, s }, hash, publicKey);
    }
    SignatureUtils.validate = validate;
    function recover(signature, hash) {
        const { r, s, v } = signature;
        const sig = new utils_js_1.secp256k1.Signature(r, s);
        // @ts-ignore -- recovery field is marked readonly
        sig.recovery = v;
        const pubkey = sig.recoverPublicKey(hash);
        return pubkey.toRawBytes();
    }
    SignatureUtils.recover = recover;
})(SignatureUtils || (exports.SignatureUtils = SignatureUtils = {}));
//# sourceMappingURL=signature.js.map