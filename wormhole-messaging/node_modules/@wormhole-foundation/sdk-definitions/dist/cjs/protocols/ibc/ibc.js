"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isIbcTransferInfo = exports.makeGatewayTransferMsg = exports.gatewayTransferMsg = exports.toGatewayMsg = exports.isGatewayTransferDetails = exports.isGatewayIbcTransferMsg = exports.isGatewayTransferWithPayloadMsg = exports.isGatewayTransferMsg = void 0;
const sdk_base_1 = require("@wormhole-foundation/sdk-base");
require("../../registry.js");
function isGatewayTransferMsg(thing) {
    return thing.gateway_transfer !== undefined;
}
exports.isGatewayTransferMsg = isGatewayTransferMsg;
function isGatewayTransferWithPayloadMsg(thing) {
    return thing.gateway_transfer_with_payload !== undefined;
}
exports.isGatewayTransferWithPayloadMsg = isGatewayTransferWithPayloadMsg;
function isGatewayIbcTransferMsg(thing) {
    return thing.gateway_ibc_token_bridge_payload !== undefined;
}
exports.isGatewayIbcTransferMsg = isGatewayIbcTransferMsg;
function isGatewayTransferDetails(thing) {
    return (thing.token !== undefined &&
        thing.amount !== undefined &&
        thing.from !== undefined &&
        thing.to !== undefined);
}
exports.isGatewayTransferDetails = isGatewayTransferDetails;
// Get the underlying payload from a gateway message
// without prefix
function toGatewayMsg(msg) {
    if (typeof msg === "string")
        msg = JSON.parse(msg);
    if (isGatewayIbcTransferMsg(msg))
        msg = msg.gateway_ibc_token_bridge_payload;
    if (isGatewayTransferMsg(msg))
        return msg.gateway_transfer;
    if (isGatewayTransferWithPayloadMsg(msg))
        return msg.gateway_transfer_with_payload;
    throw new Error(`Unrecognized payload: ${msg}`);
}
exports.toGatewayMsg = toGatewayMsg;
function gatewayTransferMsg(gtd) {
    if (isGatewayTransferDetails(gtd)) {
        // If we've already got a payload, b64 encode it so it works in json
        const _payload = gtd.payload ? sdk_base_1.encoding.b64.encode(gtd.payload) : undefined;
        // Encode the payload so the gateway contract knows where to forward the
        // newly minted tokens
        return makeGatewayTransferMsg(gtd.to.chain, gtd.to.address.toNative(gtd.to.chain), gtd.fee, gtd.nonce ?? Math.round(Math.random() * 100000), _payload);
    }
    // Encode the payload so the gateway contract knows where to forward the
    // newly minted tokens
    return makeGatewayTransferMsg((0, sdk_base_1.toChain)(gtd.chain), gtd.recipient, BigInt(gtd.fee), gtd.nonce, gtd.payload);
}
exports.gatewayTransferMsg = gatewayTransferMsg;
function makeGatewayTransferMsg(chain, recipient, fee = 0n, nonce, payload) {
    // Address of recipient is b64 encoded Cosmos bech32 address
    // If its already a string, assume its been b64 encoded
    const address = typeof recipient === "string"
        ? recipient
        : // @ts-ignore
            sdk_base_1.encoding.b64.encode(recipient.toString());
    const common = {
        chain: (0, sdk_base_1.toChainId)(chain),
        recipient: address,
        fee: fee.toString(),
        nonce: nonce,
    };
    const msg = payload
        ? {
            gateway_transfer_with_payload: { ...common, payload: payload },
        }
        : { gateway_transfer: { ...common } };
    return msg;
}
exports.makeGatewayTransferMsg = makeGatewayTransferMsg;
function isIbcTransferInfo(thing) {
    return (thing.id !== undefined &&
        thing.pending !== undefined &&
        thing.data !== undefined);
}
exports.isIbcTransferInfo = isIbcTransferInfo;
//# sourceMappingURL=ibc.js.map