"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniversalAddress = void 0;
const sdk_base_1 = require("@wormhole-foundation/sdk-base");
const address_js_1 = require("./address.js");
const utils_js_1 = require("./utils.js");
const algorandAppIdLayout = [
    { name: "appIdPrefix", binary: "bytes", custom: sdk_base_1.encoding.bytes.encode("appID"), omit: true },
    { name: "appId", binary: "uint", size: 8 },
];
/**
 * The UniversalAddress represents an address that has been parsed into its
 * byte representation and possibly modified to ensure it is exactly 32 bytes long
 */
class UniversalAddress {
    static byteSize = 32;
    static type = "Universal";
    address;
    constructor(address, format = "hex") {
        this.address =
            typeof address === "string" ? UniversalAddress.stringToUint8Array(address, format) : address;
    }
    toNative(chainOrPlatform) {
        return (0, address_js_1.toNative)(chainOrPlatform, this.toUint8Array());
    }
    unwrap() {
        return this.address;
    }
    toString() {
        return sdk_base_1.encoding.hex.encode(this.address, true);
    }
    toUint8Array() {
        return this.address;
    }
    toUniversalAddress() {
        return this;
    }
    equals(other) {
        return sdk_base_1.encoding.bytes.equals(this.address, other.address);
    }
    static isValidAddress(address, format = "hex") {
        return !(0, sdk_base_1.throws)(() => UniversalAddress.stringToUint8Array(address, format));
    }
    static instanceof(address) {
        return (typeof address === "object" &&
            "constructor" in address &&
            address.constructor.type === UniversalAddress.type);
    }
    static stringToUint8Array(address, format) {
        const decoded = (() => {
            switch (format) {
                case "hex":
                    if (![40, 2 * this.byteSize].includes(address.length - (address.startsWith("0x") ? 2 : 0)))
                        throw new Error(`string ${address} has invalid length for format ${format}`);
                    return sdk_base_1.encoding.hex.decode(address);
                case "base58":
                    return sdk_base_1.encoding.b58.decode(address);
                case "bech32":
                    return sdk_base_1.encoding.bech32.decodeToBytes(address).bytes;
                case "algorandAppId":
                    return (0, utils_js_1.sha512_256)((0, sdk_base_1.serializeLayout)(algorandAppIdLayout, { appId: BigInt(address) }));
                case "sha256":
                    return (0, utils_js_1.sha256)(address);
            }
        })();
        if (decoded.length > UniversalAddress.byteSize)
            throw new Error(`string ${address} has invalid length for format ${format}`);
        return decoded.length < UniversalAddress.byteSize
            ? sdk_base_1.encoding.bytes.zpad(decoded, UniversalAddress.byteSize)
            : decoded;
    }
}
exports.UniversalAddress = UniversalAddress;
//# sourceMappingURL=universalAddress.js.map