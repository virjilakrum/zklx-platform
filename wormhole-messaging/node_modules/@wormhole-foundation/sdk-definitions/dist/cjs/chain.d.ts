import type { Chain, ChainToPlatform, Network, Platform, Token, TokenSymbol } from "@wormhole-foundation/sdk-base";
import type { ChainAddress, UniversalOrNative } from "./address.js";
import type { WormholeMessageId } from "./attestation.js";
import type { AutomaticCircleBridge, CircleBridge, Contracts, IbcBridge, PorticoBridge, WormholeCore } from "./index.js";
import type { PlatformContext } from "./platform.js";
import type { ProtocolInstance, ProtocolInterface, ProtocolName } from "./protocol.js";
import type { AutomaticTokenBridge, TokenBridge } from "./protocols/tokenBridge/tokenBridge.js";
import type { RpcConnection } from "./rpc.js";
import type { ChainConfig, SignedTx, TokenAddress, TokenId } from "./types.js";
/**
 * A ChainContext provides a consistent interface for interacting with a chain.
 * It holds the configuration for the chain and cached RPC and protocol clients.
 *
 */
export declare abstract class ChainContext<N extends Network, C extends Chain = Chain, P extends Platform = ChainToPlatform<C>> {
    readonly network: N;
    readonly chain: C;
    readonly config: ChainConfig<N, C>;
    readonly platform: PlatformContext<N, P>;
    protected rpc?: RpcConnection<P>;
    protected protocols: Map<ProtocolName, ProtocolInterface<ProtocolName, N, C>>;
    constructor(chain: C, platform: PlatformContext<N, P>, rpc?: RpcConnection<P>);
    /**
     * Get an RPC connection for this chain, uses the configuration passed in
     * the initial constructor
     *
     * @returns the RPC connection for this chain
     */
    getRpc(): Promise<RpcConnection<P>>;
    /**
     *  Get the number of decimals for a token
     *
     *  @param token the token to get the decimals for
     *  @returns the number of decimals for the token
     */
    getDecimals(token: TokenAddress<C>): Promise<number>;
    /**
     * Get the balance of a token for a given address
     *
     * @param walletAddr the address to get the balance for
     * @param token the token to get the balance for
     * @returns the balance of the token for the address
     *
     */
    getBalance(walletAddr: string, token: TokenAddress<C>): Promise<bigint | null>;
    /**
     * Get the latest block number seen by the chain according to the RPC
     *
     * @returns the latest block number
     */
    getLatestBlock(): Promise<number>;
    /**
     * Get the latest _finalized_ block number seen by the chain according to the RPC
     *
     * @returns the latest finalized block number
     */
    getLatestFinalizedBlock(): Promise<number>;
    /**
     * Parse the Wormhole Core messages from a transaction
     *
     * @param txid the transaction to parse
     * @returns the Wormhole Core messages emitted by the transaction
     */
    parseTransaction(txid: string): Promise<WormholeMessageId[]>;
    /**
     *  Send a transaction and wait for it to be confirmed
     *
     * @param stxns the signed transaction to send
     * @returns the transaction hashes of the sent transactions
     */
    sendWait(stxns: SignedTx[]): Promise<string[]>;
    /**
     * Get the token data from the local cache if available
     * @param symbol the symbol of the token to get
     * @returns the token data if available
     */
    getToken(symbol: TokenSymbol): Token | undefined;
    /**
     * Get the token id of the wrapped token for the native gas token
     *
     * @returns the wrapped token for the native gas token
     */
    getNativeWrappedTokenId(): Promise<TokenId<C>>;
    /**
     * Get the token account for a given address and token
     *
     * @remarks
     * This is really only useful in the context of Solana but in order
     * to provide a consistent interface, we provide it here.
     *
     * @param address the address to get the token account for
     * @param token the token to get the token account for
     * @returns the token account for the address and token
     */
    getTokenAccount(address: UniversalOrNative<C>, token: TokenAddress<C>): Promise<ChainAddress<C>>;
    /**
     * Check to see if a given protocol is supported by this chain
     * by checking if it is registered in the platform and the configuration
     * is available and correct
     *
     * @param protocolName the name of the Protocol to check for support
     * @returns a boolean indicating if this protocol is supported
     */
    supportsProtocol(protocolName: ProtocolName): boolean;
    /**
     * Construct a protocol client for the given protocol
     *
     * Note: If no contracts are passed, we assume the default contracts should be used
     * and that the protocol client is cacheable
     *
     * @param protocolName The name of the protocol to construct a client for
     * @returns An instance of the protocol client that implements the protocol interface for the chain
     */
    getProtocol<PN extends ProtocolName>(protocolName: PN, contracts?: Contracts, rpc?: RpcConnection<P>): Promise<ProtocolInstance<P, PN, N, C>>;
    /**
     * Check to see if the Wormhole Core protocol is supported by this chain
     * @returns a boolean indicating if this chain supports the Wormhole Core protocol
     */
    supportsWormholeCore: () => boolean;
    /**
     * Get the Wormhole Core protocol client for this chain
     * @returns the Wormhole Core protocol client for this chain
     */
    getWormholeCore: () => Promise<WormholeCore<N, C>>;
    /**
     * Check to see if the Token Bridge protocol is supported by this chain
     * @returns a boolean indicating if this chain supports the Token Bridge protocol
     */
    supportsTokenBridge: () => boolean;
    /**
     * Get the Token Bridge protocol client for this chain
     * @returns the Token Bridge protocol client for this chain
     */
    getTokenBridge: () => Promise<TokenBridge<N, C>>;
    /**
     * Check to see if the Automatic Token Bridge protocol is supported by this chain
     * @returns  a boolean indicating if this chain supports the Automatic Token Bridge protocol
     */
    supportsAutomaticTokenBridge: () => boolean;
    /**
     * Get the Automatic Token Bridge protocol client for this chain
     * @returns the Automatic Token Bridge protocol client for this chain
     */
    getAutomaticTokenBridge: () => Promise<AutomaticTokenBridge<N, C>>;
    /**
     * Check to see if the Circle Bridge protocol is supported by this chain
     * @returns a boolean indicating if this chain supports the Circle Bridge protocol
     */
    supportsCircleBridge: () => boolean;
    /**
     * Get the Circle Bridge protocol client for this chain
     * @returns the Circle Bridge protocol client for this chain
     */
    getCircleBridge: () => Promise<CircleBridge<N, C>>;
    /**
     * Check to see if the Automatic Circle Bridge protocol is supported by this chain
     * @returns a boolean indicating if this chain supports the Automatic Circle Bridge protocol
     */
    supportsAutomaticCircleBridge: () => boolean;
    /**
     * Get the Automatic Circle Bridge protocol client for this chain
     * @returns the Automatic Circle Bridge protocol client for this chain
     */
    getAutomaticCircleBridge: () => Promise<AutomaticCircleBridge<N, C>>;
    /**
     * Check to see if the IBC Bridge protocol is supported by this chain
     * @returns a boolean indicating if this chain supports the IBC Bridge protocol
     */
    supportsIbcBridge: () => boolean;
    /**
     * Get the IBC Bridge protocol client for this chain
     * @returns the IBC Bridge protocol client for this chain
     */
    getIbcBridge: () => Promise<IbcBridge<N, C>>;
    /**
     * Check to see if the Portico Bridge protocol is supported by this chain
     * @returns a boolean indicating if this chain supports the Portico Bridge protocol
     */
    supportsPorticoBridge: () => boolean;
    /**
     * Get the Portico Bridge protocol client for this chain
     * @returns the Portico Bridge protocol client for this chain
     */
    getPorticoBridge: () => Promise<PorticoBridge<N, C>>;
}
//# sourceMappingURL=chain.d.ts.map