import type { ChainId, ChainsConfig, Contracts, Network, VAA, WormholeCore, WormholeMessageId } from "@wormhole-foundation/sdk-connect";
import type { AlgorandChains, AnyAlgorandAddress, TransactionSet } from "@wormhole-foundation/sdk-algorand";
import { AlgorandUnsignedTransaction } from "@wormhole-foundation/sdk-algorand";
import type { Algodv2, SuggestedParams } from "algosdk";
import { LogicSigAccount } from "algosdk";
export declare class AlgorandWormholeCore<N extends Network, C extends AlgorandChains> implements WormholeCore<N, C> {
    readonly network: N;
    readonly chain: C;
    readonly connection: Algodv2;
    readonly contracts: Contracts;
    readonly chainId: ChainId;
    readonly coreAppId: bigint;
    readonly coreAppAddress: string;
    readonly tokenBridgeAppId: bigint;
    readonly tokenBridgeAppAddress: string;
    static MAX_SIGS_PER_TXN: number;
    static ALGO_VERIFY_HASH: string;
    static ALGO_VERIFY: Uint8Array;
    static feeKey: string;
    static verifyVaa: Uint8Array;
    static verifySigs: Uint8Array;
    static publishMessage: Uint8Array;
    constructor(network: N, chain: C, connection: Algodv2, contracts: Contracts);
    getGuardianSet(index: number): Promise<WormholeCore.GuardianSet>;
    verifyMessage(sender: AnyAlgorandAddress, vaa: VAA, appId?: bigint): AsyncGenerator<AlgorandUnsignedTransaction<N, C>, void, unknown>;
    static fromRpc<N extends Network>(connection: Algodv2, config: ChainsConfig<N, "Algorand">): Promise<AlgorandWormholeCore<N, AlgorandChains>>;
    publishMessage(sender: AnyAlgorandAddress, message: Uint8Array): AsyncGenerator<AlgorandUnsignedTransaction<N, C>, void, unknown>;
    /**
     * Return the message fee for the core bridge
     * @param client An Algodv2 client
     * @param bridgeId The application ID of the core bridge
     * @returns Promise with the message fee for the core bridge
     */
    getMessageFee(): Promise<bigint>;
    getGuardianSetIndex(): Promise<number>;
    parseTransaction(txId: string): Promise<WormholeMessageId[]>;
    parseMessages(txId: string): Promise<VAA<"Uint8Array">[]>;
    private parseTx;
    /**
     * Constructs opt in transactions
     * @param client An Algodv2 client
     * @param senderAddr Sender address
     * @param appId Application ID
     * @param storage StorageLogicSig
     * @returns Address and array of TransactionSignerPairs
     */
    static maybeCreateStorageTx(client: Algodv2, senderAddr: string, appId: bigint, storage: LogicSigAccount, suggestedParams?: SuggestedParams): Promise<TransactionSet>;
    /**
     * Submits just the header of the VAA
     * @param client AlgodV2 client
     * @param bridgeId Application ID of the core bridge
     * @param vaa The VAA (just the header is used)
     * @param senderAddr Sending account address
     * @param appid Application ID
     * @returns Promise with current VAA state
     */
    static submitVAAHeader(client: Algodv2, coreId: bigint, appid: bigint, vaa: VAA, senderAddr: string, suggestedParams?: SuggestedParams): Promise<TransactionSet>;
    private createUnsignedTx;
}
//# sourceMappingURL=core.d.ts.map