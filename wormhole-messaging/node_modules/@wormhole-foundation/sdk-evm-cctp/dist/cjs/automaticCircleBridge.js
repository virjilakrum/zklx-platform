"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmAutomaticCircleBridge = void 0;
const sdk_connect_1 = require("@wormhole-foundation/sdk-connect");
const index_js_1 = require("./index.js");
const sdk_evm_1 = require("@wormhole-foundation/sdk-evm");
require("@wormhole-foundation/sdk-evm-core");
require("@wormhole-foundation/sdk-evm-tokenbridge");
class EvmAutomaticCircleBridge {
    network;
    chain;
    provider;
    contracts;
    circleRelayer;
    chainId;
    tokenAddr;
    // https://github.com/wormhole-foundation/wormhole-connect/blob/development/sdk/src/contexts/eth/context.ts#L379
    constructor(network, chain, provider, contracts) {
        this.network = network;
        this.chain = chain;
        this.provider = provider;
        this.contracts = contracts;
        if (network === 'Devnet')
            throw new Error('AutomaticCircleBridge not supported on Devnet');
        this.chainId = sdk_connect_1.nativeChainIds.networkChainToNativeChainId.get(network, chain);
        const relayerAddress = this.contracts.cctp?.wormholeRelayer;
        if (!relayerAddress)
            throw new Error(`Wormhole Circle relayer contract for domain ${chain} not found`);
        this.circleRelayer = index_js_1.ethers_contracts.CircleRelayer__factory.connect(relayerAddress, provider);
        const tokenAddr = sdk_connect_1.circle.usdcContract.get(this.network, this.chain);
        if (!tokenAddr)
            throw new Error(`USDC contract not found for ${this.network} ${this.chain}`);
        this.tokenAddr = tokenAddr;
    }
    static async fromRpc(provider, config) {
        const [network, chain] = await sdk_evm_1.EvmPlatform.chainFromRpc(provider);
        const conf = config[chain];
        if (conf.network !== network)
            throw new Error(`Network mismatch: ${conf.network} != ${network}`);
        return new EvmAutomaticCircleBridge(network, chain, provider, conf.contracts);
    }
    async getRelayerFee(destination) {
        return this.circleRelayer.relayerFee((0, sdk_connect_1.toChainId)(destination), this.tokenAddr);
    }
    async *transfer(sender, recipient, amount, nativeGas) {
        const senderAddr = new sdk_evm_1.EvmAddress(sender).toString();
        const recipientChainId = (0, sdk_connect_1.chainToChainId)(recipient.chain);
        const recipientAddress = recipient.address
            .toUniversalAddress()
            .toUint8Array();
        const nativeTokenGas = nativeGas ? nativeGas : 0n;
        const tokenContract = sdk_evm_1.EvmPlatform.getTokenImplementation(this.provider, this.tokenAddr);
        const allowance = await tokenContract.allowance(senderAddr, this.circleRelayer.target);
        if (allowance < amount) {
            const txReq = await tokenContract.approve.populateTransaction(this.circleRelayer.target, amount);
            yield this.createUnsignedTx((0, sdk_evm_1.addFrom)(txReq, senderAddr), 'ERC20.approve of CircleRelayer');
        }
        const txReq = await this.circleRelayer.transferTokensWithRelay.populateTransaction(this.tokenAddr, amount, nativeTokenGas, recipientChainId, recipientAddress);
        yield this.createUnsignedTx((0, sdk_evm_1.addFrom)(txReq, senderAddr), 'CircleRelayer.transfer');
    }
    createUnsignedTx(txReq, description, parallelizable = false) {
        return new sdk_evm_1.EvmUnsignedTransaction((0, sdk_evm_1.addChainId)(txReq, this.chainId), this.network, this.chain, description, parallelizable);
    }
}
exports.EvmAutomaticCircleBridge = EvmAutomaticCircleBridge;
//# sourceMappingURL=automaticCircleBridge.js.map