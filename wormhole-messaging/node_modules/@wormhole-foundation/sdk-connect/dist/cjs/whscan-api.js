"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIsVaaEnqueued = exports.getGovernorLimits = exports.getGovernedTokens = exports.getGuardianHeartbeats = exports.getTxsByAddress = exports.getVaaByTxHashWithRetry = exports.getVaaByTxHash = exports.getRelayStatusWithRetry = exports.getRelayStatus = exports.getTransactionStatusWithRetry = exports.getTransactionStatus = exports.getVaaWithRetry = exports.getVaa = exports.getVaaBytesWithRetry = exports.getVaaBytes = exports.WHSCAN_RETRY_INTERVAL = void 0;
const sdk_base_1 = require("@wormhole-foundation/sdk-base");
const sdk_definitions_1 = require("@wormhole-foundation/sdk-definitions");
const axios_1 = __importDefault(require("axios"));
const tasks_js_1 = require("./tasks.js");
exports.WHSCAN_RETRY_INTERVAL = 2000;
/**
 * Gets the bytes of a VAA for a given WormholeMessageId or `null` if the VAA is not available yet.
 * @param apiUrl the url of the wormholescan API
 * @param whm the WormholeMessageId
 * @returns a Uint8Array containing the VAA or `null` if it's not available yet
 * @throws Errors if the service throws an unrecoverable error (e.g. 500)
 */
async function getVaaBytes(apiUrl, whm) {
    const { chain, emitter, sequence } = whm;
    const chainId = (0, sdk_base_1.toChainId)(chain);
    const emitterAddress = sdk_base_1.encoding.stripPrefix("0x", emitter.toString());
    const url = `${apiUrl}/v1/signed_vaa/${chainId}/${emitterAddress}/${sequence}`;
    try {
        const { data: { vaaBytes }, } = await axios_1.default.get(url);
        return sdk_base_1.encoding.b64.decode(vaaBytes);
    }
    catch (error) {
        if (!error)
            return null;
        if (typeof error === "object") {
            // A 404 error means the VAA is not yet available
            // since its not available yet, we return null signaling it can be tried again
            if (axios_1.default.isAxiosError(error) && error.response?.status === 404)
                return null;
            if ("status" in error && error.status === 404)
                return null;
        }
        throw error;
    }
}
exports.getVaaBytes = getVaaBytes;
async function getVaaBytesWithRetry(apiUrl, whm, timeout) {
    const task = () => getVaaBytes(apiUrl, whm);
    return await (0, tasks_js_1.retry)(task, exports.WHSCAN_RETRY_INTERVAL, timeout, "Wormholescan:GetVaaBytes");
}
exports.getVaaBytesWithRetry = getVaaBytesWithRetry;
async function getVaa(apiUrl, whm, decodeAs) {
    const vaaBytes = await getVaaBytes(apiUrl, whm);
    if (!vaaBytes)
        return null;
    return (0, sdk_definitions_1.deserialize)(decodeAs, vaaBytes);
}
exports.getVaa = getVaa;
async function getVaaWithRetry(apiUrl, whm, decodeAs, timeout) {
    const task = () => getVaa(apiUrl, whm, decodeAs);
    return await (0, tasks_js_1.retry)(task, exports.WHSCAN_RETRY_INTERVAL, timeout, "Wormholescan:GetVaaBytes");
}
exports.getVaaWithRetry = getVaaWithRetry;
/**
 * Gets the status for a transaction given WormholeMessageId or `null` if the VAA is not available yet.
 * @param rpcUrl the url of the wormholescan API
 * @param whm the WormholeMessageId
 * @returns a TransactionStatus or `null` if it's not available yet
 * @throws Errors if the service throws an unrecoverable error (e.g. 500)
 */
async function getTransactionStatus(rpcUrl, whm) {
    const { chain, emitter, sequence } = whm;
    const chainId = (0, sdk_base_1.toChainId)(chain);
    const emitterAddress = emitter.toUniversalAddress().toString();
    const url = `${rpcUrl}/api/v1/transactions/${chainId}/${emitterAddress}/${sequence}`;
    try {
        const response = await axios_1.default.get(url);
        return response.data;
    }
    catch (error) {
        if (!error)
            return null;
        if (typeof error === "object") {
            // A 404 error means the VAA is not yet available
            // since its not available yet, we return null signaling it can be tried again
            if (axios_1.default.isAxiosError(error) && error.response?.status === 404)
                return null;
            if ("status" in error && error.status === 404)
                return null;
        }
        throw error;
    }
}
exports.getTransactionStatus = getTransactionStatus;
async function getTransactionStatusWithRetry(rpcUrl, whm, timeout) {
    const task = () => getTransactionStatus(rpcUrl, whm);
    return await (0, tasks_js_1.retry)(task, exports.WHSCAN_RETRY_INTERVAL, timeout, "Wormholescan:GetTransactionStatus");
}
exports.getTransactionStatusWithRetry = getTransactionStatusWithRetry;
async function getRelayStatus(rpcUrl, txid) {
    const url = `${rpcUrl}/v1/relays?txHash=${txid}`;
    try {
        const response = await axios_1.default.get(url);
        if (response.data.data.to.txHash)
            return response.data.data;
    }
    catch (error) {
        if (!error)
            return null;
        if (typeof error === "object") {
            // A 404 error means the VAA is not yet available
            // since its not available yet, we return null signaling it can be tried again
            if (axios_1.default.isAxiosError(error) && error.response?.status === 404)
                return null;
            if ("status" in error && error.status === 404)
                return null;
        }
        throw error;
    }
    return null;
}
exports.getRelayStatus = getRelayStatus;
async function getRelayStatusWithRetry(rpcUrl, txid, timeout) {
    const task = () => getRelayStatus(rpcUrl, txid);
    return (0, tasks_js_1.retry)(task, exports.WHSCAN_RETRY_INTERVAL, timeout, "Wormholescan:GetRelayStatus");
}
exports.getRelayStatusWithRetry = getRelayStatusWithRetry;
async function getVaaByTxHash(rpcUrl, txid) {
    const url = `${rpcUrl}/api/v1/vaas?txHash=${txid}`;
    try {
        const response = await axios_1.default.get(url);
        if (response.data.data.length > 0)
            return response.data.data[0];
    }
    catch (error) {
        if (!error)
            return null;
        if (typeof error === "object") {
            // A 404 error means the VAA is not yet available
            // since its not available yet, we return null signaling it can be tried again
            if (axios_1.default.isAxiosError(error) && error.response?.status === 404)
                return null;
            if ("status" in error && error.status === 404)
                return null;
        }
        throw error;
    }
    return null;
}
exports.getVaaByTxHash = getVaaByTxHash;
async function getVaaByTxHashWithRetry(rpcUrl, txid, decodeAs, timeout) {
    const task = () => getVaaByTxHash(rpcUrl, txid);
    const vaa = await (0, tasks_js_1.retry)(task, exports.WHSCAN_RETRY_INTERVAL, timeout, "Wormholescan:GetVaaByTxHash");
    if (!vaa)
        return null;
    return (0, sdk_definitions_1.deserialize)(decodeAs, sdk_base_1.encoding.b64.decode(vaa.vaa));
}
exports.getVaaByTxHashWithRetry = getVaaByTxHashWithRetry;
async function getTxsByAddress(rpcUrl, address, pageSize = 50, page = 0) {
    const url = `${rpcUrl}/api/v1/transactions?address=${address}&pageSize=${pageSize}&page=${page}`;
    try {
        const response = await axios_1.default.get(url);
        if (response.data.transactions.length > 0)
            return response.data.transactions;
    }
    catch (error) {
        if (!error)
            return null;
        if (typeof error === "object") {
            // A 404 error means the VAA is not yet available
            // since its not available yet, we return null signaling it can be tried again
            if (axios_1.default.isAxiosError(error) && error.response?.status === 404)
                return null;
            if ("status" in error && error.status === 404)
                return null;
        }
        throw error;
    }
    return null;
}
exports.getTxsByAddress = getTxsByAddress;
async function getGuardianHeartbeats(rpcUrl) {
    const url = `${rpcUrl}/v1/heartbeats`;
    try {
        const response = await axios_1.default.get(url);
        if (response.data && response.data.entries.length > 0)
            return response.data.entries;
    }
    catch { }
    return null;
}
exports.getGuardianHeartbeats = getGuardianHeartbeats;
async function getGovernedTokens(rpcUrl) {
    const url = `${rpcUrl}/v1/governor/token_list`;
    try {
        const response = await axios_1.default.get(url);
        if (response.data && response.data.entries.length > 0) {
            return response.data.entries.reduce((acc, entry) => {
                const chain = (0, sdk_base_1.toChain)(entry.originChainId);
                acc[chain] = acc[chain] || {};
                acc[chain][entry.originAddress] = entry.price;
                return acc;
            }, {});
        }
    }
    catch { }
    return null;
}
exports.getGovernedTokens = getGovernedTokens;
async function getGovernorLimits(rpcUrl) {
    const url = `${rpcUrl}/v1/governor/available_notional_by_chain`;
    try {
        const response = await axios_1.default.get(url);
        if (response.data && response.data.entries.length > 0) {
            return response.data.entries.reduce((acc, entry) => {
                // if 0 consider it no limit
                const maxSize = entry.bigTransactionSize === "0"
                    ? undefined
                    : sdk_base_1.amount.whole(sdk_base_1.amount.parse(entry.bigTransactionSize, 2));
                acc[(0, sdk_base_1.toChain)(entry.chainId)] = {
                    available: sdk_base_1.amount.whole(sdk_base_1.amount.parse(entry.remainingAvailableNotional, 2)),
                    limit: sdk_base_1.amount.whole(sdk_base_1.amount.parse(entry.notionalLimit, 2)),
                    maxSize,
                };
                return acc;
            }, {});
        }
    }
    catch { }
    return null;
}
exports.getGovernorLimits = getGovernorLimits;
// TODO: returning bool or null is asking for trouble
async function getIsVaaEnqueued(rpcUrl, whm) {
    const { chain, emitter, sequence } = whm;
    const chainId = (0, sdk_base_1.toChainId)(chain);
    const emitterAddress = emitter.toUniversalAddress().toString();
    const url = `${rpcUrl}/v1/governor/is_vaa_enqueued/${chainId}/${emitterAddress}/${sequence}`;
    try {
        const response = await axios_1.default.get(url);
        return response.data.isEnqueued;
    }
    catch { }
    return null;
}
exports.getIsVaaEnqueued = getIsVaaEnqueued;
//# sourceMappingURL=whscan-api.js.map