import type { Chain, Network, Platform } from "@wormhole-foundation/sdk-base";
import type { ChainAddress, ChainContext, Contracts, NativeAddress, PayloadDiscriminator, PayloadLiteral, PlatformContext, PlatformUtils, TokenAddress, TokenId, TxHash, WormholeMessageId, deserialize } from "@wormhole-foundation/sdk-definitions";
import type { WormholeConfig, WormholeConfigOverrides } from "./config.js";
import { CircleTransfer } from "./protocols/cctp/cctpTransfer.js";
import { TokenTransfer } from "./protocols/tokenBridge/tokenTransfer.js";
import type { RouteConstructor } from "./routes/index.js";
import { RouteResolver } from "./routes/resolver.js";
import type { TransactionStatus } from "./whscan-api.js";
type PlatformMap<N extends Network, P extends Platform = Platform> = Map<P, PlatformContext<N, P>>;
type ChainMap<N extends Network, C extends Chain = Chain> = Map<C, ChainContext<N, C>>;
export declare class Wormhole<N extends Network> {
    protected readonly _network: N;
    protected _platforms: PlatformMap<N>;
    protected _chains: ChainMap<N>;
    readonly config: WormholeConfig<N>;
    constructor(network: N, platforms: PlatformUtils<any>[], config?: WormholeConfigOverrides<N>);
    get network(): N;
    /**
     * Creates a CircleTransfer object to move Native USDC from one chain to another
     * @param amount the amount to transfer
     * @param from the address to transfer from
     * @param to the address to transfer to
     * @param automatic whether to use automatic delivery
     * @param payload the payload to send with the transfer
     * @param nativeGas the amount of native gas to send with the transfer
     * @returns the CircleTransfer object
     * @throws Errors if the chain or protocol is not supported
     */
    circleTransfer(amount: bigint, from: ChainAddress, to: ChainAddress, automatic: boolean, payload?: Uint8Array, nativeGas?: bigint): Promise<CircleTransfer<N>>;
    /**
     * Creates a TokenTransfer object to move a token from one chain to another
     * @param token the token to transfer
     * @param amount the amount to transfer
     * @param from the address to transfer from
     * @param to the address to transfer to
     * @param automatic whether to use automatic delivery
     * @param payload the payload to send with the transfer
     * @param nativeGas the amount of native gas to send with the transfer
     * @returns the TokenTransfer object
     * @throws Errors if the chain or protocol is not supported
     */
    tokenTransfer(token: TokenId, amount: bigint, from: ChainAddress, to: ChainAddress, automatic: boolean, payload?: Uint8Array, nativeGas?: bigint): Promise<TokenTransfer<N>>;
    /**
     * Gets a RouteResolver configured with the routes passed
     * @param routes the list RouteConstructors to use
     * @returns the RouteResolver
     */
    resolver(routes: RouteConstructor[]): RouteResolver<N>;
    /**
     * Gets the contract addresses for a given chain
     * @param chain the chain name
     * @returns the contract addresses
     */
    getContracts(chain: Chain): Contracts | undefined;
    /**
     * Returns the platform object, i.e. the class with platform-specific logic and methods
     * @param chain the platform name
     * @returns the platform context class
     * @throws Errors if platform is not found
     */
    getPlatform<P extends Platform>(platformName: P): PlatformContext<N, P>;
    /**
     * Returns the chain "context", i.e. the class with chain-specific logic and methods
     * @param chain the chain name
     * @returns the chain context class
     * @throws Errors if context is not found
     */
    getChain<C extends Chain>(chain: C): ChainContext<N, C>;
    /**
     * Gets the TokenId for a token representation on any chain
     *  These are the Wormhole wrapped token addresses, not necessarily
     *  the cannonical version of that token
     *
     * @param chain The chain name to get the wrapped token address
     * @param tokenId The Token ID (chain/address) of the original token
     * @returns The TokenId on the given chain, null if it does not exist
     * @throws Errors if the chain is not supported or the token does not exist
     */
    getWrappedAsset<C extends Chain>(chain: C, token: TokenId<Chain>): Promise<TokenId<C>>;
    /**
     *  Taking the original TokenId for some wrapped token chain
     *  These are the Wormhole wrapped token addresses, not necessarily
     *  the cannonical version of that token
     *
     * @param tokenId The Token ID of the token we're looking up the original asset for
     * @returns The Original TokenId corresponding to the token id passed,
     * @throws Errors if the chain is not supported or the token does not exist
     */
    getOriginalAsset<C extends Chain>(token: TokenId<C>): Promise<TokenId<Chain>>;
    /**
     * Gets the number of decimals for a token on a given chain
     *
     * @param chain The chain name or id of the token/representation
     * @param token The token address
     * @returns The number of decimals
     */
    getDecimals<C extends Chain>(chain: C, token: TokenAddress<C>): Promise<number>;
    /**
     * Fetches the balance of a given token for a wallet
     *
     * @param walletAddress The wallet address
     * @param tokenId The token ID (its home chain and address on the home chain)
     * @param chain The chain name or id
     * @returns The token balance of the wormhole asset as a BigNumber
     */
    getBalance<C extends Chain>(chain: C, token: TokenAddress<C>, walletAddress: string): Promise<bigint | null>;
    /**
     * Gets the associated token account for chains that require it (only Solana currently).
     *
     * @param token the TokenId of the token to get the token account for
     * @param recipient the address of the primary account that may require a separate token account
     * @returns
     */
    getTokenAccount<C extends Chain>(recipient: ChainAddress<C>, token: TokenId<C>): Promise<ChainAddress<C>>;
    /**
     * Gets the Raw VAA Bytes from the API or Guardian RPC, finality must be met before the VAA will be available.
     *
     * @param wormholeMessageId The WormholeMessageId corresponding to the VAA to be fetched
     * @param timeout The total amount of time to wait for the VAA to be available
     * @returns The VAA bytes if available
     * @throws Errors if the VAA is not available after the retries
     */
    getVaaBytes(wormholeMessageId: WormholeMessageId, timeout?: number): Promise<Uint8Array | null>;
    /**
     * Gets a VAA from the API or Guardian RPC, finality must be met before the VAA will be available.
     *
     * @param id The WormholeMessageId or Transaction hash corresponding to the VAA to be fetched
     * @param decodeAs The VAA type to decode the bytes as
     * @param timeout The total amount of time to wait for the VAA to be available
     * @returns The VAA if available
     * @throws Errors if the VAA is not available after the retries
     */
    getVaa<T extends PayloadLiteral | PayloadDiscriminator>(id: WormholeMessageId | TxHash, decodeAs: T, timeout?: number): Promise<ReturnType<typeof deserialize<T>> | null>;
    /**
     * Gets the CircleAttestation corresponding to the message hash logged in the transfer transaction.
     * @param msgHash  The keccak256 hash of the message emitted by the circle contract
     * @param timeout The total amount of time to wait for the VAA to be available
     * @returns The CircleAttestation as a string, if available
     * @throws Errors if the CircleAttestation is not available after the retries
     */
    getCircleAttestation(msgHash: string, timeout?: number): Promise<string | null>;
    /**
     * Get the status of a transaction, identified by the chain, emitter address, and sequence number
     *
     * @param id the message id for the Wormhole Message to get transaction status for or originating Transaction hash
     * @returns the TransactionStatus
     */
    getTransactionStatus(id: WormholeMessageId | TxHash, timeout?: number): Promise<TransactionStatus | null>;
    /**
     * Get recent transactions for an address
     *
     * @param address the string formatted address to get transactions for
     * @returns the TransactionStatus
     */
    getTransactionsForAddress(address: string, pageSize?: number, page?: number): Promise<TransactionStatus[] | null>;
    /**
     * Parse an address from its canonincal string format to a NativeAddress
     *
     * @param chain The chain the address is for
     * @param address The address in canonical string format
     * @returns The address in the NativeAddress format
     */
    static parseAddress<C extends Chain>(chain: C, address: string): NativeAddress<C>;
    /**
     * Return a string in the canonical chain format representing the address
     * of a token or account
     *
     * @param chainAddress The ChainAddress or TokenId to get a string address
     * @returns The string address in canonical format for the chain
     */
    static canonicalAddress(chainAddress: ChainAddress | TokenId): string;
    /**
     * Parse an address from its canonincal string format to a NativeAddress
     *
     * @param chain The chain the address is for
     * @param address The native address in canonical string format
     * @returns The ChainAddress
     */
    static chainAddress<C extends Chain>(chain: C, address: string): ChainAddress<C>;
    /**
     * Parse an address from its canonincal string format to a NativeAddress
     *
     * @param chain The chain the address is for
     * @param address The native address in canonical string format or the string "native"
     * @returns The ChainAddress
     */
    static tokenId<C extends Chain>(chain: C, address: string): TokenId<C>;
    /**
     * Parses all relevant information from a transaction given the sending tx hash and sending chain
     *
     * @param chain The sending chain name or context
     * @param tx The sending transaction hash
     * @returns The parsed WormholeMessageId
     */
    static parseMessageFromTx<N extends Network, C extends Chain>(chain: ChainContext<N, C>, txid: TxHash, timeout?: number): Promise<WormholeMessageId[]>;
}
export {};
//# sourceMappingURL=wormhole.d.ts.map