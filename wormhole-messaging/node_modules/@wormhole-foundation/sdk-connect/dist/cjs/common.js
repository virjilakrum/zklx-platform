"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signAndSendWait = exports.signSendWait = void 0;
const sdk_definitions_1 = require("@wormhole-foundation/sdk-definitions");
async function signSendWait(chain, xfer, signer) {
    if (!(0, sdk_definitions_1.isSigner)(signer))
        throw new Error("Invalid signer, not SignAndSendSigner or SignOnlySigner");
    const signSend = async (txns) => (0, sdk_definitions_1.isSignAndSendSigner)(signer)
        ? signer.signAndSend(txns)
        : chain.sendWait(await signer.sign(txns));
    const txHashes = await ssw(xfer, signSend);
    return txHashes.map((txid) => ({ chain: chain.chain, txid }));
}
exports.signSendWait = signSendWait;
async function signAndSendWait(xfer, signer) {
    if (!(0, sdk_definitions_1.isSignAndSendSigner)(signer))
        throw new Error("Invalid signer, only SignAndSendSigner may call this method");
    const signSend = (txs) => signer.signAndSend(txs);
    const txHashes = await ssw(xfer, signSend);
    return txHashes.map((txid) => ({ chain: signer.chain(), txid }));
}
exports.signAndSendWait = signAndSendWait;
async function ssw(xfer, signSend) {
    const txids = [];
    let txbuff = [];
    for await (const tx of xfer) {
        // buffer transactions as long as they are
        // marked as parallelizable
        if (tx.parallelizable) {
            txbuff.push(tx);
        }
        else {
            // if we find one is not parallelizable
            // flush the buffer then sign and send the
            // current tx
            if (txbuff.length > 0) {
                txids.push(...(await signSend(txbuff)));
                txbuff = [];
            }
            // Note: it may be possible to group this tx with
            // those in the buffer if there are any but
            // the parallelizable flag alone is not enough to signal
            // if this is safe
            txids.push(...(await signSend([tx])));
        }
    }
    if (txbuff.length > 0) {
        txids.push(...(await signSend(txbuff)));
    }
    return txids;
}
//# sourceMappingURL=common.js.map