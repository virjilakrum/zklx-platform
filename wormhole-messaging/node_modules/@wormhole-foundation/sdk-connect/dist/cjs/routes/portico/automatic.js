"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutomaticPorticoRoute = exports.BPS_PER_HUNDRED_PERCENT = exports.SLIPPAGE_BPS = void 0;
const sdk_base_1 = require("@wormhole-foundation/sdk-base");
const route_js_1 = require("../route.js");
const index_js_1 = require("./../../index.js");
exports.SLIPPAGE_BPS = 15n; // 0.15%
exports.BPS_PER_HUNDRED_PERCENT = 10000n;
class AutomaticPorticoRoute extends route_js_1.AutomaticRoute {
    NATIVE_GAS_DROPOFF_SUPPORTED = false;
    static meta = {
        name: "AutomaticPortico",
    };
    static _supportedTokens = ["WETH", "WSTETH"];
    static supportedNetworks() {
        return ["Mainnet"];
    }
    static supportedChains(network) {
        if (index_js_1.contracts.porticoContractChains.has(network)) {
            return index_js_1.contracts.porticoContractChains.get(network);
        }
        return [];
    }
    static async supportedSourceTokens(fromChain) {
        const { chain } = fromChain;
        const supported = this._supportedTokens
            .map((symbol) => {
            return sdk_base_1.filters.bySymbol(fromChain.config.tokenMap, symbol) ?? [];
        })
            .flat()
            .filter((td) => {
            const localOrEth = !td.original || td.original === "Ethereum";
            const isAvax = chain === "Avalanche" && (0, index_js_1.isNative)(td.address);
            return localOrEth && !isAvax;
        });
        return supported.map((td) => index_js_1.Wormhole.tokenId(chain, td.address));
    }
    static async supportedDestinationTokens(sourceToken, fromChain, toChain) {
        const [, srcTokenAddress] = (0, index_js_1.resolveWrappedToken)(fromChain.network, fromChain.chain, sourceToken);
        const tokenAddress = (0, index_js_1.canonicalAddress)(srcTokenAddress);
        // The token that will be used to bridge
        const pb = await fromChain.getPorticoBridge();
        const transferrableToken = pb.getTransferrableToken(tokenAddress);
        // The tokens that _will_ be received on redemption
        const redeemToken = await index_js_1.TokenTransfer.lookupDestinationToken(fromChain, toChain, transferrableToken);
        // Grab the symbol for the token that gets redeemed
        const redeemTokenDetails = sdk_base_1.filters.byAddress(toChain.config.tokenMap, (0, index_js_1.canonicalAddress)(redeemToken));
        // Find the local/native version of the same token by symbol
        const locallyRedeemable = (sdk_base_1.filters.bySymbol(toChain.config.tokenMap, redeemTokenDetails.symbol) ?? [])
            .filter((td) => {
            return !td.original;
        })
            .map((td) => {
            switch (td.symbol) {
                case "ETH":
                case "WETH":
                    return index_js_1.Wormhole.tokenId(toChain.chain, td.address);
                case "WSTETH":
                    return index_js_1.Wormhole.tokenId(toChain.chain, td.address);
                default:
                    throw new Error("Unknown symbol: " + redeemTokenDetails.symbol);
            }
        });
        return locallyRedeemable;
    }
    static isProtocolSupported(chain) {
        return chain.supportsPorticoBridge();
    }
    async isAvailable() {
        // TODO:
        return true;
    }
    getDefaultOptions() {
        return {};
    }
    async validate(request, params) {
        try {
            if ((0, index_js_1.chainToPlatform)(request.fromChain.chain) !== "Evm" ||
                (0, index_js_1.chainToPlatform)(request.toChain.chain) !== "Evm") {
                throw new Error("Only EVM chains are supported");
            }
            const { fromChain, toChain, source, destination } = request;
            const { network } = fromChain;
            // This may be "native" but we want the token that can actually be bridged
            const [, sourceToken] = (0, index_js_1.resolveWrappedToken)(network, fromChain.chain, source.id);
            const [, destinationToken] = (0, index_js_1.resolveWrappedToken)(network, toChain.chain, destination.id);
            const fromPb = await fromChain.getPorticoBridge();
            const toPb = await toChain.getPorticoBridge();
            const canonicalSourceToken = fromPb.getTransferrableToken((0, index_js_1.canonicalAddress)(sourceToken));
            const canonicalDestinationToken = toPb.getTransferrableToken((0, index_js_1.canonicalAddress)(destinationToken));
            const validatedParams = {
                amount: params.amount,
                options: params.options ?? this.getDefaultOptions(),
                normalizedParams: {
                    amount: request.parseAmount(params.amount),
                    canonicalSourceToken,
                    canonicalDestinationToken,
                    sourceToken,
                    destinationToken,
                },
            };
            return { valid: true, params: validatedParams };
        }
        catch (e) {
            return { valid: false, error: e, params: params };
        }
    }
    async quote(request, params) {
        try {
            const swapAmounts = await this.quoteUniswap(request, params);
            const pb = await request.toChain.getPorticoBridge();
            const fee = await pb.quoteRelay(params.normalizedParams.canonicalDestinationToken.address, params.normalizedParams.destinationToken.address);
            const details = {
                swapAmounts,
                relayerFee: fee,
            };
            let destinationAmount = details.swapAmounts.minAmountFinish - fee;
            if (Number(destinationAmount) < 0) {
                return {
                    success: false,
                    error: new Error(`Amount too low for slippage and fee, would result in negative destination amount (${destinationAmount})`),
                };
            }
            return (await request.displayQuote({
                sourceToken: {
                    token: params.normalizedParams.sourceToken,
                    amount: index_js_1.amount.units(params.normalizedParams.amount),
                },
                destinationToken: {
                    token: params.normalizedParams.destinationToken,
                    amount: details.swapAmounts.minAmountFinish - fee,
                },
                relayFee: {
                    token: params.normalizedParams.destinationToken,
                    amount: fee,
                },
            }, params, details));
        }
        catch (e) {
            return {
                success: false,
                error: e,
            };
        }
    }
    async initiate(request, sender, quote, to) {
        const { params, details } = quote;
        const sourceToken = request.source.id.address;
        const destToken = request.destination.id;
        const fromPorticoBridge = await request.fromChain.getPorticoBridge();
        const xfer = fromPorticoBridge.transfer(index_js_1.Wormhole.parseAddress(sender.chain(), sender.address()), to, sourceToken, index_js_1.amount.units(params.normalizedParams.amount), destToken, details);
        const txids = await (0, index_js_1.signSendWait)(request.fromChain, xfer, sender);
        const receipt = {
            originTxs: txids,
            state: index_js_1.TransferState.SourceInitiated,
            from: request.fromChain.chain,
            to: request.toChain.chain,
        };
        return receipt;
    }
    async *track(receipt, timeout) {
        if (!(0, index_js_1.isSourceInitiated)(receipt))
            throw new Error("Source must be initiated");
        const { txid } = receipt.originTxs[receipt.originTxs.length - 1];
        const vaa = await this.wh.getVaa(txid, "TokenBridge:TransferWithPayload", timeout);
        if (!vaa)
            throw new Error("No VAA found for transaction: " + txid);
        const parsed = index_js_1.PorticoBridge.deserializePayload(vaa.payload.payload);
        yield { ...receipt, vaa, parsed };
    }
    async complete(signer, receipt) {
        if (!(0, index_js_1.isAttested)(receipt))
            throw new Error("Source must be attested");
        const toChain = await this.wh.getChain(receipt.to);
        const toPorticoBridge = await toChain.getPorticoBridge();
        const sender = index_js_1.Wormhole.chainAddress(signer.chain(), signer.address());
        const xfer = toPorticoBridge.redeem(sender.address, receipt.attestation.attestation);
        return await (0, index_js_1.signSendWait)(toChain, xfer, signer);
    }
    async quoteUniswap(request, params) {
        const fromPorticoBridge = await request.fromChain.getPorticoBridge();
        const startQuote = await fromPorticoBridge.quoteSwap(params.normalizedParams.sourceToken.address, params.normalizedParams.canonicalSourceToken.address, index_js_1.amount.units(params.normalizedParams.amount));
        const startSlippage = (startQuote * exports.SLIPPAGE_BPS) / exports.BPS_PER_HUNDRED_PERCENT;
        if (startSlippage >= startQuote)
            throw new Error("Start slippage too high");
        const toPorticoBridge = await request.toChain.getPorticoBridge();
        const minAmountStart = startQuote - startSlippage;
        const finishQuote = await toPorticoBridge.quoteSwap(params.normalizedParams.canonicalDestinationToken.address, params.normalizedParams.destinationToken.address, minAmountStart);
        const finishSlippage = (finishQuote * exports.SLIPPAGE_BPS) / exports.BPS_PER_HUNDRED_PERCENT;
        if (finishSlippage >= finishQuote)
            throw new Error("Finish slippage too high");
        const minAmountFinish = finishQuote - finishSlippage;
        const amountFinishQuote = await toPorticoBridge.quoteSwap(params.normalizedParams.canonicalDestinationToken.address, params.normalizedParams.destinationToken.address, startQuote);
        // the expected receive amount is the amount out from the swap
        // minus 5bps slippage
        const amountFinishSlippage = (amountFinishQuote * 5n) / exports.BPS_PER_HUNDRED_PERCENT;
        if (amountFinishSlippage >= amountFinishQuote)
            throw new Error("Amount finish slippage too high");
        const amountFinish = amountFinishQuote - amountFinishSlippage;
        if (amountFinish <= minAmountFinish)
            throw new Error("Amount finish too low");
        return {
            minAmountStart: minAmountStart,
            minAmountFinish: minAmountFinish,
            amountFinish: amountFinish,
        };
    }
}
exports.AutomaticPorticoRoute = AutomaticPorticoRoute;
//# sourceMappingURL=automatic.js.map