import type { Chain } from "@wormhole-foundation/sdk-base";
import type { PayloadDiscriminator, PayloadLiteral, TxHash, WormholeMessageId } from "@wormhole-foundation/sdk-definitions";
import { deserialize } from "@wormhole-foundation/sdk-definitions";
export declare const WHSCAN_RETRY_INTERVAL = 2000;
/**
 * The status of a transaction
 *
 * contains information about the transaction and the global transaction if it was relayed
 */
export interface TransactionStatus {
    id: string;
    timestamp: string;
    txHash: string;
    emitterChain: number;
    emitterAddress: string;
    emitterNativeAddress: string;
    payload: {
        amount: string;
        callerAppId: string;
        fee: string;
        fromAddress: string;
        parsedPayload: any;
        payload: string;
        payloadType: number;
        toAddress: string;
        toChain: number;
        tokenAddress: string;
        tokenChain: number;
    };
    standardizedProperties: {
        amount: string;
        appIds: string[];
        fee: string;
        feeAddress: string;
        feeChain: number;
        fromAddress: string;
        fromChain: number;
        toAddress: string;
        toChain: number;
        tokenAddress: string;
        tokenChain: number;
    };
    globalTx?: {
        id: string;
        originTx: {
            txHash: string;
            from: string;
            status: string;
        };
        destinationTx?: {
            chainId: number;
            status: string;
            method: string;
            txHash: string;
            from: string;
            to: string;
            blockNumber: string;
            timestamp: string;
            updatedAt: string;
        };
    };
}
export interface RelayData {
    from: {
        chain: string;
        chainId: number;
        txHash: string;
        senderAddress: string;
        symbol: string;
        amountSent: number;
        amountToSwap: number;
        estimatedNativeAssetAmount: number;
    };
    vaa: string;
    status: string;
    fee: {
        amount: number;
        symbol: string;
    };
    error: any;
    to: {
        chain: string;
        chainId: number;
        recipientAddress: string;
        txHash: string;
        gasUsed: number;
        nativeAssetSymbol: string;
        nativeAssetReceived: number;
    };
    metrics: {
        receivedAt: string;
        completedAt: string;
        failedAt: any;
        attempts: number;
        maxAttempts: number;
        waitingForTxInMs: number;
        waitingForWalletInMs: number;
    };
}
export interface ApiVaa {
    sequence: number;
    id: string;
    version: number;
    emitterChain: number;
    emitterAddr: string;
    emitterNativeAddr: string;
    guardianSetIndex: number;
    vaa: string;
    timestamp: string;
    updatedAt: string;
    indexedAt: string;
    txHash: string;
}
/**
 * Gets the bytes of a VAA for a given WormholeMessageId or `null` if the VAA is not available yet.
 * @param apiUrl the url of the wormholescan API
 * @param whm the WormholeMessageId
 * @returns a Uint8Array containing the VAA or `null` if it's not available yet
 * @throws Errors if the service throws an unrecoverable error (e.g. 500)
 */
export declare function getVaaBytes(apiUrl: string, whm: WormholeMessageId): Promise<Uint8Array | null>;
export declare function getVaaBytesWithRetry(apiUrl: string, whm: WormholeMessageId, timeout: number): Promise<Uint8Array | null>;
export declare function getVaa<T extends PayloadLiteral | PayloadDiscriminator>(apiUrl: string, whm: WormholeMessageId, decodeAs: T): Promise<ReturnType<typeof deserialize<T>> | null>;
export declare function getVaaWithRetry<T extends PayloadLiteral | PayloadDiscriminator>(apiUrl: string, whm: WormholeMessageId, decodeAs: T, timeout: number): Promise<ReturnType<typeof deserialize<T>> | null>;
/**
 * Gets the status for a transaction given WormholeMessageId or `null` if the VAA is not available yet.
 * @param rpcUrl the url of the wormholescan API
 * @param whm the WormholeMessageId
 * @returns a TransactionStatus or `null` if it's not available yet
 * @throws Errors if the service throws an unrecoverable error (e.g. 500)
 */
export declare function getTransactionStatus(rpcUrl: string, whm: WormholeMessageId): Promise<TransactionStatus | null>;
export declare function getTransactionStatusWithRetry(rpcUrl: string, whm: WormholeMessageId, timeout: number): Promise<TransactionStatus | null>;
export declare function getRelayStatus(rpcUrl: string, txid: TxHash): Promise<RelayData | null>;
export declare function getRelayStatusWithRetry(rpcUrl: string, txid: TxHash, timeout: number): Promise<RelayData | null>;
export declare function getVaaByTxHash(rpcUrl: string, txid: string): Promise<ApiVaa | null>;
export declare function getVaaByTxHashWithRetry<T extends PayloadLiteral | PayloadDiscriminator>(rpcUrl: string, txid: TxHash, decodeAs: T, timeout: number): Promise<ReturnType<typeof deserialize<T>> | null>;
export declare function getTxsByAddress(rpcUrl: string, address: string, pageSize?: number, page?: number): Promise<TransactionStatus[] | null>;
export type GuardianHeartbeat = {
    p2pNodeAddr: string;
    rawHeartbeat: {
        bootTimestamp: string;
        counter: string;
        features: string[];
        guardianAddr: string;
        networks: {
            contractAddress: string;
            errorCount: string;
            height: string;
            id: number;
        }[];
        nodeName: string;
        timestamp: string;
        version: string;
    };
    verifiedGuardianAddr: string;
};
export declare function getGuardianHeartbeats(rpcUrl: string): Promise<GuardianHeartbeat[] | null>;
export type GovernedTokens = {
    [chain in Chain]?: Record<string, number>;
};
export declare function getGovernedTokens(rpcUrl: string): Promise<GovernedTokens | null>;
export type GovernorChainLimit = {
    available: number;
    limit: number;
    maxSize?: number;
};
export type GovernorLimits = {
    [chain in Chain]?: GovernorChainLimit;
};
export declare function getGovernorLimits(rpcUrl: string): Promise<GovernorLimits | null>;
export declare function getIsVaaEnqueued(rpcUrl: string, whm: WormholeMessageId): Promise<boolean | null>;
//# sourceMappingURL=whscan-api.d.ts.map