import type { AccountAddress, Chain, ChainAddress, ChainId, ChainsConfig, Contracts, NativeAddress, Network, Platform, TokenAddress, TokenBridge, TokenId } from "@wormhole-foundation/sdk-connect";
import { UniversalAddress } from "@wormhole-foundation/sdk-connect";
import type { AlgorandChains, AnyAlgorandAddress } from "@wormhole-foundation/sdk-algorand";
import { AlgorandUnsignedTransaction } from "@wormhole-foundation/sdk-algorand";
import { AlgorandWormholeCore } from "@wormhole-foundation/sdk-algorand-core";
import type { Algodv2, SuggestedParams } from "algosdk";
import { ABIMethod } from "algosdk";
import "@wormhole-foundation/sdk-algorand-core";
export declare const TransferMethodSelector: ABIMethod;
export declare class AlgorandTokenBridge<N extends Network, C extends AlgorandChains> implements TokenBridge<N, C> {
    readonly network: N;
    readonly chain: C;
    readonly connection: Algodv2;
    readonly contracts: Contracts;
    readonly chainId: ChainId;
    readonly coreBridge: AlgorandWormholeCore<N, C>;
    readonly coreAppId: bigint;
    readonly coreAppAddress: string;
    readonly tokenBridgeAppId: bigint;
    readonly tokenBridgeAddress: string;
    static sendTransfer: Uint8Array;
    static attestToken: Uint8Array;
    static noop: Uint8Array;
    static optIn: Uint8Array;
    static completeTransfer: Uint8Array;
    static receiveAttest: Uint8Array;
    constructor(network: N, chain: C, connection: Algodv2, contracts: Contracts);
    static fromRpc<N extends Network>(provider: Algodv2, config: ChainsConfig<N, Platform>): Promise<AlgorandTokenBridge<N, AlgorandChains>>;
    isWrappedAsset(token: TokenAddress<C>): Promise<boolean>;
    getOriginalAsset(token: TokenAddress<C>): Promise<TokenId>;
    getTokenUniversalAddress(token: TokenAddress<C>): Promise<UniversalAddress>;
    getWrappedAsset(token: TokenId<Chain>): Promise<NativeAddress<C>>;
    hasWrappedAsset(token: TokenId<Chain>): Promise<boolean>;
    getWrappedNative(): Promise<NativeAddress<C>>;
    isTransferCompleted(vaa: TokenBridge.TransferVAA): Promise<boolean>;
    createAttestation(token: TokenAddress<C>, payer?: AnyAlgorandAddress): AsyncGenerator<AlgorandUnsignedTransaction<N, C>, void, unknown>;
    submitAttestation(vaa: TokenBridge.AttestVAA, sender?: AnyAlgorandAddress, suggestedParams?: SuggestedParams): AsyncGenerator<AlgorandUnsignedTransaction<N, C>>;
    transfer(sender: AccountAddress<C>, recipient: ChainAddress<C>, token: TokenAddress<C>, amount: bigint, payload?: Uint8Array): AsyncGenerator<AlgorandUnsignedTransaction<N, C>>;
    redeem(sender: AnyAlgorandAddress, vaa: TokenBridge.TransferVAA, unwrapNative?: boolean, suggestedParams?: SuggestedParams): AsyncGenerator<AlgorandUnsignedTransaction<N, C>, void, unknown>;
    /**
     * Checks if the asset has been opted in by the receiver
     * @param client Algodv2 client
     * @param asset Algorand asset index
     * @param receiver Account address
     * @returns Promise with True if the asset was opted in, False otherwise
     */
    static isOptedInToAsset(client: Algodv2, address: string, asset: number): Promise<boolean>;
    private createUnsignedTx;
}
//# sourceMappingURL=tokenBridge.d.ts.map