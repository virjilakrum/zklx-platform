import { UniversalAddress, createVAA, encoding, toChainId } from "@wormhole-foundation/sdk-connect";
import { AptosPlatform } from "@wormhole-foundation/sdk-aptos";
export class AptosWormholeCore {
    network;
    chain;
    connection;
    contracts;
    chainId;
    coreBridge;
    constructor(network, chain, connection, contracts) {
        this.network = network;
        this.chain = chain;
        this.connection = connection;
        this.contracts = contracts;
        this.chainId = toChainId(chain);
        const coreBridgeAddress = contracts.coreBridge;
        if (!coreBridgeAddress)
            throw new Error(`CoreBridge contract Address for chain ${chain} not found`);
        this.coreBridge = coreBridgeAddress;
    }
    getGuardianSet(index) {
        throw new Error("Method not implemented.");
    }
    getGuardianSetIndex() {
        throw new Error("Method not implemented.");
    }
    getMessageFee() {
        throw new Error("Method not implemented.");
    }
    static async fromRpc(connection, config) {
        const [network, chain] = await AptosPlatform.chainFromRpc(connection);
        const conf = config[chain];
        if (conf.network !== network)
            throw new Error(`Network mismatch: ${conf.network} !== ${network}`);
        return new AptosWormholeCore(network, chain, connection, conf.contracts);
    }
    async *publishMessage(sender, message) {
        throw new Error("Method not implemented.");
    }
    async *verifyMessage(sender, vaa) {
        throw new Error("Not implemented.");
    }
    async parseTransaction(txid) {
        const msgs = await this.parseMessages(txid);
        return msgs.map((message) => {
            return {
                chain: message.emitterChain,
                emitter: message.emitterAddress,
                sequence: message.sequence,
            };
        });
    }
    async parseMessages(txid) {
        const transaction = await this.connection.getTransactionByHash(txid);
        if (transaction.type !== "user_transaction")
            throw new Error(`${txid} is not a user_transaction`);
        const userTransaction = transaction;
        const messages = userTransaction.events.filter((event) => event.type.endsWith("WormholeMessage"));
        if (!messages || messages.length === 0)
            throw new Error(`WormholeMessage not found for ${txid}`);
        return messages.map((message) => {
            const msg = message.data;
            const emitter = new UniversalAddress(BigInt(msg.sender).toString(16).padStart(64, "0"));
            return createVAA("Uint8Array", {
                guardianSet: 0, // TODO: need to implement guardian set idx
                emitterChain: this.chain,
                emitterAddress: emitter,
                sequence: BigInt(msg.sequence),
                timestamp: Number(msg.timestamp),
                consistencyLevel: msg.consistency_level,
                nonce: Number(msg.nonce),
                signatures: [],
                payload: encoding.hex.decode(msg.payload),
            });
        });
    }
}
//# sourceMappingURL=core.js.map